<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="毕业后就一直混迹在深圳的不知名攻城狮"><meta name="baidu-site-verification" content="code-osvb6rgMcu"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.5"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.5"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><title>jvm基础-GC垃圾回收 | sunshine-zwq</title><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">jvm基础-GC垃圾回收</h1><a id="logo" href="/.">sunshine-zwq</a><p class="description">Where there is a will, there is a way.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">jvm基础-GC垃圾回收</h1><div class="post-meta"><a href="/2020/12/26/jvm%E5%9F%BA%E7%A1%80-GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/#comments" class="comment-count"></a><p><span class="date">2020/12/26</span><span><a href="/categories/jvm/" class="category">jvm</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="1-GC垃圾收集机制"><a href="#1-GC垃圾收集机制" class="headerlink" title="1.GC垃圾收集机制"></a>1.GC垃圾收集机制</h2><p>对于GC垃圾收集机制，我们需要记住以下几点：</p>
<ol>
<li>次数上频繁收集Young区。</li>
<li>次数上较少收集Old区。</li>
<li>基本不动元空间。</li>
</ol>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201223/028.png" alt=""></p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201223/029.png" alt=""></p>
<p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。<br>因此GC按照回收的区域又分了两种类型，一种是普通GC（minor GC），一种是全局GC（major GC or Full GC）。</p>
<p><strong>Minor GC和Full GC的区别：</strong><br> <strong>（1）普通GC（minor GC）</strong>：只针对新生代区域的GC，指发生在新生代的垃圾收集动作，因为大多数Java对象存活率都不高，所以Minor GC非常频繁，一般回收速度也比较快。<br> <strong>（2）全局GC（major GC or Full GC）</strong>：指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC（但并不是绝对的）。Major GC的速度一般要比Minor GC慢上10倍以上。</p>
<h2 id="2-GC日志信息详解"><a href="#2-GC日志信息详解" class="headerlink" title="2.GC日志信息详解"></a>2.GC日志信息详解</h2><p>通过 java 命令后添加参数<code>-XX:+PrintGCDetails</code>查看。</p>
<p><strong>（1）YGC相关参数：</strong></p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201223/030.png" alt=""></p>
<p><strong>（2）FGC相关参数：</strong></p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201223/031.png" alt=""></p>
<h2 id="3-GC四大算法"><a href="#3-GC四大算法" class="headerlink" title="3.GC四大算法"></a>3.GC四大算法</h2><h3 id="3-1-如何判断Java中对象是否存活？"><a href="#3-1-如何判断Java中对象是否存活？" class="headerlink" title="3.1 如何判断Java中对象是否存活？"></a>3.1 如何判断Java中对象是否存活？</h3><p>通过<strong>根搜索方法</strong>判断。<strong>根搜索方法</strong>是通过一些<code>GCRoots</code>对象作为起点，从这些节点开始往下搜索，搜索通过的路径成为引用链（ReferenceChain），当一个对象没有被<code>GCRoots</code>的引用链连接的时候，说明这个对象是不可用的。</p>
<p><strong>GCRoots对象包括：</strong></p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li>
<li>方法区域中的类静态属性引用的对象。</li>
<li>方法区域中常量引用的对象。</li>
<li>方法栈中JNI（<code>Native</code>方法）的引用的对象。</li>
</ol>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201223/032.png" alt=""></p>
<h3 id="3-2-四大算法"><a href="#3-2-四大算法" class="headerlink" title="3.2 四大算法"></a>3.2 四大算法</h3><h4 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="(1) 引用计数算法"></a>(1) 引用计数算法</h4><p><strong>引用计数算法</strong>是给每个对象设置一个计数器，当有地方引用这个对象的时候，计数器+1，当引用失效的时候，计数器-1，当计数器为0的时候，JVM就认为该对象不再被使用，是“垃圾”了。</p>
<p>引用计数实现简单，效率高；但是不能解决循环引用问问题（A对象引用B对象，B对象又引用A对象，但是A，B对象已不被任何其他对象引用），同时每次计数器的增加和减少都带来了很多额外的开销，所以在JDK1.1之后，这个算法已经不再使用了。</p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201223/033.png" alt=""></p>
<h4 id="2-复制算法（Copying）：适用于新生代"><a href="#2-复制算法（Copying）：适用于新生代" class="headerlink" title="(2) 复制算法（Copying）：适用于新生代"></a>(2) 复制算法（Copying）：适用于新生代</h4><p><strong>原理分析</strong></p>
<p>虚拟机把新生代分为了三部分：1个<code>Eden</code>区和2个<code>Survivor</code>区（分别叫<code>from</code>和<code>to</code>），默认比例为8:1:1。</p>
<p>一般情况下，新创建的对象都会被分配到<code>Eden</code>区（一些大对象特殊处理），这些对象经过第一次<code>Minor GC</code>后，如果仍然存活，将会被移到<code>Survivor</code>区。对象在<code>Survivor</code>区中每熬过一次<code>Minor GC</code>，年龄 +1，当它的年龄增加到一定程度时（默认是 15 ，通过<code>-XX:MaxTenuringThreshold</code>来设定参数），就会被移动到年老代中。</p>
<p>因为新生代中的对象基本都是<strong>朝生夕死</strong>（被GC回收率90%以上），<strong>所以在新生代的垃圾回收算法使用的是复制算法</strong>。</p>
<p>复制算法的基本思想就是将内存分为两块，每次只用其中一块（<code>from</code>），当这一块内存用完，就将还活着的对象复制到另外一块上面。</p>
<p>我们来举个例子，在GC开始的时候，对象只会存在于<code>Eden</code>区和名为<code>from</code>的<code>Survivor</code>区，<code>Survivor</code>区<code>to</code>是空的。紧接着进行GC，<code>Eden</code>区中所有存活的对象都会被复制到<code>to</code>，而在<code>from</code>区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值（默认15）的对象会被移动到老年代中，没有达到阈值的对象会被复制到<code>to</code>区域。经过这次GC后，<code>Eden</code>区和<code>from</code>区已经被清空。这个时候，<code>from</code>和<code>to</code>会交换他们的角色，也就是新的<code>to</code>就是上次GC前的<code>from</code>，新的<code>from</code>就是上次GC前的<code>to</code>。不管怎样，都会保证名为<code>to</code>的<code>Survivor</code>区域是空的。<code>Minor GC</code>会一直重复这样的过程，直到<code>to</code>区被填满，<strong><code>to</code>区被填满之后，会将所有对象移动到老年代中</strong>。</p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201223/034.png" alt=""></p>
<blockquote>
<p><code>-XX:MaxTenuringThreshold</code>，设置对象在新生代中存活的次数。</p>
<p><strong>误区</strong>：虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
</blockquote>
<p>因为<code>Eden</code>区对象一般存活率较低，一般的，使用两块10%的内存作为空闲和活动区间，而另外80%的内存，则是用来给新建对象分配内存的。一旦发生GC，将10%的<code>from</code>活动区间与另外80%中存活的<code>Eden</code>区对象转移到10%的<code>to</code>空闲区间，接下来，将之前90%的内存全部释放，以此类推。</p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201223/035.gif" alt=""></p>
<p>上面动画中，Area空闲代表to，Area激活代表from，绿色代表不被回收的，红色代表被回收的。</p>
<p><strong>优缺点</strong></p>
<p>优点 ：不会产生内存碎片，效率高。<br>缺点 ：耗费内存空间。</p>
<p>如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。</p>
<p>所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。</p>
<h4 id="3-标记清除（Mark-Sweep）：适用于老年代"><a href="#3-标记清除（Mark-Sweep）：适用于老年代" class="headerlink" title="(3) 标记清除（Mark-Sweep）：适用于老年代"></a>(3) 标记清除（Mark-Sweep）：适用于老年代</h4><p><strong>原理分析</strong></p>
<p>标记清除算法，主要分成标记和清除两个阶段，先标记出要回收的对象，然后统一回收这些对象，如下图：</p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201223/036.png" alt=""></p>
<p>简单来说，标记清除算法就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将要回收的对象标记一遍，最终统一回收这些对象，完成标记清理工作接下来便让应用程序恢复运行。</p>
<p>主要进行两项工作，第一项则是标记，第二项则是清除。</p>
<ul>
<li>标记：从引用根节点开始标记遍历所有的<code>GC Roots</code>， 先标记出要回收的对象。</li>
<li>清除：遍历整个堆，把标记的对象清除。</li>
</ul>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201223/037.gif" alt=""></p>
<p><strong>优缺点</strong></p>
<p>优点 ：不需要额外的内存空间。<br>缺点 ：需要暂停整个应用，会产生内存碎片；两次扫描，耗时严重。</p>
<p>简单来说，它的缺点就是<strong>效率比较低</strong>（递归与全堆对象遍历），而且在进行GC的时候，需要停止应用程序，这会导致用户体验非常差劲。</p>
<p>而且这种方式<strong>清理出来的空闲内存是不连续</strong>的，这点不难理解，我们的死亡对象都是随机分布在内存当中，现在把它们清除之后，内存的布局自然会零碎不连续。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。并且在分配数组对象的时候，需要去内存寻找连续的内存空间，但此时的内存空间太过零碎分散，因此资源耗费加大。</p>
<h4 id="4-标记压缩（Mark-Compact）：适用于老年代"><a href="#4-标记压缩（Mark-Compact）：适用于老年代" class="headerlink" title="(4) 标记压缩（Mark-Compact）：适用于老年代"></a>(4) 标记压缩（Mark-Compact）：适用于老年代</h4><p><strong>原理分析</strong></p>
<p>简单来说，就是<strong>先标记，后整理</strong>，如下图所示：</p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201223/038.png" alt=""></p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201223/039.gif" alt=""></p>
<p><strong>优缺点</strong></p>
<p>优点 ：没有内存碎片。<br>缺点 ：需要移动对象的成本，效率也不高（不仅要标记所有存活对象，还要整理所有存活对象的引用地址）。</p>
<p><strong>标记清除压缩</strong></p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201223/040.png" alt=""></p>
<h3 id="3-3-分代收集算法"><a href="#3-3-分代收集算法" class="headerlink" title="3.3 分代收集算法"></a>3.3 分代收集算法</h3><p>当前商业虚拟机都是采用分代收集算法，它根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，然后根据各个年代的特点采用最适当的垃圾收集算法。<br>在新生代中，每次垃圾收集都发现有大批对象死去，只有少量存活，就选用<strong>复制算法</strong>，而老年代因为对象存活率高，没有额外空间对它进行分配担保，就必须使用<strong>标记清除</strong>或者<strong>标记压缩</strong>算法来进行回收。</p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201223/041.png" alt=""></p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><h3 id="4-1-年轻代（Young-Gen）"><a href="#4-1-年轻代（Young-Gen）" class="headerlink" title="4.1 年轻代（Young Gen）"></a>4.1 年轻代（Young Gen）</h3><p><strong>年轻代特点是内存空间相对老年代较小，对象存活率低。</strong></p>
<p>复制算法的效率只和当前存活对象大小有关，因而很适用于年轻代的回收。而复制算法的内存利用率不高的问题，可以通过虚拟机中的两个<code>Survivor</code>区设计得到缓解。</p>
<h3 id="4-2-老年代（Tenure-Gen）"><a href="#4-2-老年代（Tenure-Gen）" class="headerlink" title="4.2 老年代（Tenure Gen）"></a>4.2 老年代（Tenure Gen）</h3><p><strong>老年代的特点是内存空间较大，对象存活率高。</strong></p>
<p>这种情况，存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记清除或者是标记清除与标记整理的混合实现。</p>
<p>（1）<strong>标记阶段（Mark）</strong> 的开销与存活对象的数量成正比。这点上说来，对于老年代，标记清除或者标记整理有一些不符，但可以通过多核/线程利用，对并发、并行的形式提高标记效率。<br>（2）<strong>清除阶段（Sweep）</strong> 的开销与所管理内存空间大小形正相关。但Sweep“就地处决”的特点，回收的过程没有对象的移动。使其相对其他有对象移动步骤的回收算法，仍然是效率最好的。但是需要解决内存碎片问题。<br>（3）<strong>整理阶段（Compact）</strong> 的开销与存活对象的数据成开比。如上一条所描述，对于大量对象的移动是很大开销的，做为老年代的第一选择并不合适。</p>
<p>基于上面的考虑，<strong>老年代一般是由标记清除或者是标记清除与标记整理的混合实现</strong>。以虚拟机中的CMS回收器为例，CMS是基于<code>Mark-Sweep</code>实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于<code>Mark-Compact</code>算法的Serial Old回收器做为补偿措施：当内存回收不佳（碎片导致的<code>Concurrent Mode Failure</code>时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</p>
<h2 id="5-常见问题"><a href="#5-常见问题" class="headerlink" title="5.常见问题"></a>5.常见问题</h2><p>(1).GC四种算法哪个好？</p>
<p>没有哪个算法是能一次性解决所有问题的，因为JVM垃圾回收使用的是分代收集算法，没有最好的算法，只有根据每一代他的垃圾回收的特性用对应的算法。例如新生代使用复制算法，老年代使用标记清除和标记整理算法。<br>所以说，没有最好的垃圾回收机制，只有最合适的。</p>
<p>(2).请说出各个垃圾回收算法的优缺点</p>
<p><strong>（1）内存效率：</strong> 复制算法 &gt; 标记清除算法 &gt; 标记整理算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。<br><strong>（2）内存整齐度：</strong> 复制算法 = 标记整理算法 &gt; 标记清除算法。<br><strong>（3）内存利用率：</strong> 标记整理算法 = 标记清除算法 &gt; 复制算法。</p>
<p>可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记清除多了一个整理内存的过程。</p>
<p>参考链接：<a href="https://blog.csdn.net/qq_33366229/article/details/93194267" target="_blank" rel="noopener">GC四大算法</a></p>
</div><div class="post-copyright"><blockquote><p>原文作者: zwq</p><p>原文链接: <a href="https://sunshine-zwq.gitee.io/2020/12/26/jvm基础-GC垃圾回收/">https://sunshine-zwq.gitee.io/2020/12/26/jvm基础-GC垃圾回收/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/java/">java</a><a href="/tags/jvm/">jvm</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2020/12/29/JDK%E4%B8%ADbin%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="pre">JDK中bin目录下常用命令</a><a href="/2020/12/26/jvm%E5%9F%BA%E7%A1%80-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" class="next">jvm基础-体系结构及底层原理</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-GC垃圾收集机制"><span class="toc-text">1.GC垃圾收集机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-GC日志信息详解"><span class="toc-text">2.GC日志信息详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-GC四大算法"><span class="toc-text">3.GC四大算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-如何判断Java中对象是否存活？"><span class="toc-text">3.1 如何判断Java中对象是否存活？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-四大算法"><span class="toc-text">3.2 四大算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-引用计数算法"><span class="toc-text">(1) 引用计数算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-复制算法（Copying）：适用于新生代"><span class="toc-text">(2) 复制算法（Copying）：适用于新生代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-标记清除（Mark-Sweep）：适用于老年代"><span class="toc-text">(3) 标记清除（Mark-Sweep）：适用于老年代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-标记压缩（Mark-Compact）：适用于老年代"><span class="toc-text">(4) 标记压缩（Mark-Compact）：适用于老年代</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-分代收集算法"><span class="toc-text">3.3 分代收集算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-总结"><span class="toc-text">4.总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-年轻代（Young-Gen）"><span class="toc-text">4.1 年轻代（Young Gen）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-老年代（Tenure-Gen）"><span class="toc-text">4.2 老年代（Tenure Gen）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-常见问题"><span class="toc-text">5.常见问题</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/01/01/jvm%E9%AB%98%E7%BA%A7-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">jvm高级-常见问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/30/Java%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/">Java中的强引用、软引用、弱引用、虚引用</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/29/JDK%E4%B8%ADbin%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">JDK中bin目录下常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/26/jvm%E5%9F%BA%E7%A1%80-GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">jvm基础-GC垃圾回收</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/26/jvm%E5%9F%BA%E7%A1%80-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">jvm基础-体系结构及底层原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-AQS/">Java并发编程常见问题-AQS</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C/">Java并发编程常见问题-线程协作</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/18/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-Future%E4%B8%8ECallable/">Java并发编程常见问题-Future与Callable</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/18/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-ThreadLocal/">Java并发编程常见问题-ThreadLocal</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/17/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/">Java并发编程常见问题-阻塞队列</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node-js/">Node.js</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js/">Vue.js</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ftp/">ftp</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/jvm/">jvm</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 15px;">面试</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">并发编程</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/gitee/" style="font-size: 15px;">gitee</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/element-ui/" style="font-size: 15px;">element-ui</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/json/" style="font-size: 15px;">json</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/jdk/" style="font-size: 15px;">jdk</a> <a href="/tags/ftp/" style="font-size: 15px;">ftp</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/js%E6%A8%A1%E5%9D%97%E5%8C%96/" style="font-size: 15px;">js模块化</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a> <a href="/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 15px;">正则表达式</a> <a href="/tags/Node-js/" style="font-size: 15px;">Node.js</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 15px;">工具</a> <a href="/tags/ECMAScript/" style="font-size: 15px;">ECMAScript</a> <a href="/tags/java8/" style="font-size: 15px;">java8</a> <a href="/tags/Lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/Stream/" style="font-size: 15px;">Stream</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">26</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://github.com/sunshine-zwq" title="我的Github" target="_blank">我的Github</a><ul></ul><a href="https://blog.csdn.net/zwq1105" title="我的CSDN博客" target="_blank">我的CSDN博客</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">zwq.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.5"></script><div id="fullscreen-img" class="hide"><span class="close"></span></div><script type="text/javascript" src="/js/imgview.js?v=2.0.5" async></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.5" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>