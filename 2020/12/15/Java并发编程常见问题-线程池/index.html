<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="毕业后就一直混迹在深圳的不知名攻城狮"><meta name="baidu-site-verification" content="code-osvb6rgMcu"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.5"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.5"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><title>Java并发编程常见问题-线程池 | sunshine-zwq</title><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java并发编程常见问题-线程池</h1><a id="logo" href="/.">sunshine-zwq</a><p class="description">Where there is a will, there is a way.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Java并发编程常见问题-线程池</h1><div class="post-meta"><a href="/2020/12/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#comments" class="comment-count"></a><p><span class="date">2020/12/15</span><span><a href="/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="category">Java并发编程</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="1-使用线程池比手动创建线程好在哪里？"><a href="#1-使用线程池比手动创建线程好在哪里？" class="headerlink" title="1.使用线程池比手动创建线程好在哪里？"></a>1.使用线程池比手动创建线程好在哪里？</h2><p><strong>为什么要使用线程池？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123; </span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task());</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如代码所示，我们创建了 10000 个子线程，而 Java 程序中的线程与操作系统中的线程是一一对应的，此时假设线程中的任务需要一定的耗时才能够完成，便会产生很大的系统开销与资源浪费。</p>
<p><strong>创建线程时会产生系统开销，并且每个线程还会占用一定的内存等资源</strong>，更重要的是我们创建如此多的线程也会给稳定性带来危害，因为每个系统中，可创建线程的数量是有一个上限的，不可能无限的创建。<strong>线程执行完需要被回收，大量的线程又会给垃圾回收带来压力</strong>。但我们的任务确实非常多，如果都在主线程串行执行，那效率也太低了，那应该怎么办呢？于是便诞生了线程池来平衡线程与系统资源之间的关系。</p>
<p>如果每个任务都创建一个线程会带来的问题：</p>
<ol>
<li>第一点，反复创建线程系统开销比较大，每个线程创建和销毁都需要时间，如果任务比较简单，那么就有<strong>可能导致创建和销毁线程消耗的资源比线程执行任务本身消耗的资源还要大</strong>。</li>
<li>第二点，<strong>过多的线程会占用过多的内存等资源，还会带来过多的上下文切换，同时还会导致系统不稳定</strong>。</li>
</ol>
<p><strong>线程池解决问题思路</strong></p>
<p>针对上面的两点问题，线程池有两个解决思路：</p>
<p>首先，针对反复创建线程开销大的问题，线程池用一些固定的线程一直保持工作状态并反复执行任务。</p>
<p>其次，针对过多线程占用太多内存资源的问题，解决思路更直接，线程池会根据需要创建线程，控制线程的总数量，避免占用过多内存资源。</p>
<p><strong>如何使用线程池</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 描述：     用固定线程数的线程池执行10000个任务 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123; </span><br><span class="line">            service.execute(<span class="keyword">new</span> Task());</span><br><span class="line">        &#125; </span><br><span class="line">    	System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            System.out.println(<span class="string">"Thread Name: "</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Thread Name: pool-1-thread-1</span><br><span class="line">Thread Name: pool-1-thread-2</span><br><span class="line">Thread Name: pool-1-thread-3</span><br><span class="line">Thread Name: pool-1-thread-4</span><br><span class="line">Thread Name: pool-1-thread-5</span><br><span class="line">Thread Name: pool-1-thread-5</span><br><span class="line">Thread Name: pool-1-thread-5</span><br><span class="line">Thread Name: pool-1-thread-5</span><br><span class="line">Thread Name: pool-1-thread-5</span><br><span class="line">Thread Name: pool-1-thread-2</span><br><span class="line">Thread Name: pool-1-thread-1</span><br><span class="line">Thread Name: pool-1-thread-5</span><br><span class="line">Thread Name: pool-1-thread-3</span><br><span class="line">Thread Name: pool-1-thread-5</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如打印结果所示，打印的线程名始终在 Thread Name: pool-1-thread-1~5 之间变化，并没有超过这个范围，也就证明了线程池不会无限制地扩张线程的数量，始终是这5个线程在工作。</p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201214/001.png" alt=""></p>
<p>执行流程如图所示，首先创建了一个线程池，线程池中有 5 个线程，然后线程池将 10000 个任务分配给这 5 个线程，这 5 个线程反复领取任务并执行，直到所有任务执行完毕，这就是线程池的思想。</p>
<p><strong>使用线程池的好处</strong></p>
<ol>
<li>第一点，线程池可以解决线程生命周期的系统开销问题，同时还可以加快响应速度。因为线程池中的线程是可以复用的，我们只用少量的线程去执行大量的任务，这就大大减小了线程生命周期的开销。而且线程通常不是等接到任务后再临时创建，而是已经创建好时刻准备执行任务，这样就消除了线程创建所带来的延迟，提升了响应速度，增强了用户体验。</li>
<li>第二点，线程池可以统筹内存和 CPU 的使用，避免资源使用不当。线程池会根据配置和任务数量灵活地控制线程数量，不够的时候就创建，太多的时候就回收，避免线程过多导致内存溢出，或线程太少导致 CPU 资源浪费，达到了一个完美的平衡。</li>
<li>第三点，线程池可以统一管理资源。比如线程池可以统一管理任务队列和线程，可以统一开始或结束任务，比单个线程逐一处理任务要更方便、更易于管理，同时也有利于数据统计，比如我们可以很方便地统计出已经执行过的任务的数量。</li>
</ol>
<h2 id="2-线程池的各个参数的含义"><a href="#2-线程池的各个参数的含义" class="headerlink" title="2.线程池的各个参数的含义"></a>2.线程池的各个参数的含义</h2><p><strong>线程池的参数</strong></p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201214/002.png" alt=""></p>
<p><strong>线程创建的时机</strong></p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201214/003.png" alt=""></p>
<p>如上图所示，当提交任务后，线程池首先会检查当前线程数，如果此时线程数小于核心线程数，比如最开始线程数量为 0，则新建线程并执行任务，随着任务的不断增加，线程数会逐渐增加并达到核心线程数，此时如果仍有任务被不断提交，就会被放入 workQueue 任务队列中，等待核心线程执行完当前任务后重新从 workQueue 中提取正在等待被执行的任务。</p>
<p>此时，假设我们的任务特别的多，已经达到了 workQueue 的容量上限，这时线程池就会启动后备力量，也就是 maximumPoolSize 最大线程数，线程池会在 corePoolSize 核心线程数的基础上继续创建线程来执行任务，假设任务被不断提交，线程池会持续创建线程直到线程数达到 maximumPoolSize 最大线程数，如果依然有任务被提交，这就超过了线程池的最大处理能力，这个时候线程池就会拒绝这些任务，我们可以看到实际上任务进来之后，线程池会逐一判断 corePoolSize、workQueue、maximumPoolSize，如果依然不能满足需求，则会拒绝任务。</p>
<p><strong>corePoolSize 与 maximumPoolSize</strong></p>
<p>corePoolSize 指的是核心线程数，线程池初始化时线程数默认为 0，当有新的任务提交后，会创建新线程执行任务，如果不做特殊设置，此后线程数通常不会再小于 corePoolSize ，因为它们是<strong>核心线程，即便未来可能没有可执行的任务也不会被销毁</strong>。随着任务量的增加，<strong>在任务队列满了之后，线程池会进一步创建新线程，最多可以达到 maximumPoolSize 来应对任务多的场景，如果未来线程有空闲，大于 corePoolSize 的线程会被合理回收</strong>。所以正常情况下，线程池中的线程数量会处在 corePoolSize 与 maximumPoolSize 的闭区间内。</p>
<p><strong>“长工”与“临时工”</strong></p>
<p>我们可以把 corePoolSize 与 maximumPoolSize 比喻成长工与临时工，通常古代一个大户人家会有几个固定的长工，负责日常的工作，而大户人家起初肯定也是从零开始雇佣长工的。假如长工数量被老爷设定为 5 人，也就对应了 corePoolSize，不管这 5 个长工是忙碌还是空闲，都会一直在大户人家待着，可到了农忙或春节，长工的人手显然就不够用了，这时就需要雇佣更多的临时工，这些临时工就相当于在 corePoolSize 的基础上继续创建新线程，但临时工也是有上限的，也就对应了 maximumPoolSize，随着农忙或春节结束，老爷考虑到人工成本便会解约掉这些临时工，家里工人数量便会从 maximumPoolSize 降到 corePoolSize，所以老爷家的工人数量会一致保持在 corePoolSize 和 maximumPoolSize 的区间。</p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201214/004.gif" alt=""></p>
<p>总结线程池的几个特点：</p>
<ul>
<li>线程池希望保持较少的线程数，并且只有在负载变得很大时才增加线程。</li>
<li>线程池只有在任务队列填满时才创建多于 corePoolSize 的线程，如果使用的是无界队列（例如 LinkedBlockingQueue），那么由于队列不会满，所以线程数不会超过 corePoolSize。</li>
<li>通过设置 corePoolSize 和 maximumPoolSize 为相同的值，就可以创建固定大小的线程池。</li>
<li>通过设置 maximumPoolSize 为很高的值，例如 Integer.MAX_VALUE，就可以允许线程池创建任意多的线程。</li>
</ul>
<p><strong>keepAliveTime+时间单位</strong></p>
<p>第三个参数是 keepAliveTime + 时间单位，当线程池中线程数量多于核心线程数时，而此时又没有任务可做，线程池就会检测线程的 keepAliveTime，如果超过规定的时间，无事可做的线程就会被销毁，以便减少内存的占用和资源消耗。如果后期任务又多了起来，线程池也会根据规则重新创建线程，所以这是一个可伸缩的过程，比较灵活，我们也可以用 setKeepAliveTime 方法动态改变 keepAliveTime 的参数值。</p>
<p><strong>ThreadFactory</strong></p>
<p>第四个参数是 ThreadFactory，ThreadFactory 实际上是一个线程工厂，它的作用是生产线程以便执行任务。我们可以选择使用默认的线程工厂，创建的线程都会在同一个线程组，并拥有一样的优先级，且都不是守护线程，我们也可以选择自己定制线程工厂，以方便给线程自定义命名，不同的线程池内的线程通常会根据具体业务来定制不同的线程名。</p>
<p><strong>workQueue 和 Handler</strong></p>
<p>最后两个参数是 workQueue 和 Handler，它们分别对应阻塞队列和任务拒绝策略。</p>
<h2 id="3-线程池有哪-4-种拒绝策略？"><a href="#3-线程池有哪-4-种拒绝策略？" class="headerlink" title="3.线程池有哪 4 种拒绝策略？"></a>3.线程池有哪 4 种拒绝策略？</h2><p><strong>拒绝时机</strong></p>
<p>新建线程池时可以指定它的任务拒绝策略，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">5</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(),</span><br><span class="line">   <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br></pre></td></tr></table></figure>

<p>以便在必要的时候按照我们的策略来拒绝任务，那么拒绝任务的时机是什么呢？线程池会在以下两种情况下会拒绝新提交的任务：</p>
<ul>
<li>第一种情况是当我们调用 shutdown 等方法关闭线程池后，即便此时可能线程池内部依然有没执行完的任务正在执行，但是由于线程池已经关闭，此时如果再向线程池内提交任务，就会遭到拒绝。</li>
<li>第二种情况是线程池没有能力继续处理新提交的任务，也就是工作已经非常饱和的时候。</li>
</ul>
<p>第二种情况，比如新建一个线程池，使用容量上限为 10 的 ArrayBlockingQueue 作为任务队列，并且指定线程池的核心线程数为 5，最大线程数为 10，假设此时有 20 个耗时任务被提交，在这种情况下，线程池会首先创建核心数量的线程，也就是5个线程来执行任务，然后往队列里去放任务，队列的 10 个容量被放满了之后，会继续创建新线程，直到达到最大线程数 10。此时线程池中一共有 20 个任务，其中 10 个任务正在被 10 个线程执行，还有 10 个任务在任务队列中等待，而且由于线程池的最大线程数量就是 10，所以已经不能再增加更多的线程来帮忙处理任务了，这就意味着此时线程池工作饱和，这个时候再提交新任务时就会被拒绝。</p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201214/005.png" alt=""></p>
<p><strong>拒绝策略</strong></p>
<p>Java 在 ThreadPoolExecutor 类中为我们提供了 4 种默认的拒绝策略来应对不同的场景，都实现了 RejectedExecutionHandler 接口，如图所示：</p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201214/006.png" alt=""></p>
<ul>
<li>第一种拒绝策略是 <strong>AbortPolicy</strong>，这种拒绝策略在拒绝任务时，会直接<strong>抛出一个类型为 RejectedExecutionException 的 RuntimeException</strong>，让你感知到任务被拒绝了，于是你便可以根据业务逻辑选择重试或者放弃提交等策略。</li>
<li>第二种拒绝策略是 <strong>DiscardPolicy</strong>，这种拒绝策略正如它的名字所描述的一样，当<strong>新任务被提交后直接被丢弃掉，也不会给你任何的通知</strong>，相对而言存在一定的风险，因为我们提交的时候根本不知道这个任务会被丢弃，可能造成数据丢失。</li>
<li>第三种拒绝策略是 <strong>DiscardOldestPolicy</strong>，如果线程池没被关闭且没有能力执行，则<strong>会丢弃任务队列中的头结点，通常是存活时间最长的任务</strong>，这种策略与第二种不同之处在于它丢弃的不是最新提交的，而是队列中存活时间最长的，这样就可以腾出空间给新提交的任务，但同理它也存在一定的数据丢失风险。</li>
<li>第四种拒绝策略是 <strong>CallerRunsPolicy</strong>，相对而言它就比较完善了，当有新任务提交后，如果线程池没被关闭且没有能力执行，则<strong>把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务</strong>。这样做主要有两点好处。<ul>
<li>第一点新提交的任务不会被丢弃，这样也就不会造成业务损失。</li>
<li>第二点好处是，由于谁提交任务谁就要负责执行任务，这样提交任务的线程就得负责执行任务，而执行任务又是比较耗时的，在这段期间，提交任务的线程被占用，也就不会再提交新的任务，减缓了任务提交的速度，相当于是一个负反馈。在此期间，线程池中的线程也可以充分利用这段时间来执行掉一部分任务，腾出一定的空间，相当于是给了线程池一定的缓冲期。</li>
</ul>
</li>
</ul>
<h2 id="4-有哪-6-种常见的线程池？什么是-Java7-的-ForkJoinPool？"><a href="#4-有哪-6-种常见的线程池？什么是-Java7-的-ForkJoinPool？" class="headerlink" title="4.有哪 6 种常见的线程池？什么是 Java7 的 ForkJoinPool？"></a>4.有哪 6 种常见的线程池？什么是 Java7 的 ForkJoinPool？</h2><p>6种常见线程池如下：</p>
<ul>
<li>FixedThreadPool</li>
<li>CachedThreadPool</li>
<li>ScheduledThreadPool</li>
<li>SingleThreadExecutor</li>
<li>SingleThreadScheduledExecutor</li>
<li>ForkJoinPool</li>
</ul>
<p><strong>FixedThreadPool</strong></p>
<p>FixedThreadPool的<strong>核心线程数和最大线程数是一样的</strong>，所以可以把它看作是<strong>固定线程数的线程池</strong>，它的特点是线程池中的线程数除了初始阶段需要从 0 开始增加外，之后的线程数量就是固定的，就算任务数超过线程数，线程池也不会再创建更多的线程来处理任务，而是会把超出线程处理能力的任务放到任务队列中进行等待。而且就算任务队列满了，到了本该继续增加线程数的时候，由于它的最大线程数和核心线程数是一样的，所以也无法再增加新的线程了。</p>
<p><strong>CachedThreadPool</strong></p>
<p>CachedThreadPool可以称作可缓存线程池，它的特点在于<strong>线程数是几乎可以无限增加的</strong>（实际最大可以达到 Integer.MAX_VALUE，为 2^31-1，这个数非常大，所以基本不可能达到），而<strong>当线程闲置时还可以对线程进行回收。也就是说该线程池的线程数量不是固定不变的</strong>，当然它也有一个用于存储提交任务的队列，但这个队列是 <strong>SynchronousQueue，队列的容量为0，实际不存储任何任务，它只负责对任务进行中转和传递</strong>，所以效率比较高。</p>
<p>当我们提交一个任务后，线程池会判断已创建的线程中是否有空闲线程，如果有空闲线程则将任务直接指派给空闲线程，如果没有空闲线程，则新建线程去执行任务，这样就做到了动态地新增线程。当任务执行完之后，假设没有新的任务了，那么大量的闲置线程又会造成内存资源的浪费，这时线程池就会检测线程在 60 秒内有没有可执行任务，如果没有就会被销毁，最终线程数量会减为 0。</p>
<p><strong>ScheduledThreadPool</strong></p>
<p>ScheduledThreadPool支持定时或周期性执行任务。比如每隔 10 秒钟执行一次任务，而实现这种功能的方法主要有 3 种，如代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line">service.schedule(<span class="keyword">new</span> Task(), <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"> </span><br><span class="line">service.scheduleAtFixedRate(<span class="keyword">new</span> Task(), <span class="number">10</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"> </span><br><span class="line">service.scheduleWithFixedDelay(<span class="keyword">new</span> Task(), <span class="number">10</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>3 种方法的区别：</p>
<ul>
<li>第一种方法 schedule 比较简单，表示延迟指定时间后执行一次任务，如果代码中设置参数为 10 秒，也就是 10 秒后执行一次任务后就结束。</li>
<li>第二种方法 scheduleAtFixedRate 表示以固定的频率执行任务，它的第二个参数 initialDelay 表示第一次延时时间，第三个参数 period 表示周期，也就是第一次延时后每次延时多长时间执行一次任务。</li>
<li>第三种方法 scheduleWithFixedDelay 与第二种方法类似，也是周期执行任务，区别在于对周期的定义，之前的 scheduleAtFixedRate 是以任务开始的时间为时间起点开始计时，时间到就开始执行第二次任务，而不管任务需要花多久执行；而 scheduleWithFixedDelay 方法以任务结束的时间为下一次循环的时间起点开始计时。</li>
</ul>
<p><strong>SingleThreadExecutor</strong></p>
<p>SingleThreadExecutor会使用唯一的线程去执行任务，原理和 FixedThreadPool 是一样的，只不过这里线程只有一个，<strong>如果线程在执行任务的过程中发生异常，线程池也会重新创建一个线程来执行后续的任务</strong>。这种线程池由于只有一个线程，所以非常适合用于所有任务都需要按被提交的顺序依次执行的场景，而前几种线程池不一定能够保障任务的执行顺序等于被提交的顺序，因为它们是多线程并行执行的。</p>
<p><strong>SingleThreadScheduledExecutor</strong></p>
<p>SingleThreadScheduledExecutor和第三种 ScheduledThreadPool 线程池非常相似，它只是 ScheduledThreadPool 的一个特例，内部只有一个线程，如源码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>它只是将 ScheduledThreadPool 的核心线程数设置为了 1。</p>
<p>几种线程池的各参数：</p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201214/007.png" alt=""></p>
<p><strong>ForkJoinPool</strong></p>
<p>ForkJoinPool是在 JDK 7 加入的，ForkJoinPool 线程池和之前的线程池有两点非常大的不同之处。第一点是它非常适合执行可以产生子任务的任务。</p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201214/008.png" alt=""></p>
<p>如图所示，我们有一个 Task，这个 Task 可以产生三个子任务，三个子任务并行执行完毕后将结果汇总给 Result，比如说主任务需要执行非常繁重的计算任务，我们就可以把计算拆分成三个部分，这三个部分是互不影响相互独立的，这样就可以利用 CPU 的多核优势，并行计算，然后将结果进行汇总。这里面主要涉及两个步骤，第一步是拆分也就是 Fork，第二步是汇总也就是 Join，这也是 ForkJoinPool 线程池名字的由来。</p>
<p>举个例子，比如面试中经常考到的菲波那切数列，这个数列的特点就是后一项的结果等于前两项的和，第 0 项是 0，第 1 项是 1，那么第 2 项就是 0+1=1，以此类推。我们在写代码时应该首选效率更高的迭代形式或者更高级的乘方或者矩阵公式法等写法，不过假设我们写成了最初版本的递归形式，伪代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Fib f1 = <span class="keyword">new</span> Fib(n - <span class="number">1</span>);</span><br><span class="line">    Fib f2 = <span class="keyword">new</span> Fib(n - <span class="number">2</span>);</span><br><span class="line">    f1.solve();</span><br><span class="line">    f2.solve();</span><br><span class="line">    number = f1.number + f2.number;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到如果 n&lt;=1 则直接返回 n，如果 n&gt;1 ，先将前一项 f1 的值计算出来，然后往前推两项求出 f2 的值，然后将两值相加得到结果，所以我们看到在求和运算中产生了两个子任务。计算 f(4) 的流程如下图所示：</p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201214/009.png" alt=""></p>
<p>在计算 f(4) 时需要首先计算出 f(2) 和 f(3)，而同理，计算 f(3) 时又需要计算 f(1) 和 f(2)，以此类推。</p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201214/010.png" alt=""></p>
<p>这是典型的递归问题，对应到我们的 ForkJoin 模式，如图所示，子任务同样会产生子子任务，最后再逐层汇总，得到最终的结果。</p>
<p>ForkJoinPool 线程池有多种方法可以实现任务的分裂和汇总，其中一种用法如下方代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125; </span><br><span class="line">    Fibonacci f1 = <span class="keyword">new</span> Fibonacci(n - <span class="number">1</span>);</span><br><span class="line">    f1.fork();</span><br><span class="line">    Fibonacci f2 = <span class="keyword">new</span> Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    f2.fork();</span><br><span class="line">    <span class="keyword">return</span> f1.join() + f2.join();</span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>Fibonacci首先继承了 RecursiveTask，RecursiveTask 类是对ForkJoinTask 的一个简单的包装，这时我们重写 compute() 方法，当 n&lt;=1 时直接返回，当 n&gt;1 就创建递归任务，也就是 f1 和 f2，然后我们用 fork() 方法分裂任务并分别执行，最后在 return 的时候，使用 join() 方法把结果汇总，这样就实现了任务的分裂和汇总。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123; </span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">        ForkJoinTask task = forkJoinPool.submit(<span class="keyword">new</span> Fibonacci(i));</span><br><span class="line">        System.out.println(task.get());</span><br><span class="line">    &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码将会打印出斐波那契数列的第 0 到 9 项的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">13</span><br><span class="line">21</span><br><span class="line">34</span><br></pre></td></tr></table></figure>

<p>和线程池的第二点不同之处在于内部结构，之前的线程池所有的线程共用一个队列，但 ForkJoinPool 线程池中每个线程都有自己独立的任务队列，如图所示：</p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201214/011.png" alt=""></p>
<p>ForkJoinPool 线程池内部除了有一个共用的任务队列之外，每个线程还有一个对应的<strong>双端队列 deque</strong>，这时一旦线程中的任务被 Fork 分裂了，分裂出来的子任务放入线程自己的 deque 里，而不是放入公共的任务队列中。如果此时有三个子任务放入线程 t1 的 deque 队列中，对于线程 t1 而言获取任务的成本就降低了，可以直接在自己的任务队列中获取而不必去公共队列中争抢也不会发生阻塞（除了后面会讲到的 steal 情况外），减少了线程间的竞争和切换，是非常高效的。</p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201214/012.png" alt=""></p>
<p>再考虑一种情况，此时线程有多个，而线程 t1 的任务特别繁重，分裂了数十个子任务，但是 t0 此时却无事可做，它自己的 deque 队列为空，这时为了提高效率，t0 就会想办法帮助 t1 执行任务，这就是“work-stealing”（工作窃取）的含义。</p>
<p>双端队列 deque 中，线程 t1 获取任务的逻辑是后进先出，也就是LIFO（Last In Frist Out），而线程 t0 在“steal”偷线程 t1 的 deque 中的任务的逻辑是先进先出，也就是FIFO（Fast In Frist Out），如图所示，图中很好的描述了两个线程使用双端队列分别获取任务的情景。你可以看到，使用 “work-stealing” 算法和双端队列很好地平衡了各线程的负载。</p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201214/013.png" alt=""></p>
<p>最后，我们用一张全景图来描述 ForkJoinPool 线程池的内部结构，你可以看到 ForkJoinPool 线程池和其他线程池很多地方都是一样的，但重点区别在于它每个线程都有一个自己的双端队列来存储分裂出来的子任务。ForkJoinPool 非常适合用于递归的场景，例如树的遍历、最优路径搜索等场景。</p>
<h2 id="5-线程池常用的阻塞队列有哪些？"><a href="#5-线程池常用的阻塞队列有哪些？" class="headerlink" title="5.线程池常用的阻塞队列有哪些？"></a>5.线程池常用的阻塞队列有哪些？</h2><p><strong>线程池内部结构</strong></p>
<p>线程池的内部结构主要由四部分组成，如图所示：</p>
<p><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201214/014.png" alt=""></p>
<ul>
<li>第一部分是线程池管理器，它主要负责管理线程池的创建、销毁、添加任务等管理操作，它是整个线程池的管家。</li>
<li>第二部分是工作线程，也就是图中的线程 t0~t9，这些线程勤勤恳恳地从任务队列中获取任务并执行。</li>
<li>第三部分是任务队列，作为一种缓冲机制，线程池会把当下没有处理的任务放入任务队列中，由于多线程同时从任务队列中获取任务是并发场景，此时就需要任务队列满足线程安全的要求，所以线程池中任务队列采用 BlockingQueue 来保障线程安全。</li>
<li>第四部分是任务，任务要求实现统一的接口，以便工作线程可以处理和执行。</li>
</ul>
<p><strong>阻塞队列</strong><br><img src="https://sunshine-zwq.gitee.io/blog-pic/blogPics/20201214/015.png" alt=""></p>
<p>不同的线程池会选用不同的阻塞队列，常见的5 种线程池对应了 3 种阻塞队列。</p>
<p><strong>LinkedBlockingQueue</strong></p>
<p><strong>对于 FixedThreadPool 和 SingleThreadExector 而言，它们使用的阻塞队列是容量为</strong><br><strong>Integer.MAX_VALUE 的 LinkedBlockingQueue，可以认为是无界队列。</strong>由于 FixedThreadPool<br>线程池的线程数是固定的，所以没有办法增加特别多的线程来处理任务，这时就需要 LinkedBlockingQueue 这样一个没有容量限制的阻塞队列来存放任务。这里需要注意，由于线程池的任务队列永远不会放满，所以线程池只会创建核心线程数量的线程，所以此时的最大线程数对线程池来说没有意义，因为并不会触发生成多于核心线程数的线程。</p>
<p><strong>SynchronousQueue</strong></p>
<p>第二种阻塞队列是 SynchronousQueue，对应的线程池是 CachedThreadPool。线程池 CachedThreadPool 的最大线程数是 Integer 的最大值，可以理解为线程数是可以无限扩展的。CachedThreadPool 和上一种线程池 FixedThreadPool 的情况恰恰相反，FixedThreadPool 的情况是阻塞队列的容量是无限的，而这里 CachedThreadPool 是线程数可以无限扩展，所以 <strong>CachedThreadPool 线程池并不需要一个任务队列来存储任务，因为一旦有任务被提交就直接转发给线程或者创建新线程来执行</strong>，而不需要另外保存它们。</p>
<p>我们自己创建使用 SynchronousQueue 的线程池时，如果不希望任务被拒绝，那么就需要注意设置最大线程数要尽可能大一些，以免发生任务数大于最大线程数时，没办法把任务放到队列中也没有足够线程来执行任务的情况。</p>
<p><strong>DelayedWorkQueue</strong></p>
<p>第三种阻塞队列是DelayedWorkQueue，它对应的线程池分别是 ScheduledThreadPool 和 SingleThreadScheduledExecutor，这两种线程池的最大特点就是可以延迟执行任务，比如说一定时间后执行任务或是每隔一定的时间执行一次任务。<strong>DelayedWorkQueue 的特点是内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构</strong>。之所以线程池 ScheduledThreadPool 和 SingleThreadScheduledExecutor 选择 DelayedWorkQueue，是因为它们本身正是基于时间执行任务的，而延迟队列正好可以把任务按时间进行排序，方便任务的执行。</p>
<h2 id="6-为什么不应该自动创建线程池？"><a href="#6-为什么不应该自动创建线程池？" class="headerlink" title="6.为什么不应该自动创建线程池？"></a>6.为什么不应该自动创建线程池？</h2><p>所谓的自动创建线程池就是直接调用 Executors 的各种方法来生成前面学过的常见的线程池，例如 Executors.newCachedThreadPool()。但这样做是有一定风险的。</p>
<p><strong>FixedThreadPool</strong></p>
<p>首先我们来看第一种线程池 FixedThreadPool， 它是线程数量固定的线程池，如源码所示，newFixedThreadPool 内部实际还是调用了 ThreadPoolExecutor 构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过往构造函数中传参，创建了一个核心线程数和最大线程数相等的线程池，它们的数量也就是我们传入的参数，这里的重点是使用的队列是容量没有上限的 LinkedBlockingQueue，如果我们对任务的处理速度比较慢，那么随着请求的增多，队列中堆积的任务也会越来越多，最终大量堆积的任务会占用大量内存，并发生 OOM ，也就是OutOfMemoryError，这几乎会影响到整个程序，会造成很严重的后果。</p>
<p><strong>SingleThreadExecutor</strong></p>
<p>第二种线程池是 SingleThreadExecutor，我们来分析下创建它的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，newSingleThreadExecutor 和 newFixedThreadPool 的原理是一样的，只不过把核心线程数和最大线程数都直接设置成了 1，但是任务队列仍是无界的 LinkedBlockingQueue，所以也会导致同样的问题，也就是当任务堆积时，可能会占用大量的内存并导致 OOM。</p>
<p><strong>CachedThreadPool</strong></p>
<p>第三种线程池是 CachedThreadPool，创建它的源码下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,<span class="number">60L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 CachedThreadPool 和前面两种线程池不一样的地方在于任务队列使用的是 SynchronousQueue，SynchronousQueue 本身并不存储任务，而是对任务直接进行转发，这本身是没有问题的，但你会发现构造函数的第二个参数被设置成了 Integer.MAX_VALUE，这个参数的含义是最大线程数，所以由于 CachedThreadPool 并不限制线程的数量，当任务数量特别多的时候，就可能会导致创建非常多的线程，最终超过了操作系统的上限而无法创建新线程，或者导致内存不足。</p>
<p><strong>ScheduledThreadPool 和 SingleThreadScheduledExecutor</strong></p>
<p>第四种线程池 ScheduledThreadPool 和第五种线程池 SingleThreadScheduledExecutor 的原理是一样的，创建 ScheduledThreadPool 的源码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这里的 ScheduledThreadPoolExecutor 是 ThreadPoolExecutor 的子类，调用的它的构造方法如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,<span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过源码可以看出，它采用的任务队列是 DelayedWorkQueue，这是一个延迟队列，同时也是一个无界队列，所以和 LinkedBlockingQueue 一样，如果队列中存放过多的任务，就可能导致 OOM。</p>
<p>可以看到，这几种自动创建的线程池都存在风险，相比较而言，我们自己手动创建会更好，因为我们可以更加明确线程池的运行规则，不仅可以选择适合自己的线程数量，更可以在必要的时候拒绝新任务的提交，避免资源耗尽的风险。</p>
<h2 id="7-合适的线程数量是多少？CPU-核心数和线程数的关系？"><a href="#7-合适的线程数量是多少？CPU-核心数和线程数的关系？" class="headerlink" title="7.合适的线程数量是多少？CPU 核心数和线程数的关系？"></a>7.合适的线程数量是多少？CPU 核心数和线程数的关系？</h2><p>我们调整线程池中的线程数量的最主要的目的是为了充分并合理地使用 CPU 和内存等资源，从而最大限度地提高程序的性能。在实际工作中，我们需要根据任务类型的不同选择对应的策略。</p>
<p><strong>CPU 密集型任务</strong></p>
<p>首先，我们来看 CPU 密集型任务，比如加密、解密、压缩、计算等一系列需要大量耗费 CPU 资源的任务。对于这样的任务最佳的线程数为 CPU 核心数的 1~2 倍，如果设置过多的线程数，实际上并不会起到很好的效果。此时假设我们设置的线程数量是 CPU 核心数的 2 倍以上，<strong>因为计算任务非常重，会占用大量的 CPU 资源，所以这时 CPU 的每个核心工作基本都是满负荷的，而我们又设置了过多的线程，每个线程都想去利用 CPU 资源来执行自己的任务，这就会造成不必要的上下文切换，此时线程数的增多并没有让性能提升，反而由于线程数量过多会导致性能下降。</strong></p>
<p>针对这种情况，我们最好还要同时考虑在同一台机器上还有哪些其他会占用过多 CPU 资源的程序在运行，然后对资源使用做整体的平衡。</p>
<p><strong>耗时 IO 型任务</strong></p>
<p>第二种任务是耗时 IO 型，比如数据库、文件的读写，网络通信等任务，这种任务的特点是并不会特别消耗 CPU 资源，但是 IO 操作很耗时，总体会占用比较多的时间。对于这种任务最大线程数一般会大于 CPU 核心数很多倍，因为 <strong>IO 读写速度相比于 CPU 的速度而言是比较慢的，如果我们设置过少的线程数，就可能导致 CPU 资源的浪费。而如果我们设置更多的线程数，那么当一部分线程正在等待 IO 的时候，它们此时并不需要 CPU 来计算，那么另外的线程便可以利用 CPU 去执行其他的任务</strong>，互不影响，这样的话在任务队列中等待的任务就会减少，可以更好地利用资源。</p>
<p>《Java并发编程实战》的作者 Brain Goetz 推荐的计算方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程数 &#x3D; CPU 核心数 *（1+平均等待时间&#x2F;平均工作时间）</span><br></pre></td></tr></table></figure>

<p>通过这个公式，我们可以计算出一个合理的线程数量，如果任务的平均等待时间长，线程数就随之增加，而如果平均工作时间长，也就是对于我们上面的 CPU 密集型任务，线程数就随之减少。</p>
<p>太少的线程数会使得程序整体性能降低，而过多的线程也会消耗内存等其他资源，所以如果想要更准确的话，可以进行压测，监控 JVM 的线程情况以及 CPU 的负载情况，根据实际情况衡量应该创建的线程数，合理并充分利用资源。</p>
<p><strong>结论</strong></p>
<ul>
<li>线程的平均工作时间所占比例越高，就需要越少的线程；</li>
<li>线程的平均等待时间所占比例越高，就需要越多的线程；</li>
<li>针对不同的程序，进行对应的实际测试就可以得到最合适的选择。</li>
</ul>
<h2 id="8-如何根据实际需要，定制自己的线程池？"><a href="#8-如何根据实际需要，定制自己的线程池？" class="headerlink" title="8.如何根据实际需要，定制自己的线程池？"></a>8.如何根据实际需要，定制自己的线程池？</h2><p><strong>核心线程数</strong></p>
<p>合理的线程数量和任务类型，以及 CPU 核心数都有关系，基本结论是线程的平均工作时间所占比例越高，就需要越少的线程；线程的平均等待时间所占比例越高，就需要越多的线程。而对于最大线程数而言，如果我们执行的任务类型不是固定的，比如可能一段时间是 CPU 密集型，另一段时间是 IO 密集型，或是同时有两种任务相互混搭。那么在这种情况下，我们可以把最大线程数设置成核心线程数的几倍，以便应对任务突发情况。当然更好的办法是用不同的线程池执行不同类型的任务，让任务按照类型区分开，而不是混杂在一起。</p>
<p><strong>阻塞队列</strong></p>
<p>对于阻塞队列这个参数而言，我们可以选择之前介绍过的 LinkedBlockingQueue 或者 SynchronousQueue 或者 DelayedWorkQueue，不过还有一种常用的阻塞队列叫 <strong>ArrayBlockingQueue</strong>，它也经常被用于线程池中，这种阻塞队列内部是用数组实现的，<strong>在新建对象的时候要求传入容量值，且后期不能扩容</strong>，所以 ArrayBlockingQueue 的最大的特点就是容量是有限的。这样一来，如果任务队列放满了任务，而且线程数也已经达到了最大值，线程池根据规则就会拒绝新提交的任务，这样一来就可能会产生一定的数据丢失。</p>
<p>但相比于无限增加任务或者线程数导致内存不足，进而导致程序崩溃，数据丢失还是要更好一些的，如果我们使用了 ArrayBlockingQueue 这种阻塞队列，再加上我们限制了最大线程数量，就可以非常有效地防止资源耗尽的情况发生。此时的队列容量大小和 maxPoolSize 是一个 trade-off，<strong>如果我们使用容量更大的队列和更小的最大线程数，就可以减少上下文切换带来的开销，但也可能因此降低整体的吞吐量；如果我们的任务是 IO 密集型，则可以选择稍小容量的队列和更大的最大线程数，这样整体的效率就会更高，不过也会带来更多的上下文切换。</strong></p>
<p><strong>线程工厂</strong></p>
<p>对于线程工厂 threadFactory 这个参数，我们可以使用默认的 defaultThreadFactory，也可以传入自定义的有额外能力的线程工厂，因为我们可能有多个线程池，而不同的线程池之间有必要通过不同的名字来进行区分，所以可以传入能根据业务信息进行命名的线程工厂，以便后续可以根据线程名区分不同的业务进而快速定位问题代码。比如可以通过com.google.common.util.concurrent.ThreadFactoryBuilder 来实现，如代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactoryBuilder builder = <span class="keyword">new</span> ThreadFactoryBuilder();</span><br><span class="line">ThreadFactory rpcFactory = builder.setNameFormat(<span class="string">"rpc-pool-%d"</span>).build();</span><br></pre></td></tr></table></figure>

<p>我们生成了名字为 rpcFactory 的 ThreadFactory，它的 nameFormat 为 “rpc-pool-%d” ，那么它生成的线程的名字是有固定格式的，它生成的线程的名字分别为”rpc-pool-1”，”rpc-pool-2” ，以此类推。</p>
<p><strong>拒绝策略</strong></p>
<p>最后一个参数是拒绝策略，我们可以根据业务需要四种拒绝策略之一来使用：AbortPolicy，DiscardPolicy，DiscardOldestPolicy 或者 CallerRunsPolicy。除此之外，我们还可以通过实现 RejectedExecutionHandler 接口来实现自己的拒绝策略，在接口中我们需要实现 rejectedExecution 方法，在 rejectedExecution 方法中，执行例如打印日志、暂存任务、重新执行等自定义的拒绝策略，以便满足业务需求。如代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRejectionHandler</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123; </span><br><span class="line">        <span class="comment">//打印日志、暂存任务、重新执行等拒绝策略</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结</strong></p>
<p>所以定制自己的线程池和我们的业务是强相关的，首先我们需要掌握每个参数的含义，以及常见的选项，然后根据实际需要，比如说并发量、内存大小、是否接受任务被拒绝等一系列因素去定制一个非常适合自己业务的线程池，这样既不会导致内存不足，同时又可以用合适数量的线程来保障任务执行的效率，并在拒绝任务时有所记录方便日后进行追溯。</p>
<h2 id="9-如何正确关闭线程池？shutdown-和-shutdownNow-的区别？"><a href="#9-如何正确关闭线程池？shutdown-和-shutdownNow-的区别？" class="headerlink" title="9.如何正确关闭线程池？shutdown 和 shutdownNow 的区别？"></a>9.如何正确关闭线程池？shutdown 和 shutdownNow 的区别？</h2><p>5 种在 ThreadPoolExecutor 中涉及关闭线程池的方法：</p>
<ul>
<li>void shutdown;</li>
<li>boolean isShutdown;</li>
<li>boolean isTerminated;</li>
<li>boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;</li>
<li>List<Runnable> shutdownNow;</li>
</ul>
<p><strong>shutdown()</strong></p>
<p>第一种方法叫作 shutdown()，它可以安全地关闭一个线程池，调用 shutdown() 方法之后线程池并不是立刻就被关闭，因为这时线程池中可能还有很多任务正在被执行，或是任务队列中有大量正在等待被执行的任务，调用 shutdown() 方法后线程池会在执行完正在执行的任务和队列中等待的任务后才彻底关闭。但这并不代表 shutdown() 操作是没有任何效果的，调用 shutdown() 方法后如果还有新的任务被提交，线程池则会根据拒绝策略直接拒绝后续新提交的任务。</p>
<p><strong>isShutdown()</strong></p>
<p>第二个方法叫作 isShutdown()，它可以返回 true 或者 false 来判断线程池是否已经开始了关闭工作，也就是是否执行了 shutdown 或者 shutdownNow 方法。这里需要注意，如果调用 isShutdown() 方法的返回的结果为 true 并不代表线程池此时已经彻底关闭了，这仅仅代表线程池开始了关闭的流程，也就是说，此时可能线程池中依然有线程在执行任务，队列里也可能有等待被执行的任务。</p>
<p><strong>isTerminated()</strong></p>
<p>第三种方法叫作 isTerminated()，这个方法可以检测线程池是否真正“终结”了，这不仅代表线程池已关闭，同时代表线程池中的所有任务都已经都执行完毕了。</p>
<p><strong>awaitTermination()</strong></p>
<p>第四个方法叫作 awaitTermination()，它本身并不是用来关闭线程池的，而是主要用来判断线程池状态的。比如我们给 awaitTermination 方法传入的参数是 10 秒，那么它就会陷入 10 秒钟的等待，直到发生以下三种情况之一：</p>
<ol>
<li>等待期间（包括进入等待状态之前）线程池已关闭并且所有已提交的任务（包括正在执行的和队列中等待的）都执行完毕，相当于线程池已经“终结”了，方法便会返回 true；</li>
<li>等待超时时间到后，第一种线程池“终结”的情况始终未发生，方法返回 false；</li>
<li>等待期间线程被中断，方法会抛出 InterruptedException 异常。</li>
</ol>
<p>也就是说，调用 awaitTermination 方法后当前线程会尝试等待一段指定的时间，如果在等待时间内，线程池已关闭并且内部的任务都执行完毕了，也就是说线程池真正“终结”了，那么方法就返回 true，否则超时返回 fasle。</p>
<p>我们则可以根据 awaitTermination() 返回的布尔值来判断下一步应该执行的操作。</p>
<p><strong>shutdownNow()</strong></p>
<p>最后一个方法是 shutdownNow()，也是 5 种方法里功能最强大的，它与第一种 shutdown 方法不同之处在于名字中多了一个单词 Now，也就是表示立刻关闭的意思。在执行 shutdownNow 方法之后，首先会给所有线程池中的线程发送 interrupt 中断信号，尝试中断这些任务的执行，然后会将任务队列中正在等待的所有任务转移到一个 List 中并返回，我们可以根据返回的任务 List 来进行一些补救的操作，例如记录在案并在后期重试。shutdownNow() 的源码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        interruptWorkers();</span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到源码中有一行 interruptWorkers() 代码，这行代码会让每一个已经启动的线程都中断，这样线程就可以在执行任务期间检测到中断信号并进行相应的处理，提前结束任务。<strong>这里需要注意的是，由于 Java 中不推荐强行停止线程的机制的限制，即便我们调用了 shutdownNow 方法，如果被中断的线程对于中断信号不理不睬，那么依然有可能导致任务不会停止。可见我们在开发中落地最佳实践是很重要的，我们自己编写的线程应当具有响应中断信号的能力，应当利用中断信号来协同工作。</strong></p>
<h2 id="10-线程池实现“线程复用”的原理？"><a href="#10-线程池实现“线程复用”的原理？" class="headerlink" title="10.线程池实现“线程复用”的原理？"></a>10.线程池实现“线程复用”的原理？</h2><p><strong>线程复用原理</strong></p>
<p>线程池可以把线程和任务进行解耦，线程归线程，任务归任务，摆脱了之前通过 Thread 创建线程时的一个线程必须对应一个任务的限制。在线程池中，同一个线程可以从 BlockingQueue 中不断提取新任务来执行，其<strong>核心原理在于线程池对 Thread 进行了封装，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程去执行一个“循环任务”</strong>，在这个“循环任务”中，不停地检查是否还有任务等待被执行，如果有则直接去执行这个任务，也就是调用任务的 run 方法，把 run 方法当作和普通方法一样的地位去调用，相当于把每个任务的 run() 方法串联了起来，所以线程数量并不增加。</p>
<p><strong>线程复用源码解析</strong></p>
<p>线程复用的逻辑实现主要在 Worker 类中的 run 方法里执行的 runWorker 方法中，简化后的 runWorker 方法代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            task.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            task = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，实现线程复用的逻辑主要在一个不停循环的 while 循环体中。</p>
<ol>
<li>通过取 Worker 的 firstTask 或者通过 getTask 方法从 workQueue 中获取待执行的任务。</li>
<li>直接调用 task 的 run 方法来执行具体的任务（而不是新建线程）。</li>
</ol>
<p>在这里，我们找到了最终的实现，通过取 Worker 的 firstTask 或者 getTask方法从 workQueue 中取出了新任务，并直接调用 Runnable 的 run 方法来执行任务，也就是如之前所说的，每个线程都始终在一个大循环中，反复获取任务，然后执行任务，从而实现了线程的复用。</p>
</div><div class="post-copyright"><blockquote><p>原文作者: zwq</p><p>原文链接: <a href="https://sunshine-zwq.gitee.io/2020/12/15/Java并发编程常见问题-线程池/">https://sunshine-zwq.gitee.io/2020/12/15/Java并发编程常见问题-线程池/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/java/">java</a><a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a><a href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2020/12/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="pre">Java并发编程常见问题-Java内存模型</a><a href="/2020/12/14/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" class="next">Java并发编程常见问题-线程安全</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-使用线程池比手动创建线程好在哪里？"><span class="toc-text">1.使用线程池比手动创建线程好在哪里？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-线程池的各个参数的含义"><span class="toc-text">2.线程池的各个参数的含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-线程池有哪-4-种拒绝策略？"><span class="toc-text">3.线程池有哪 4 种拒绝策略？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-有哪-6-种常见的线程池？什么是-Java7-的-ForkJoinPool？"><span class="toc-text">4.有哪 6 种常见的线程池？什么是 Java7 的 ForkJoinPool？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-线程池常用的阻塞队列有哪些？"><span class="toc-text">5.线程池常用的阻塞队列有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-为什么不应该自动创建线程池？"><span class="toc-text">6.为什么不应该自动创建线程池？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-合适的线程数量是多少？CPU-核心数和线程数的关系？"><span class="toc-text">7.合适的线程数量是多少？CPU 核心数和线程数的关系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-如何根据实际需要，定制自己的线程池？"><span class="toc-text">8.如何根据实际需要，定制自己的线程池？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-如何正确关闭线程池？shutdown-和-shutdownNow-的区别？"><span class="toc-text">9.如何正确关闭线程池？shutdown 和 shutdownNow 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-线程池实现“线程复用”的原理？"><span class="toc-text">10.线程池实现“线程复用”的原理？</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/05/26/MongoDB%E5%85%A5%E9%97%A8/">MongoDB入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/25/Java%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6-%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%B1%87%E6%80%BB/">Java安全密码学-工具类汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/24/Java%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/">Java安全密码学-数字签名</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/23/Java%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6-%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/">Java安全密码学-非对称加密</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/23/Java%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6-%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/">Java安全密码学-加密模式和填充模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/21/Java%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/">Java安全密码学-对称加密</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/13/Java%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6-%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%EF%BC%88MD5%E3%80%81SHA256%E7%AD%89%EF%BC%89/">Java安全密码学-消息摘要（MD5、SHA256等）</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/13/%E5%9C%A8web%E9%A1%B5%E9%9D%A2%E5%B5%8C%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%EF%BC%88%E5%90%AB%E5%AE%9A%E7%82%B9%E5%AE%9A%E4%BD%8D%EF%BC%89/">在web页面嵌入百度地图（含定点定位）</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/12/Java%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6-Base64/">Java安全密码学-Base64</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/11/Java%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6-Byte%E5%92%8Cbit/">Java安全密码学-Byte和bit</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Dubbo/">Dubbo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MongoDB/">MongoDB</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node-js/">Node.js</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js/">Vue.js</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ftp/">ftp</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/jvm/">jvm</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/gc/" style="font-size: 15px;">gc</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" style="font-size: 15px;">密码学</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">并发编程</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/MongoDB/" style="font-size: 15px;">MongoDB</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/gitee/" style="font-size: 15px;">gitee</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/element-ui/" style="font-size: 15px;">element-ui</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/json/" style="font-size: 15px;">json</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/js%E6%A8%A1%E5%9D%97%E5%8C%96/" style="font-size: 15px;">js模块化</a> <a href="/tags/jdk/" style="font-size: 15px;">jdk</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 15px;">工具</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 15px;">面试</a> <a href="/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/tags/%E5%9C%B0%E5%9B%BE/" style="font-size: 15px;">地图</a> <a href="/tags/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE/" style="font-size: 15px;">百度地图</a> <a href="/tags/ftp/" style="font-size: 15px;">ftp</a> <a href="/tags/Node-js/" style="font-size: 15px;">Node.js</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 15px;">正则表达式</a> <a href="/tags/ECMAScript/" style="font-size: 15px;">ECMAScript</a> <a href="/tags/java8/" style="font-size: 15px;">java8</a> <a href="/tags/Lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/Stream/" style="font-size: 15px;">Stream</a> <a href="/tags/Dubbo/" style="font-size: 15px;">Dubbo</a> <a href="/tags/ShardingSphere/" style="font-size: 15px;">ShardingSphere</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 15px;">数据库</a> <a href="/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" style="font-size: 15px;">分库分表</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">26</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://github.com/sunshine-zwq" title="我的Github" target="_blank">我的Github</a><ul></ul><a href="https://blog.csdn.net/zwq1105" title="我的CSDN博客" target="_blank">我的CSDN博客</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">zwq.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.5"></script><div id="fullscreen-img" class="hide"><span class="close"></span></div><script type="text/javascript" src="/js/imgview.js?v=2.0.5" async></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.5" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>