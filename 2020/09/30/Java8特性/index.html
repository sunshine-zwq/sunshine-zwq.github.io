<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="毕业后就一直混迹在深圳的不知名攻城狮"><meta name="baidu-site-verification" content="code-osvb6rgMcu"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.5"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.5"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><title>Java8特性 | sunshine-zwq</title><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java8特性</h1><a id="logo" href="/.">sunshine-zwq</a><p class="description">Where there is a will, there is a way.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Java8特性</h1><div class="post-meta"><a href="/2020/09/30/Java8%E7%89%B9%E6%80%A7/#comments" class="comment-count"></a><p><span class="date">2020/09/30</span><span><a href="/categories/java/" class="category">java</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p><strong>Java 8 新特性简介</strong></p>
<ul>
<li>速度更快</li>
<li>代码更少（增加了新的语法 Lambda 表达式）</li>
<li>强大的 Stream API</li>
<li>便于并行</li>
<li>最大化减少空指针异常 Optional</li>
</ul>
<h2 id="1-Lambda-表达式"><a href="#1-Lambda-表达式" class="headerlink" title="1.Lambda 表达式"></a>1.Lambda 表达式</h2><p><strong>简介：</strong></p>
<blockquote>
<p>Lambda 是一个 匿名函数。Lambda 表达式在Java 语言中引入了一个新的语法元素和操作符 “-&gt;” ，该操作符被称为 Lambda 操作符或箭头操作符。它将 Lambda 分为两个部分：</p>
<p>左侧：指定了 Lambda 表达式需要的所有参数<br>右侧：指定了 Lambda 体，即 Lambda 表达式要执行的功能。</p>
</blockquote>
<p>从匿名类到 Lambda 的转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名内部类</span></span><br><span class="line">Runnable r1 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda表达式</span></span><br><span class="line">Runnable r1 = () -&gt; System.out.println(<span class="string">"Hello World"</span>);</span><br></pre></td></tr></table></figure>



<p>Lambda 表达式语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法格式1：无参，无返回值，Lambda体只需要一条语句</span></span><br><span class="line">Runnable r1 = () -&gt; System.out.println(<span class="string">"Hello Lambda!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法格式2：Lambda只需要一个参数</span></span><br><span class="line">Consumer&lt;String&gt; fun = (args) -&gt; System.out.println(args);</span><br><span class="line"><span class="comment">// 只有一个参数时，参数的括号可省略（参数有2个或以上时，括号不能省略）</span></span><br><span class="line">Consumer&lt;String&gt; fun = args -&gt; System.out.println(args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法格式3：Lambda需要2个参数，并且有返回值</span></span><br><span class="line">BinaryOperator&lt;Long&gt; bo = (x, y) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"实现函数接口方法"</span>);</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法格式4：当Lambda体有返回值且只有一条语句时，return与大括号可以省略</span></span><br><span class="line">BinaryOperator&lt;Long&gt; bo = (x, y) -&gt; x + y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法格式5：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</span></span><br><span class="line">BinaryOperator&lt;Long&gt; bo = (Long x, Long y) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"实现函数接口方法"</span>);</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>类型推断</strong></p>
<blockquote>
<p>上述 Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac根据程序的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的。</p>
</blockquote>
<h2 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2.函数式接口"></a>2.函数式接口</h2><p><strong>简介：</strong></p>
<ul>
<li><strong>只包含一个抽象方法的接口</strong>，称为 函数式接口。</li>
<li>可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明）。</li>
<li>我们可以在任意函数式接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口，同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口</li>
</ul>
<p>自定义函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyNumber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式接口中使用泛型</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunc</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>作为参数传递Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUpperString</span><span class="params">(MyFunc&lt;String&gt; mf, String str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mf.getValue(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String newStr = toUpperString((str) -&gt; str.toUpperCase(), <span class="string">"abcdef"</span>);</span><br><span class="line">System.out.println(newStr);</span><br></pre></td></tr></table></figure>



<p><strong>Java内置四大核心函数式接口：</strong></p>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th align="center">参数类型</th>
<th align="center">返回类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>Consumer<T>：消费型接口</td>
<td align="center">T</td>
<td align="center">void</td>
<td>对类型为T的对象应用操作，<br/>包含方法：void accept(T t)</td>
</tr>
<tr>
<td>Supplier<T>：供给型接口</td>
<td align="center">无</td>
<td align="center">T</td>
<td>返回类型为T的对象，<br/>包含方法：T get();</td>
</tr>
<tr>
<td>Function&lt;T, R&gt;：函数型接口</td>
<td align="center">T</td>
<td align="center">R</td>
<td>对类型为T的对象应用操作，并返回结果。<br/>结果是R类型的对象。<br/>包含方法：R apply(T t);</td>
</tr>
<tr>
<td>Predicate<T>：断定型接口</td>
<td align="center">T</td>
<td align="center">boolean</td>
<td>确定类型为T的对象是否满足某约束，并返回boolean 值。<br/>包含方法：boolean test(T t);</td>
</tr>
</tbody></table>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Consumer&lt;T&gt; 消费型接口</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">       buy(<span class="number">1000</span>, (m) -&gt; System.out.println(<span class="string">"本次超市购物消费"</span> + m + <span class="string">"元"</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">(<span class="keyword">double</span> money, Consumer&lt;Double&gt; con)</span></span>&#123;</span><br><span class="line">       con.accept(money);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Supplier&lt;T&gt; 供给型接口</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       List&lt;Integer&gt; numList = getNumList(<span class="number">10</span>, () -&gt; (<span class="keyword">int</span>)(Math.random() * <span class="number">100</span>));</span><br><span class="line">       <span class="keyword">for</span> (Integer num : numList) &#123;</span><br><span class="line">           System.out.println(num);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 需求：产生指定个数的整数，并放入集合中</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNumList</span><span class="params">(<span class="keyword">int</span> num, Supplier&lt;Integer&gt; sup)</span></span>&#123;</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">           list.add(sup.get());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Function&lt;T, R&gt; 函数型接口</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">       String newStr = strHandler(<span class="string">"   测试Function函数式接口   "</span>, (s) -&gt; s.trim());</span><br><span class="line">       System.out.println(newStr);</span><br><span class="line"></span><br><span class="line">       String subStr = strHandler(<span class="string">"测试Function函数式接口"</span>, (s) -&gt; s.substring(<span class="number">2</span>, <span class="number">5</span>));</span><br><span class="line">       System.out.println(subStr);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">strHandler</span><span class="params">(String str, Function&lt;String, String&gt; fun)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> fun.apply(str);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Predicate&lt;T&gt; 断言型接口</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">       List&lt;String&gt; list = Arrays.asList(<span class="string">"Hello"</span>, <span class="string">"www"</span>, <span class="string">"ok"</span>, <span class="string">"Lambda"</span>, <span class="string">"test"</span>);</span><br><span class="line">       List&lt;String&gt; resultList = filterStr(list, (s) -&gt; s.contains(<span class="string">"e"</span>));</span><br><span class="line">       <span class="keyword">for</span> (String s : resultList) &#123;</span><br><span class="line">           System.out.println(s);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">filterStr</span><span class="params">(List&lt;String&gt; list, Predicate&lt;String&gt; pre)</span></span>&#123;</span><br><span class="line">       List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">           <span class="keyword">if</span>(pre.test(s))&#123;</span><br><span class="line">               strList.add(s);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> strList;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>其他接口：</p>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>BiFunction&lt;T, U, R&gt;</td>
<td>T, U</td>
<td>R</td>
<td>对类型为 T, U 参数应用操作，返回 R 类型的结果。<br/>包含方法：R apply(T t, U u);</td>
</tr>
<tr>
<td>UnaryOperator<T><br/>(Function 子接口)</td>
<td>T</td>
<td>T</td>
<td>对类型为T的对象进行一元运算，并返回T类型的结果。<br/>包含方法：T apply(T t);</td>
</tr>
<tr>
<td>BinaryOperator<T><br/>(BiFunction 子接口)</td>
<td>T, T</td>
<td>T</td>
<td>对类型为T的对象进行二元运算，并返回T类型的结果。<br/>包含方法：T apply(T t1, T t2);</td>
</tr>
<tr>
<td>BiConsumer&lt;T, U&gt;</td>
<td>T, U</td>
<td>void</td>
<td>对类型为T, U 参数应用操作。<br/>包含方法：void accept(T t, U u)</td>
</tr>
<tr>
<td>ToIntFunction<T><br/>ToLongFunction<T><br/>ToDoubleFunction<T></td>
<td>T</td>
<td>int<br/>long<br/>double</td>
<td>分别计算int 、 long 、double值的函数</td>
</tr>
<tr>
<td>IntFunction<R><br/>LongFunction<R><br/>DoubleFunction<R></td>
<td>int<br/>long<br/>double</td>
<td>R</td>
<td>参数分别为int、long、double 类型的函数</td>
</tr>
</tbody></table>
<h2 id="3-方法引用与构造器引用"><a href="#3-方法引用与构造器引用" class="headerlink" title="3.方法引用与构造器引用"></a>3.方法引用与构造器引用</h2><p><strong>简介：</strong></p>
<ul>
<li>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用</li>
<li><strong>可以理解为，方法引用是lambda表达式的另外一种表现形式。</strong></li>
<li>实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致</li>
<li>方法引用，使用操作符  ::  将方法名和对象或类的名字分隔开来。</li>
</ul>
<p><strong>(1).对象::实例方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(x) -&gt; System.out.println(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">System.out::println</span><br></pre></td></tr></table></figure>



<p><strong>(2).类::静态方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Double&gt; bo = (x, y) -&gt; Math.pow(x, y);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">BinaryOperator&lt;Double&gt; bo = Math::pow;</span><br></pre></td></tr></table></figure>



<p><strong>(3).类::实例方法</strong></p>
<p><strong>当需要引用方法的第一个参数是调用对象，并且第二个参数是需要引用方法的第二个 参数( 或无参数 ) 时：ClassName::methodName</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compare((x, y) -&gt; x.equals(y), <span class="string">"abcdef"</span>, <span class="string">"abcdef"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">compare(String::equals, <span class="string">"abcdef"</span>, <span class="string">"abcdef"</span>);</span><br></pre></td></tr></table></figure>



<p><strong>(4).构造器引用</strong></p>
<p>格式：Class::new</p>
<p>与函数式接口相结合，自动与函数式接口中方法兼容。可以把构造器引用赋值给定义的方法，与构造器参数列表要与接口中抽象方法的参数列表一致！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, MyClass&gt; fun = (n) -&gt; <span class="keyword">new</span> MyClass(n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">Function&lt;Integer, MyClass&gt; fun = MyClass::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>



<p><strong>(5).数组引用</strong></p>
<p>格式：type[]::new</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer[]&gt; fun = (n) -&gt; <span class="keyword">new</span> Integer[n];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">Function&lt;Integer, Integer[]&gt; fun = Integer[]::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>



<h2 id="4-Stream-API"><a href="#4-Stream-API" class="headerlink" title="4.Stream API"></a>4.Stream API</h2><p><strong>简介：</strong></p>
<p>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p>
<p><strong>什么是Stream？</strong></p>
<blockquote>
<p>Stream是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。<br>“集合讲的是数据，流讲的是计算！</p>
<p>注意：<br>①<strong>Stream 自己不会存储元素</strong>。<br>②<strong>Stream 不会改变源对象</strong>。相反，他们会返回一个持有结果的新Stream。<br>③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</p>
</blockquote>
<p><strong>Stream的操作三个步骤：</strong></p>
<ul>
<li>创建Stream<ul>
<li>一个数据源（如：集合、数组），获取一个流</li>
</ul>
</li>
<li>中间操作<ul>
<li>一个中间操作链，对数据源的数据进行处理</li>
</ul>
</li>
<li>终止操作（终端操作）<ul>
<li>一个终止操作，执行中间操作链，并产生结果</li>
</ul>
</li>
</ul>
<p><img src="https://zwq1105.gitee.io/blog-pic/blogPics/20200926/001.png" alt=""></p>
<h3 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h3><p>(1).通过Collection接口方法</p>
<p>Java8 中的 Collection 接口被扩展，提供了两个获取流的方法 ：</p>
<ul>
<li>default Stream<E> stream() : 返回一个顺序流</li>
<li>default Stream<E> parallelStream() : 返回一个并行流</li>
</ul>
<p>(2).由数组创建流</p>
<p>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：</p>
<ul>
<li>static <T> Stream<T> stream(T[] array): 返回一个流</li>
</ul>
<p>(3).由值创建流</p>
<p>可以使用静态方法 Stream.of(), 通过显示值创建一个流。它可以接收任意数量的参数。</p>
<ul>
<li>public static<T> Stream<T> of(T… values) : 返回一个流</li>
</ul>
<p>(4).由函数创建流：创建无限流</p>
<p>可以使用静态方法 Stream.iterate() 和Stream.generate()，创建无限流。</p>
<ul>
<li>迭代<ul>
<li>public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)</li>
</ul>
</li>
<li>生成<ul>
<li>public static<T> Stream<T> generate(Supplier<T> s)</li>
</ul>
</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.可以通过Collection系列集合提供的stream()或parallelStream()</span></span><br><span class="line">      List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      Stream&lt;String&gt; stream1 = list.stream();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2.通过Arrays中的静态方法stream()获取数据流</span></span><br><span class="line">      Employee[] emps = <span class="keyword">new</span> Employee[<span class="number">10</span>];</span><br><span class="line">      Stream&lt;Employee&gt; stream2 = Arrays.stream(emps);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3.通过Stream类中的静态方法of</span></span><br><span class="line">      Stream&lt;String&gt; stream3 = Stream.of(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4.创建无限流</span></span><br><span class="line">      <span class="comment">// 迭代</span></span><br><span class="line">      Stream&lt;Integer&gt; stream4 = Stream.iterate(<span class="number">0</span>, (x) -&gt; x + <span class="number">2</span>);</span><br><span class="line">      stream4.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"==========================================="</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 生成</span></span><br><span class="line">      Stream.generate(() -&gt; Math.random())</span><br><span class="line">              .limit(<span class="number">5</span>)</span><br><span class="line">              .forEach(System.out::println);</span><br></pre></td></tr></table></figure>



<h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。</p>
<p><strong>筛选与切片</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>filter(Predicate p)</td>
<td>接收 Lambda ， 从流中排除某些元素</td>
</tr>
<tr>
<td>distinct()</td>
<td>筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</td>
</tr>
<tr>
<td>limit(long maxSize)</td>
<td>截断流，使其元素不超过给定数量</td>
</tr>
<tr>
<td>skip(long n)</td>
<td>跳过元素，返回一个扔掉了前 n 个元素的流。<br/>若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</td>
</tr>
</tbody></table>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; emps = Arrays.asList(</span><br><span class="line">           <span class="keyword">new</span> Employee(<span class="number">101</span>, <span class="string">"张三"</span>, <span class="number">18</span>, <span class="number">9999.99</span>),</span><br><span class="line">           <span class="keyword">new</span> Employee(<span class="number">102</span>, <span class="string">"李四"</span>, <span class="number">59</span>, <span class="number">6666.66</span>),</span><br><span class="line">           <span class="keyword">new</span> Employee(<span class="number">103</span>, <span class="string">"王五"</span>, <span class="number">28</span>, <span class="number">3333.33</span>),</span><br><span class="line">           <span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">"赵六"</span>, <span class="number">8</span>, <span class="number">7777.77</span>),</span><br><span class="line">           <span class="keyword">new</span> Employee(<span class="number">105</span>, <span class="string">"田七"</span>, <span class="number">38</span>, <span class="number">5555.55</span>),</span><br><span class="line">           <span class="keyword">new</span> Employee(<span class="number">105</span>, <span class="string">"田七"</span>, <span class="number">38</span>, <span class="number">5555.55</span>),</span><br><span class="line">           <span class="keyword">new</span> Employee(<span class="number">105</span>, <span class="string">"田七"</span>, <span class="number">38</span>, <span class="number">5555.55</span>)</span><br><span class="line">   );</span><br><span class="line"></span><br><span class="line">   <span class="comment">// filter</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Stream&lt;Employee&gt; stream = emps.stream()</span><br><span class="line">               .filter((e) -&gt; e.getAge() &gt; <span class="number">35</span>);</span><br><span class="line"></span><br><span class="line">       stream.forEach(System.out::println);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// limit</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       emps.stream()</span><br><span class="line">               .filter((e) -&gt; e.getSalary() &gt; <span class="number">5000</span>)</span><br><span class="line">               .limit(<span class="number">2</span>)</span><br><span class="line">               .forEach(System.out::println);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// skip</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">       emps.stream()</span><br><span class="line">               .filter((e) -&gt; e.getSalary() &gt; <span class="number">5000</span>)</span><br><span class="line">               .skip(<span class="number">2</span>)</span><br><span class="line">               .forEach(System.out::println);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// distinct</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">       emps.stream()</span><br><span class="line">               .filter((e) -&gt; e.getSalary() &gt; <span class="number">5000</span>)</span><br><span class="line">               .skip(<span class="number">2</span>)</span><br><span class="line">               .distinct()</span><br><span class="line">               .forEach(System.out::println);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>映射</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>map(Function f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</td>
</tr>
<tr>
<td>mapToDouble(ToDoubleFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。</td>
</tr>
<tr>
<td>mapToInt(ToIntFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream。</td>
</tr>
<tr>
<td>mapToLong(ToLongFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。</td>
</tr>
<tr>
<td>flatMap(Function f)</td>
<td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td>
</tr>
</tbody></table>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// map</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"aaa"</span>, <span class="string">"bbb"</span>, <span class="string">"ccc"</span>, <span class="string">"ddd"</span>);</span><br><span class="line">        list.stream()</span><br><span class="line">                .map((str) -&gt; str.toUpperCase())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"==========================================="</span>);</span><br><span class="line"></span><br><span class="line">        emps.stream()</span><br><span class="line">                .map((e) -&gt; e.getName())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"==========================================="</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Stream&lt;Stream&lt;Character&gt;&gt; stream = list.stream()</span></span><br><span class="line"><span class="comment">//                .map((s) -&gt; filterCharacter(s));</span></span><br><span class="line"><span class="comment">//        stream.forEach((sm) -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            sm.forEach(System.out::println);</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line">        list.stream()</span><br><span class="line">                .flatMap((s) -&gt; filterCharacter(s))</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title">filterCharacter</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        List&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : str.toCharArray()) &#123;</span><br><span class="line">            list.add(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.stream();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>排序</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>sorted()</td>
<td>产生一个新流，其中按自然顺序排序</td>
</tr>
<tr>
<td>sorted(Comparator comp)</td>
<td>产生一个新流，其中按比较器顺序排序</td>
</tr>
</tbody></table>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">       List&lt;String&gt; list = Arrays.asList(<span class="string">"ccc"</span>, <span class="string">"aaa"</span>, <span class="string">"ddd"</span>, <span class="string">"eee"</span>, <span class="string">"bbb"</span>);</span><br><span class="line">       list.stream()</span><br><span class="line">               .sorted()</span><br><span class="line">               .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">"==========================================="</span>);</span><br><span class="line"></span><br><span class="line">       emps.stream()</span><br><span class="line">               .sorted((e1, e2) -&gt; &#123;</span><br><span class="line">                   <span class="keyword">if</span>(e1.getAge() == e2.getAge())&#123;</span><br><span class="line">                       <span class="keyword">return</span> e1.getName().compareTo(e2.getName());</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       <span class="keyword">return</span> e1.getAge() - e2.getAge();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;).forEach(System.out::println);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h3><p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void。</p>
<p><strong>查找与匹配</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>allMatch(Predicate p)</td>
<td>检查是否匹配所有元素</td>
</tr>
<tr>
<td>anyMatch(Predicate p)</td>
<td>检查是否至少匹配一个元素</td>
</tr>
<tr>
<td>noneMatch(Predicate p)</td>
<td>检查是否没有匹配所有元素</td>
</tr>
<tr>
<td>findFirst()</td>
<td>返回第一个元素</td>
</tr>
<tr>
<td>findAny()</td>
<td>返回当前流中的任意元素</td>
</tr>
<tr>
<td>count()</td>
<td>返回流中元素总数</td>
</tr>
<tr>
<td>max(Comparator c)</td>
<td>返回流中最大值</td>
</tr>
<tr>
<td>min(Comparator c)</td>
<td>返回流中最小值</td>
</tr>
<tr>
<td>forEach(Consumer c)</td>
<td>内部迭代(使用 Collection 接口需要用户去做迭代，称为外部迭代 。<br/>相反， Stream API 使用内部迭代 —— 它帮你把迭代做了)</td>
</tr>
</tbody></table>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; emps = Arrays.asList(</span><br><span class="line">           <span class="keyword">new</span> Employee(<span class="number">101</span>, <span class="string">"张三"</span>, <span class="number">18</span>, <span class="number">9999.99</span>),</span><br><span class="line">           <span class="keyword">new</span> Employee(<span class="number">102</span>, <span class="string">"李四"</span>, <span class="number">59</span>, <span class="number">6666.66</span>),</span><br><span class="line">           <span class="keyword">new</span> Employee(<span class="number">103</span>, <span class="string">"王五"</span>, <span class="number">28</span>, <span class="number">3333.33</span>),</span><br><span class="line">           <span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">"赵六"</span>, <span class="number">8</span>, <span class="number">7777.77</span>),</span><br><span class="line">           <span class="keyword">new</span> Employee(<span class="number">105</span>, <span class="string">"田七"</span>, <span class="number">38</span>, <span class="number">5555.55</span>)</span><br><span class="line">   );</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> b1 = emps.stream()</span><br><span class="line">               .allMatch((e) -&gt; e.getSalary() &gt; <span class="number">5000</span>);</span><br><span class="line">       System.out.println(b1);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">boolean</span> b2 = emps.stream()</span><br><span class="line">               .anyMatch((e) -&gt; e.getSalary() &gt; <span class="number">5000</span>);</span><br><span class="line">       System.out.println(b2);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">boolean</span> b3 = emps.stream()</span><br><span class="line">               .noneMatch((e) -&gt; e.getSalary() &gt; <span class="number">5000</span>);</span><br><span class="line">       System.out.println(b3);</span><br><span class="line"></span><br><span class="line">       Optional&lt;Employee&gt; op = emps.stream()</span><br><span class="line">               .sorted((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()))</span><br><span class="line">               .findFirst();</span><br><span class="line">       System.out.println(op.get());</span><br><span class="line"></span><br><span class="line">       Optional&lt;Employee&gt; op2 = emps.parallelStream()</span><br><span class="line">               .filter((e) -&gt; e.getSalary() &gt; <span class="number">5000</span>)</span><br><span class="line">               .findAny();</span><br><span class="line">       System.out.println(op2.get());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">long</span> count = emps.stream().count();</span><br><span class="line">       System.out.println(count);</span><br><span class="line"></span><br><span class="line">       Optional&lt;Employee&gt; op1 = emps.stream()</span><br><span class="line">               .max((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));</span><br><span class="line">       System.out.println(op1.get());</span><br><span class="line"></span><br><span class="line">       Optional&lt;Double&gt; op2 = emps.stream()</span><br><span class="line">               .map(Employee::getSalary)</span><br><span class="line">               .min(Double::compare);</span><br><span class="line">       System.out.println(op2.get());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>规约</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>reduce(T iden, BinaryOperator b)</td>
<td>可以将流中元素反复结合起来，得到一个值。返回 T</td>
</tr>
<tr>
<td>reduce(BinaryOperator b)</td>
<td>可以将流中元素反复结合起来，得到一个值。返回 Optional<T></td>
</tr>
</tbody></table>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">       List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">       Integer sum = list.stream()</span><br><span class="line">               .reduce(<span class="number">0</span>, (x, y) -&gt; x + y);</span><br><span class="line">       System.out.println(sum);</span><br><span class="line"></span><br><span class="line">       Optional&lt;Double&gt; op = emps.stream()</span><br><span class="line">               .map(Employee::getSalary)</span><br><span class="line">               .reduce(Double::sum);</span><br><span class="line">       System.out.println(op.get());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>收集</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>collect(Collector c)</td>
<td>将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法</td>
</tr>
</tbody></table>
<p>Collector 接口中方法的实现决定了如何对流执行收集操作(如收集到 List、Set、Map)。但是 Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回类型</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>toList</td>
<td>List<T></td>
<td>把流中元素收集到List</td>
<td>List<Employee> emps = list.stream().collect(Collectors.toList());</td>
</tr>
<tr>
<td>toSet</td>
<td>Set<T></td>
<td>把流中元素收集到Set</td>
<td>Set<Employee> emps= list.stream().collect(Collectors.toSet());</td>
</tr>
<tr>
<td>toCollection</td>
<td>Collection<T></td>
<td>把流中元素收集到创建的集合</td>
<td>Collection<Employee>emps=list.stream().collect(Collectors.toCollection(ArrayList::new));</td>
</tr>
<tr>
<td>counting</td>
<td>Long</td>
<td>计算流中元素的个数</td>
<td>long count = list.stream().collect(Collectors.counting());</td>
</tr>
<tr>
<td>summingInt</td>
<td>Integer</td>
<td>对流中元素的整数属性求和</td>
<td>inttotal=list.stream().collect(Collectors.summingInt(Employee::getSalary));</td>
</tr>
<tr>
<td>averagingInt</td>
<td>Double</td>
<td>计算流中元素Integer属性的平均值</td>
<td>doubleavg= list.stream().collect(Collectors.averagingInt(Employee::getSalary));</td>
</tr>
<tr>
<td>summarizingInt</td>
<td>IntSummaryStatistics</td>
<td>收集流中Integer属性的统计值。如：平均值</td>
<td>IntSummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary));</td>
</tr>
<tr>
<td>joining</td>
<td>String</td>
<td>连接流中每个字符串</td>
<td>String str= list.stream().map(Employee::getName).collect(Collectors.joining());</td>
</tr>
<tr>
<td>maxBy</td>
<td>Optional<T></td>
<td>根据比较器选择最大值</td>
<td>Optional<Emp>max= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));</td>
</tr>
<tr>
<td>minBy</td>
<td>Optional<T></td>
<td>根据比较器选择最小值</td>
<td>Optional<Emp> min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));</td>
</tr>
<tr>
<td>reducing</td>
<td>归约产生的类型</td>
<td>从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值</td>
<td>inttotal=list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum));</td>
</tr>
<tr>
<td>collectingAndThen</td>
<td>转换函数返回的类型</td>
<td>包裹另一个收集器，对其结果转换函数</td>
<td>inthow= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));</td>
</tr>
<tr>
<td>groupingBy</td>
<td>Map&lt;K, List<T>&gt;</td>
<td>根据某属性值对流分组，属性为K，结果为V</td>
<td>Map&lt;Emp.Status, List<Emp>&gt; map= list.stream().collect(Collectors.groupingBy(Employee::getStatus));</td>
</tr>
<tr>
<td>partitioningBy</td>
<td>Map&lt;Boolean, List<T>&gt;</td>
<td>根据true或false进行分区</td>
<td>Map&lt;Boolean,List<Emp>&gt;vd= list.stream().collect(Collectors.partitioningBy(Employee::getManage));</td>
</tr>
</tbody></table>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">       List&lt;String&gt; list = emps.stream()</span><br><span class="line">               .map(Employee::getName)</span><br><span class="line">               .collect(Collectors.toList());</span><br><span class="line">       list.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">       Set&lt;String&gt; set = emps.stream()</span><br><span class="line">               .map(Employee::getName)</span><br><span class="line">               .collect(Collectors.toSet());</span><br><span class="line">       set.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">       HashSet&lt;String&gt; hs = emps.stream()</span><br><span class="line">               .map(Employee::getName)</span><br><span class="line">               .collect(Collectors.toCollection(HashSet::<span class="keyword">new</span>));</span><br><span class="line">       hs.forEach(System.out::println);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">// 总数</span></span><br><span class="line">       Long count = emps.stream()</span><br><span class="line">               .collect(Collectors.counting());</span><br><span class="line">       System.out.println(count);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 平均值</span></span><br><span class="line">       Double avg = emps.stream()</span><br><span class="line">               .collect(Collectors.averagingDouble(Employee::getSalary));</span><br><span class="line">       System.out.println(avg);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 总和</span></span><br><span class="line">       Double sum = emps.stream()</span><br><span class="line">               .collect(Collectors.summingDouble(Employee::getSalary));</span><br><span class="line">       System.out.println(sum);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 最大值</span></span><br><span class="line">       Optional&lt;Employee&gt; max = emps.stream()</span><br><span class="line">               .collect(Collectors.maxBy((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())));</span><br><span class="line">       System.out.println(max.get());</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 最小值</span></span><br><span class="line">       Optional&lt;Double&gt; min = emps.stream()</span><br><span class="line">               .map(Employee::getSalary)</span><br><span class="line">               .collect(Collectors.minBy(Double::compare));</span><br><span class="line">       System.out.println(min.get());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">// 分组</span></span><br><span class="line">       Map&lt;String, List&lt;Employee&gt;&gt; map = emps.stream()</span><br><span class="line">               .collect(Collectors.groupingBy((e) -&gt; &#123;</span><br><span class="line">                   <span class="keyword">if</span> (((Employee) e).getSalary() &gt; <span class="number">7000</span>) &#123;</span><br><span class="line">                       <span class="keyword">return</span> <span class="string">"高薪"</span>;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="keyword">return</span> <span class="string">"低薪"</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;));</span><br><span class="line">       System.out.println(map);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">// 分区</span></span><br><span class="line">       Map&lt;Boolean, List&lt;Employee&gt;&gt; map = emps.stream()</span><br><span class="line">               .collect(Collectors.partitioningBy((e) -&gt; e.getSalary() &gt; <span class="number">7000</span>));</span><br><span class="line">       System.out.println(map);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">       DoubleSummaryStatistics dss = emps.stream()</span><br><span class="line">               .collect(Collectors.summarizingDouble(Employee::getSalary));</span><br><span class="line">       System.out.println(dss.getSum());</span><br><span class="line">       System.out.println(dss.getAverage());</span><br><span class="line">       System.out.println(dss.getMax());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span></span>&#123;</span><br><span class="line">       String str = emps.stream()</span><br><span class="line">               .map(Employee::getName)</span><br><span class="line">               .collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">       System.out.println(str);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>并行流与串行流</strong></p>
<blockquote>
<p>并行流 就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。</p>
<p>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与sequential() 在并行流与顺序流之间进行切换。</p>
</blockquote>
<h2 id="5-Optional类"><a href="#5-Optional类" class="headerlink" title="5.Optional类"></a>5.Optional类</h2><p><strong>简介：</strong></p>
<p>Optional<T> 类(java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</p>
<p><strong>常用方法：</strong></p>
<ul>
<li>Optional.of(T t)：创建一个 Optional 实例</li>
<li>Optional.empty()：创建一个空的 Optional 实例</li>
<li>Optional.ofNullable(T t)：若 t 不为 null,创建 Optional 实例,否则创建空实例</li>
<li>isPresent()：判断是否包含值</li>
<li>orElse(T t)：如果调用对象包含值，返回该值，否则返回t</li>
<li>orElseGet(Supplier s) ：如果调用对象包含值，返回该值，否则返回 s 获取的值</li>
<li>map(Function f)：如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty()</li>
<li>flatMap(Function mapper)：与 map 类似，要求返回值必须是Optional</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Optional&lt;Employee&gt; op = Optional.of(<span class="keyword">new</span> Employee());</span><br><span class="line">       Employee emp = op.get();</span><br><span class="line">       System.out.println(emp);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Optional&lt;Employee&gt; op = Optional.empty();</span><br><span class="line">       System.out.println(op);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Optional&lt;Employee&gt; op = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">if</span>(op.isPresent())&#123;</span><br><span class="line">           System.out.println(op.get());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Employee emp1 = op.orElse(<span class="keyword">new</span> Employee(<span class="string">"张三"</span>, <span class="number">28</span>));</span><br><span class="line">       System.out.println(emp1);</span><br><span class="line"></span><br><span class="line">       Employee emp2 = op.orElseGet(Employee::<span class="keyword">new</span>);</span><br><span class="line">       System.out.println(emp2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Optional&lt;Employee&gt; op = Optional.ofNullable(<span class="keyword">new</span> Employee(<span class="string">"张三"</span>, <span class="number">28</span>));</span><br><span class="line"></span><br><span class="line">       Optional&lt;String&gt; str = op.map((e) -&gt; e.getName());</span><br><span class="line">       System.out.println(str.get());</span><br><span class="line"></span><br><span class="line">       Optional&lt;String&gt; str2 = op.flatMap((e) -&gt; Optional.of(e.getName()));</span><br><span class="line">       System.out.println(str2.get());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>尽量避免使用的地方：</strong></p>
<p>1、避免使用Optional.isPresent()来检查实例是否存在，因为这种方式和null != obj没有区别，这样用就没什么意义了。</p>
<p>2、避免使用Optional.get()方式来获取实例对象，因为使用前需要使用Optional.isPresent()来检查实例是否存在，否则会出现NPE问题。</p>
<p>3、避免使用Optional作为类或者实例的属性，而应该在返回值中用来包装返回实例对象。</p>
<p>4、避免使用Optional作为方法的参数，原因同3。</p>
<p><strong>使用Optional优化的经典案例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java8之前的多重if判断</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getIsoCode</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Address address = user.getAddress();</span><br><span class="line">    <span class="keyword">if</span> (address != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Country country = address.getCountry();</span><br><span class="line">      <span class="keyword">if</span> (country != <span class="keyword">null</span>) &#123;</span><br><span class="line">          String isocode = country.getIsocode();</span><br><span class="line">          <span class="keyword">if</span> (isocode != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> isocode;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用java8的Optional优化后</span></span><br><span class="line">String isoCode = Optional.ofNullable(user)</span><br><span class="line">    .map(User::getAddress)  <span class="comment">//Optional&lt;Address&gt;</span></span><br><span class="line">    .map(Address::getCountry)  <span class="comment">//Optional&lt;Country&gt;</span></span><br><span class="line">    .map(Country::getIsocode)  <span class="comment">// Optional&lt;String&gt;</span></span><br><span class="line">    .orElse(<span class="string">""</span>);</span><br></pre></td></tr></table></figure>



<h2 id="6-接口中的默认方法与静态方法"><a href="#6-接口中的默认方法与静态方法" class="headerlink" title="6.接口中的默认方法与静态方法"></a>6.接口中的默认方法与静态方法</h2><p><strong>接口中的默认方法</strong></p>
<p>Java 8中允许接口中包含具有具体实现的方法，该方法称为“默认方法”，默认方法使用 <strong>default</strong> 关键字修饰。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello Java8"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>接口默认方法的 ” 类优先 ”原则</strong></p>
<p>若一个接口中定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时：</p>
<ul>
<li>选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。</li>
<li>接口冲突。如果一个父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否是默认方法），那么必须覆盖该方法来解决冲突</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyFunc</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello Java8"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Named</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">MyFunc</span>, <span class="title">Named</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Named.<span class="keyword">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>接口中的静态方法</strong></p>
<p>Java8 中，接口中允许添加静态方法。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Named</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">myFun</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hi"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-新时间日期-API"><a href="#7-新时间日期-API" class="headerlink" title="7.新时间日期 API"></a>7.新时间日期 API</h2><p>在旧版的 Java 中，日期时间 API 存在诸多问题，其中有：</p>
<ul>
<li><strong>非线程安全</strong> − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。</li>
<li><strong>设计很差</strong> − Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。</li>
<li><strong>时区处理麻烦</strong> − 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。</li>
</ul>
<p><strong>使用 LocalDate 、LocalTime 、LocalDateTime</strong></p>
<p> LocalDate、LocalTime、LocalDateTime 类的实例是不可变的对象，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息。也不包含与时区相关的信息。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>now()</td>
<td>静态方法，根据当前时间创建对象</td>
<td>LocalDate localDate = LocalDate.now();<br/>LocalTime localTime = LocalTime.now();<br/>LocalDateTime localDateTime = LocalDateTime.now();</td>
</tr>
<tr>
<td>of()</td>
<td>静态方法，根据指定日期/时间创建对象</td>
<td>LocalDate localDate = LocalDate.of(2016, 10, 26);<br/>LocalTime localTime = LocalTime.of(02, 22, 56);<br/>LocalDateTime localDateTime = LocalDateTime.of(2016, 10,26, 12, 10, 55);</td>
</tr>
<tr>
<td>plusDays, plusWeeks,<br/>plusMonths, plusYears</td>
<td>向当前 LocalDate 对象添加几天、几周、几个月、几年</td>
<td></td>
</tr>
<tr>
<td>minusDays, minusWeeks,<br/>minusMonths, minusYears</td>
<td>从当前 LocalDate 对象减去几天、几周、几个月、几年</td>
<td></td>
</tr>
<tr>
<td>plus, minus</td>
<td>添加或减少一个 Duration 或 Period</td>
<td></td>
</tr>
<tr>
<td>withDayOfMonth,<br/>withDayOfYear,<br/>withMonth,<br/>withYear</td>
<td>将月份天数、年份天数、月份、年份修改为指定的值并返回新的LocalDate 对象</td>
<td></td>
</tr>
<tr>
<td>getDayOfMonth</td>
<td>获得月份天数(1-31)</td>
<td></td>
</tr>
<tr>
<td>getDayOfYear</td>
<td>获得年份天数(1-366)</td>
<td></td>
</tr>
<tr>
<td>getDayOfWeek</td>
<td>获得星期几(返回一个 DayOfWeek枚举值)</td>
<td></td>
</tr>
<tr>
<td>getMonth</td>
<td>获得月份, 返回一个 Month 枚举值</td>
<td></td>
</tr>
<tr>
<td>getMonthValue</td>
<td>获得月份(1-12)</td>
<td></td>
</tr>
<tr>
<td>getYear</td>
<td>获得年份</td>
<td></td>
</tr>
<tr>
<td>until</td>
<td>获得两个日期之间的 Period 对象，<br/>或者指定 ChronoUnits 的数字</td>
<td></td>
</tr>
<tr>
<td>isBefore, isAfter</td>
<td>比较两个 LocalDate</td>
<td></td>
</tr>
<tr>
<td>isLeapYear</td>
<td>判断是否是闰年</td>
<td></td>
</tr>
</tbody></table>
<p><strong>Instant 时间戳</strong></p>
<p>用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算</p>
<p><strong>Duration 和 Period</strong></p>
<ul>
<li>Duration: 用于计算两个“时间”间隔</li>
<li>Period: 用于计算两个“日期”间隔</li>
</ul>
<p><strong>日期的操纵</strong></p>
<ul>
<li>emporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下个周日”等操作。</li>
<li>TemporalAdjusters : 该类通过静态方法提供了大量的常用 TemporalAdjuster 的实现。</li>
</ul>
<p><strong>解析与格式化</strong></p>
<p>java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：</p>
<ul>
<li>预定义的标准格式</li>
<li>语言环境相关的格式</li>
<li>自定义的格式</li>
</ul>
<p><strong>时区的处理</strong></p>
<p>Java8 中加入了对时区的支持，带时区的时间为分别为：<br>ZonedDate、ZonedTime、ZonedDateTime</p>
<p>其中每个时区都对应着 ID，地区ID都为 “{区域}/{城市}”的格式，例如 ：Asia/Shanghai 等</p>
<p>ZoneId：该类中包含了所有的时区信息</p>
<ul>
<li>getAvailableZoneIds() : 可以获取所有时区时区信息</li>
<li>of(id) : 用指定的时区信息获取 ZoneId 对象</li>
</ul>
<p><strong>与传统日期处理的转换</strong></p>
<table>
<thead>
<tr>
<th>类</th>
<th>To遗留类</th>
<th>From遗留类</th>
</tr>
</thead>
<tbody><tr>
<td>java.time.Instant<br/>java.util.Date</td>
<td>Date.from(instant)</td>
<td>date.toInstant()</td>
</tr>
<tr>
<td>java.time.Instant<br/>java.sql.Timestamp</td>
<td>Timestamp.from(instant)</td>
<td>timestamp.toInstant()</td>
</tr>
<tr>
<td>java.time.ZonedDateTime<br/>java.util.GregorianCalendar</td>
<td>GregorianCalendar.from(zonedDateTime)</td>
<td>cal.toZonedDateTime()</td>
</tr>
<tr>
<td>java.time.LocalDate<br/>java.sql.Time</td>
<td>Date.valueOf(localDate)</td>
<td>date.toLocalDate()</td>
</tr>
<tr>
<td>java.time.LocalTime<br/>java.sql.Time</td>
<td>Date.valueOf(localDate)</td>
<td>date.toLocalTime()</td>
</tr>
<tr>
<td>java.time.LocalDateTime<br/>java.sql.Timestamp</td>
<td>Timestamp.valueOf(localDateTime)</td>
<td>timestamp.toLocalDateTime()</td>
</tr>
<tr>
<td>java.time.ZoneId<br/>java.util.TimeZone</td>
<td>Timezone.getTimeZone(id)</td>
<td>timeZone.toZoneId()</td>
</tr>
<tr>
<td>java.time.format.DateTimeFormatter<br/>java.text.DateFormat</td>
<td>formatter.toFormat()</td>
<td>无</td>
</tr>
</tbody></table>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">       LocalDateTime ldt = LocalDateTime.now();</span><br><span class="line">       System.out.println(ldt);</span><br><span class="line">       System.out.println(ldt.getYear());</span><br><span class="line">       System.out.println(ldt.getMonthValue());</span><br><span class="line">       System.out.println(ldt.getDayOfMonth());</span><br><span class="line">       System.out.println(ldt.getHour());</span><br><span class="line">       System.out.println(ldt.getMinute());</span><br><span class="line">       System.out.println(ldt.getSecond());</span><br><span class="line"></span><br><span class="line">       LocalDateTime ldt2 = ldt.plusYears(<span class="number">2</span>);</span><br><span class="line">       System.out.println(ldt2);</span><br><span class="line"></span><br><span class="line">       LocalDateTime ldt3 = ldt.plusMonths(<span class="number">2</span>);</span><br><span class="line">       System.out.println(ldt3);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Instant ins = Instant.now();</span><br><span class="line">       System.out.println(ins);<span class="comment">// 默认获取UTC时区</span></span><br><span class="line"></span><br><span class="line">       OffsetDateTime odt = ins.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">       System.out.println(odt);</span><br><span class="line">       System.out.println(odt.toEpochSecond());</span><br><span class="line"></span><br><span class="line">       Instant ins2 = Instant.ofEpochSecond(<span class="number">1000</span>);</span><br><span class="line">       System.out.println(ins2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Instant ins1 = Instant.now();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Instant ins2 = Instant.now();</span><br><span class="line"></span><br><span class="line">       Duration duration = Duration.between(ins1, ins2);</span><br><span class="line">       System.out.println(duration.toMillis());</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">"======================================"</span>);</span><br><span class="line"></span><br><span class="line">       LocalTime lt1 = LocalTime.now();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       LocalTime lt2 = LocalTime.now();</span><br><span class="line"></span><br><span class="line">       System.out.println(Duration.between(lt1, lt2).toMillis());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">       LocalDate ld1 = LocalDate.of(<span class="number">2015</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">       LocalDate ld2 = LocalDate.now();</span><br><span class="line"></span><br><span class="line">       Period period = Period.between(ld1, ld2);</span><br><span class="line">       System.out.println(period);</span><br><span class="line">       System.out.println(period.getYears());</span><br><span class="line">       System.out.println(period.getMonths());</span><br><span class="line">       System.out.println(period.getDays());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//  TemporalAdjuster: 时间校正器</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">       LocalDateTime ldt = LocalDateTime.now();</span><br><span class="line">       System.out.println(ldt);</span><br><span class="line"></span><br><span class="line">       LocalDateTime ldt2 = ldt.withDayOfMonth(<span class="number">10</span>);</span><br><span class="line">       System.out.println(ldt2);</span><br><span class="line"></span><br><span class="line">       LocalDateTime ldt3 = ldt.with(TemporalAdjusters.next(DayOfWeek.SUNDAY));</span><br><span class="line">       System.out.println(ldt3);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 自定义：下一个工作日</span></span><br><span class="line">       LocalDateTime ldt5 = ldt.with((l) -&gt; &#123;</span><br><span class="line">           LocalDateTime ldt4 = (LocalDateTime) l;</span><br><span class="line">           DayOfWeek dow = ldt4.getDayOfWeek();</span><br><span class="line">           <span class="keyword">if</span> (dow.equals(DayOfWeek.FRIDAY)) &#123;</span><br><span class="line">               <span class="keyword">return</span> ldt4.plusDays(<span class="number">3</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dow.equals(DayOfWeek.SATURDAY)) &#123;</span><br><span class="line">               <span class="keyword">return</span> ldt4.plusDays(<span class="number">2</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> ldt4.plusDays(<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       System.out.println(ldt5);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// DateTimeFormatter</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">       DateTimeFormatter dtf = DateTimeFormatter.ISO_DATE;</span><br><span class="line">       LocalDateTime ldt = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">       String strDate = ldt.format(dtf);</span><br><span class="line">       System.out.println(strDate);</span><br><span class="line"></span><br><span class="line">       DateTimeFormatter dtf2 = DateTimeFormatter.ofPattern(<span class="string">"yyyy年MM月dd日 HH:mm:ss"</span>);</span><br><span class="line">       String strDate2 = ldt.format(dtf2);</span><br><span class="line">       System.out.println(strDate2);</span><br><span class="line"></span><br><span class="line">       LocalDateTime newDate = ldt.parse(strDate2, dtf2);</span><br><span class="line">       System.out.println(newDate);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ZonedDate、ZonedTime、ZonedDateTime</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">       LocalDateTime ldt = LocalDateTime.now(ZoneId.of(<span class="string">"Asia/Shanghai"</span>));</span><br><span class="line">       System.out.println(ldt);</span><br><span class="line"></span><br><span class="line">       ZonedDateTime zdt = ldt.atZone(ZoneId.of(<span class="string">"Asia/Shanghai"</span>));</span><br><span class="line">       System.out.println(zdt);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="8-其他新特性"><a href="#8-其他新特性" class="headerlink" title="8.其他新特性"></a>8.其他新特性</h2><p><strong>重复注解与类型注解</strong></p>
<p>Java 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。</p>
<p><img src="https://zwq1105.gitee.io/blog-pic/blogPics/20200926/002.png" alt=""></p>
</div><div class="post-copyright"><blockquote><p>原文作者: zwq</p><p>原文链接: <a href="https://sunshine-zwq.gitee.io/2020/09/30/Java8特性/">https://sunshine-zwq.gitee.io/2020/09/30/Java8特性/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/java/">java</a><a href="/tags/java8/">java8</a><a href="/tags/Lambda/">Lambda</a><a href="/tags/Stream/">Stream</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2020/11/16/%E5%88%A9%E7%94%A8LinkedHashMap%E5%AE%9E%E7%8E%B0LRU%E7%AE%97%E6%B3%95/" class="pre">利用LinkedHashMap实现LRU算法</a><a href="/2020/09/13/JS%E6%A8%A1%E5%9D%97%E5%8C%96/" class="next">JS模块化</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Lambda-表达式"><span class="toc-text">1.Lambda 表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-函数式接口"><span class="toc-text">2.函数式接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-方法引用与构造器引用"><span class="toc-text">3.方法引用与构造器引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Stream-API"><span class="toc-text">4.Stream API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建Stream"><span class="toc-text">创建Stream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中间操作"><span class="toc-text">中间操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#终止操作"><span class="toc-text">终止操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Optional类"><span class="toc-text">5.Optional类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-接口中的默认方法与静态方法"><span class="toc-text">6.接口中的默认方法与静态方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-新时间日期-API"><span class="toc-text">7.新时间日期 API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-其他新特性"><span class="toc-text">8.其他新特性</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/05/26/MongoDB%E5%85%A5%E9%97%A8/">MongoDB入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/25/Java%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6-%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%B1%87%E6%80%BB/">Java安全密码学-工具类汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/24/Java%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/">Java安全密码学-数字签名</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/23/Java%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6-%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/">Java安全密码学-非对称加密</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/23/Java%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6-%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F/">Java安全密码学-加密模式和填充模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/21/Java%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/">Java安全密码学-对称加密</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/13/Java%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6-%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%EF%BC%88MD5%E3%80%81SHA256%E7%AD%89%EF%BC%89/">Java安全密码学-消息摘要（MD5、SHA256等）</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/13/%E5%9C%A8web%E9%A1%B5%E9%9D%A2%E5%B5%8C%E5%85%A5%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%EF%BC%88%E5%90%AB%E5%AE%9A%E7%82%B9%E5%AE%9A%E4%BD%8D%EF%BC%89/">在web页面嵌入百度地图（含定点定位）</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/12/Java%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6-Base64/">Java安全密码学-Base64</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/05/11/Java%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81%E5%AD%A6-Byte%E5%92%8Cbit/">Java安全密码学-Byte和bit</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Dubbo/">Dubbo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MongoDB/">MongoDB</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node-js/">Node.js</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js/">Vue.js</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ftp/">ftp</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/jvm/">jvm</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE/" style="font-size: 15px;">百度地图</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" style="font-size: 15px;">密码学</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">并发编程</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/MongoDB/" style="font-size: 15px;">MongoDB</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/gitee/" style="font-size: 15px;">gitee</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/element-ui/" style="font-size: 15px;">element-ui</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/json/" style="font-size: 15px;">json</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 15px;">面试</a> <a href="/tags/%E5%9C%B0%E5%9B%BE/" style="font-size: 15px;">地图</a> <a href="/tags/jdk/" style="font-size: 15px;">jdk</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/js%E6%A8%A1%E5%9D%97%E5%8C%96/" style="font-size: 15px;">js模块化</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 15px;">工具</a> <a href="/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 15px;">正则表达式</a> <a href="/tags/ftp/" style="font-size: 15px;">ftp</a> <a href="/tags/Node-js/" style="font-size: 15px;">Node.js</a> <a href="/tags/ECMAScript/" style="font-size: 15px;">ECMAScript</a> <a href="/tags/Dubbo/" style="font-size: 15px;">Dubbo</a> <a href="/tags/java8/" style="font-size: 15px;">java8</a> <a href="/tags/Lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/Stream/" style="font-size: 15px;">Stream</a> <a href="/tags/ShardingSphere/" style="font-size: 15px;">ShardingSphere</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 15px;">数据库</a> <a href="/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" style="font-size: 15px;">分库分表</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">26</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://github.com/sunshine-zwq" title="我的Github" target="_blank">我的Github</a><ul></ul><a href="https://blog.csdn.net/zwq1105" title="我的CSDN博客" target="_blank">我的CSDN博客</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">zwq.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.5"></script><div id="fullscreen-img" class="hide"><span class="close"></span></div><script type="text/javascript" src="/js/imgview.js?v=2.0.5" async></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.5" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>