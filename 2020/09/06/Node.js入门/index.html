<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="毕业后就一直混迹在深圳的不知名攻城狮"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.5"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.5"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><title>Node.js入门 | sunshine-zwq</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Node.js入门</h1><a id="logo" href="/.">sunshine-zwq</a><p class="description">Where there is a will, there is a way.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Node.js入门</h1><div class="post-meta"><a href="/2020/09/06/Node.js%E5%85%A5%E9%97%A8/#comments" class="comment-count"></a><p><span class="date">2020/09/06</span><span><a href="/categories/Node-js/" class="category">Node.js</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="Node-js简介"><a href="#Node-js简介" class="headerlink" title="Node.js简介"></a>Node.js简介</h2><p><strong>简介：</strong></p>
<p>(1).开发者：瑞安·达尔（Ryan Dahl）</p>
<p>(2).Node.js是一个能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript运行环境。</p>
<p>(3).Node采用Google开发的V8引擎运行js代码，使用事件驱动、非阻塞和异步I/O模型等技术来提高性能，可优化应用程序的传输量和规模。</p>
<p>(4).Node大部分基本模块都用JavaScript编写。在Node出现之前，JS通常作为客户端程序设计语言使用，以JS写出的程序常在用户的浏览器上运行。</p>
<p><strong>特点：</strong></p>
<p>(1).Node.js允许通过JS和一系列模块来编写服务器端应用和网络相关的应用。</p>
<p>(2).核心模块包括文件系统I/O、网络（HTTP、TCP、UDP、DNS、TLS/SSL等）、二进制数据流、加密算法、数据流等等。Node模块的API形式简单，降低了编程的复杂度。</p>
<p>(3).使用框架可以加速开发。常用的框架有Express.js、Socket.IO和Connect等。Node.js的程序可以在Microsoft Windows、Linux、Unix、Mac OS X等服务器上运行。</p>
<p>(4).Node.js也可以使用CoffeeScript、TypeScript、Dart语言，以及其他能够编译成JavaScript的语言编程。</p>
<p><strong>用途：</strong></p>
<p>• Web服务API，比如REST<br>• 实时多人游戏<br>• 后端的Web服务，例如跨域、服务器端的请求<br>• 基于Web的应用<br>• 多客户端的通信，如即时通信</p>
<h2 id="Node的基本使用"><a href="#Node的基本使用" class="headerlink" title="Node的基本使用"></a>Node的基本使用</h2><p>使用node执行js：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node hello.js</span><br></pre></td></tr></table></figure>



<h2 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h2><p><strong>ECMAScript标准的缺陷：</strong><br>• 没有模块系统<br>• 标准库较少<br>• 没有标准接口<br>• 缺乏管理系统</p>
<p><strong>CommonJS简介：</strong><br>• CommonJS规范的提出，主要是为了弥补当<br>前JavaScript没有模块化标准的缺陷。<br>• CommonJS规范为JS指定了一个美好的愿景，<br>希望JS能够在任何地方运行。</p>
<h3 id="模块引用"><a href="#模块引用" class="headerlink" title="模块引用"></a>模块引用</h3><p>• 在规范中，定义了require()方法，这个方法接收模块标识，以此将一个模块引入到当前运行环境中。使用require()引入模块以后，该函数会返回一个对象，这个对象代表的就是引入的模块。</p>
<p>模块引用的示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br></pre></td></tr></table></figure>



<p>注意：</p>
<p>1.require()可以传递一个文件的路径作为参数，node会自动根据该路径来引入外部模块</p>
<p>2.这里的路径，<strong>如果使用相对路径，必须以 ./ 或者 ../ 开头</strong></p>
<p>3.路径的后缀.js可以省略</p>
<h3 id="模块定义"><a href="#模块定义" class="headerlink" title="模块定义"></a>模块定义</h3><p>• 在运行环境中，提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一的导出的出口。<br>• 在模块中还存在一个module对象，它代表模块自身，而exports是module的属性。<br>• 在Node中一个文件就是一个模块。<br>• 在Node中，<strong>每一个js文件中的js代码都是独立运行在一个函数中，而不是全局作用域，所以一个模块中的变量和函数在其他模块中无法访问。</strong></p>
<p>使用exports向外暴露属性或方法示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports.x = <span class="number">10</span>;</span><br><span class="line">exports.xxx = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="模块标识"><a href="#模块标识" class="headerlink" title="模块标识"></a>模块标识</h3><p>• 模块标识其实就是模块的名字，也就是传递给require()方法的参数，它必须是符合驼峰命名法的字符串，或者是以 ./ 或 ../ 开头的相对路径、或者绝对路径。</p>
<p><strong>模块分为两大类：核心模块、文件模块。</strong></p>
<p>(1).核心模块</p>
<p>• 由node引擎提供的模块</p>
<p>• 核心模块的标识，就是模块的名字</p>
<p>(2).文件模块</p>
<p>• 由用户自己创建的模块</p>
<p>• 文件模块的标识，就是文件的路径（绝对路径，或相对路径）</p>
<p><strong>在node中有一个全局变量global，它的作用和网页中window类似</strong></p>
<p>• 在全局中创建的变量都会作为global的属性保存</p>
<p>• 在全局中创建的函数都会作为global的方法保存</p>
<p><strong>当node在执行模块中的代码时，它会在代码首尾包裹一层函数</strong>，代码示例：</p>
<p>原始代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 在node中有一个全局变量global，它的作用和网页中window类似</span></span><br><span class="line"><span class="comment"> • 在全局中创建的变量都会作为global的属性保存</span></span><br><span class="line"><span class="comment"> • 在全局中创建的函数都会作为global的方法保存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// console.log(global.a);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> arguments.callee</span></span><br><span class="line"><span class="comment">    - 这个属性保存的是当前执行的函数对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee + <span class="string">""</span>);</span><br></pre></td></tr></table></figure>

<p>实际执行的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123; </span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 在node中有一个全局变量global，它的作用和网页中window类似</span></span><br><span class="line"><span class="comment"> • 在全局中创建的变量都会作为global的属性保存</span></span><br><span class="line"><span class="comment"> • 在全局中创建的函数都会作为global的方法保存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// console.log(global.a);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> arguments.callee</span></span><br><span class="line"><span class="comment">    - 这个属性保存的是当前执行的函数对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee + <span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上模块中的代码都是包装在一个函数中执行的，并且在函数执行时，同时传递进了5个实参：</p>
<p>(1).<strong>exports</strong>：该对象用于将变量或函数暴露到外部</p>
<p>(2).<strong>require</strong>：函数，用来引入外部的模块</p>
<p>(3).<strong>module</strong>：代表的就是当前模块本身，exports就是module的属性</p>
<p>(4).<strong>__filename</strong>：当前模块的完整路径</p>
<p>(5).<strong>__dirname</strong>：当前模块所在文件夹的完整路径</p>
<p><strong>exports和module.exports的区别：</strong></p>
<p>(1).通过exports只能使用 . 的方式来向外暴露内部变量，如exports.xxx = yyy</p>
<p>(2).module.exports既可以通过 . 的方式，也可以直接赋值</p>
<p>​    module.exports.xxx = yyy</p>
<p>​    module.exports = {</p>
<p>​    }</p>
<h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><h3 id="包-package"><a href="#包-package" class="headerlink" title="包 package"></a>包 package</h3><p>• CommonJS的包规范允许我们将一组相关的模块组合到一起，形成一组完整的工具。<br>• CommonJS的包规范由<strong>包结构</strong>和<strong>包描述</strong>文件两个部分组成</p>
<p><strong>包结构：用于组织包中的各种文件</strong></p>
<p>• 包实际上就是一个压缩文件，解压以后还原为目录。符合规范的目录，应该包含如下文件：<br>– <strong>package.json 描述文件（必须要有）</strong><br>– bin 可执行二进制文件<br>– lib js代码<br>– doc 文档<br>– test 单元测试</p>
<p><strong>包描述文件：描述包的相关信息，以供外部读取分析</strong></p>
<p>• 包描述文件用于表达非代码相关的信息，它是一个JSON格式的文件 – package.json，位于包的根目录下，是包的重要组成部分。<br>• package.json中的字段<br>– name、description、version、keywords、maintainers、contributors、bugs、licenses、repositories、dependencies、homepage、os、cpu、engine、builtin、directories、implements、scripts、author、bin、main、devDependencies。</p>
<p><strong>NPM(Node Package Manager)</strong><br>• CommonJS包规范是理论，NPM是其中一种实践。<br>• 对于Node而言，NPM帮助其完成了第三方模块的发布、安装和依赖等。借助NPM，Node与第三方模块之间形成了很好的一个生态系统。</p>
<h3 id="NPM命令"><a href="#NPM命令" class="headerlink" title="NPM命令"></a>NPM命令</h3><p>常用命令：</p>
<p>• <strong>npm –v</strong> 查看npm的版本</p>
<p>• <strong>npm version</strong> 查看所有模块的版本</p>
<p>• <strong>npm search 包名</strong> 搜索包</p>
<p>• <strong>npm install / i 包名</strong> 安装包</p>
<p>• <strong>npm remove / r 包名</strong> 删除包</p>
<p>• <strong>npm install 包名 –save</strong> 安装包并添加到依赖中</p>
<p>• <strong>npm install</strong> 下载当前项目所依赖的包</p>
<p>• <strong>npm install 包名 -g</strong> 全局安装包（全局安装的包一般都是一些工具）</p>
<p>• <strong>npm init</strong> 初始化项目生成package.json文件</p>
<p>• <strong>npm install 包名 –registry=地址</strong> 从镜像源安装</p>
<p>• <strong>npm config set registry 地址</strong> 设置镜像源</p>
<p><strong>安装cnpm（使用淘宝镜像）:</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>



<p><strong>Node搜索包的流程：</strong></p>
<p>• Node在使用模块名字来引入模块时，它会首先在当前目录的node_modules中寻找是否包含有该模块</p>
<p>• 如果有则直接使用，如果没有则去上一级目录的node_modules中寻找</p>
<p>• 如果有则直接使用，如果没有则再去上一级目录寻找，直到找到为止</p>
<p>• 直到找到磁盘的根目录，如果依然没有，则报错</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p><strong>Buffer(缓冲区)</strong></p>
<p>• 从结构上看Buffer非常像一个数组，它的<strong>元素为16进制的两位数</strong>。</p>
<p>• 实际上<strong>一个元素就表示内存中的一个字节</strong>。</p>
<p>• 实际上Buffer中的内存不是通过JavaScript分配的，而是在底层通过C++申请的。</p>
<p>• 也就是我们<strong>可以直接通过Buffer来创建内存中的空间</strong>。</p>
<p><strong>Buffer的操作</strong></p>
<p>• <strong>Buffer.from(str)</strong> 将一个字符串转换为buffer</p>
<p>• <strong>Buffer.alloc(size)</strong> 创建一个指定大小的buffer</p>
<p>• <strong>Buffer.allocUnsafe(size)</strong> 创建一个指定大小的buffer，但是可能包含敏感数据</p>
<p>• <strong>buf.toString()</strong> 将缓冲区的数据转换为字符串</p>
<p><strong>写入操作</strong><br>• 向缓冲区中写入字符串<br>    – buf.write(string[, offset[, length]][, encoding])<br>• 替换指定索引位置的数据<br>    – buf[index]<br>• 将指定值填入到缓冲区的指定位置<br>    – buf.fill(value[, offset[, end]][, encoding])</p>
<p><strong>读取操作</strong><br>• 将缓冲区中的内容，转换为一个字符串返回<br>    – buf.toString([encoding[, start[, end]]])<br>• 读取缓冲区指定索引的内容<br>    – buf[index]</p>
<p><strong>其他操作</strong><br>• 复制缓冲区<br>    – buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])<br>• 对缓冲区切片<br>    – buf.slice([start[, end]])<br>• 拼接缓冲区<br>    – Buffer.concat(list[, totalLength])</p>
<h3 id="fs（文件系统）"><a href="#fs（文件系统）" class="headerlink" title="fs（文件系统）"></a>fs（文件系统）</h3><p>• 在Node中，与文件系统的交互是非常重要的，服务器的本质就将本地的文件发送给远程的客户端<br>• Node通过fs模块来和文件系统进行交互<br>• 该模块提供了一些标准文件访问API来打开、读取、写入文件，以及与其交互。<br>• 要使用fs模块，首先需要对其进行加载<br>    – const fs = require(“fs”);</p>
<p><strong>同步和异步调用</strong><br>• fs模块中所有的操作都有两种形式可供选择同步和异步。<br>• 同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码。<br>• 异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回。</p>
<p><strong>打开和关闭文件</strong><br>• 打开文件<br>    – fs.open(path, flags[, mode], callback)<br>    – fs.openSync(path, flags[, mode])<br>• 关闭文件<br>    – fs.close(fd, callback)<br>    – fs.closeSync(fd)</p>
<p><strong>打开状态(mode)</strong><br>r     读取文件 , 文件不存在则出现异常<br>r+     读写文件 , 文件不存在则出现异常<br>rs     在同步模式下打开文件用于读取<br>rs+     在同步模式下打开文件用于读写<br>w     打开文件用于写操作 , 如果不存在则创建，如果存在则截断<br>wx     打开文件用于写操作 , 如果 存在则打开失败<br>w+     打开文件用于读写 , 如果不存在则创建 , 如果存在则截断<br>wx+     打开文件用于读写 , 如果 存在则打开失败<br>a     打开文件用于追加 , 如果不存在则创建<br>ax     打开文件用于追加 , 如果路径存在则失败<br>a+     打开文件进行读取和追加 , 如果不存在则创建该文件<br>ax+     打开文件进行读取和追加 , 如果路径存在则失败</p>
<h4 id="同步文件写入"><a href="#同步文件写入" class="headerlink" title="同步文件写入"></a>同步文件写入</h4><p>• fs.writeSync(fd, buffer, offset, length[, position])<br>• fs.writeSync(fd, data[, position[, encoding]])</p>
<p>• 要完成同步写入文件，先需要通过openSync()打开文件来获取一个文件描述符，然后在通过writeSync()写入文件。</p>
<p>• 参数<br>    – fd 文件描述符，通过openSync()获取<br>    – data 要写入的数据（String 或 Buffer）<br>    – offset buffer写入的偏移量<br>    – length 写入的长度<br>    – position 写入的起始位置<br>    – encoding 写入编码</p>
<p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    文件系统（File System）</span></span><br><span class="line"><span class="comment">        - 文件系统简单来说就是通过Node来操作系统中的文件</span></span><br><span class="line"><span class="comment">        - 使用文件系统，需要先引入fs模块，fs是核心模块，直接引入不需要下载</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    同步文件的写入</span></span><br><span class="line"><span class="comment">        - 手动操作的步骤</span></span><br><span class="line"><span class="comment">            1.打开文件</span></span><br><span class="line"><span class="comment">                fs.openSync(path, flags[, mode])</span></span><br><span class="line"><span class="comment">                    - path 要打开的文件路径</span></span><br><span class="line"><span class="comment">                    - flags 打开文件要做的操作的类型</span></span><br><span class="line"><span class="comment">                        r 只读的</span></span><br><span class="line"><span class="comment">                        w 可写的</span></span><br><span class="line"><span class="comment">                    - mode 设置文件的操作权限，一般不传</span></span><br><span class="line"><span class="comment">                    返回值：该方法会返回一个文件的描述符作为结果，我们可以通过该描述符来对文件进行各种操作</span></span><br><span class="line"><span class="comment">            2.向文件中写入内容</span></span><br><span class="line"><span class="comment">                fs.writeSync(fd, string[, position[, encoding]])</span></span><br><span class="line"><span class="comment">                    - fd 文件的描述符，需要传递写入的文件的描述符</span></span><br><span class="line"><span class="comment">                    - string 要写入的内容</span></span><br><span class="line"><span class="comment">                    - position 写入的起始位置</span></span><br><span class="line"><span class="comment">                    - encoding 写入的编码，默认utf-8</span></span><br><span class="line"><span class="comment">            3.保存并关闭文件</span></span><br><span class="line"><span class="comment">                fs.close(fd)</span></span><br><span class="line"><span class="comment">                    - fd 要关闭的文件的描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line"><span class="keyword">var</span> fd = fs.openSync(<span class="string">"hello.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向文件中写入内容</span></span><br><span class="line">fs.writeSync(fd, <span class="string">"今天天气真不错~~~"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line">fs.closeSync(fd);</span><br></pre></td></tr></table></figure>



<h4 id="异步文件写入"><a href="#异步文件写入" class="headerlink" title="异步文件写入"></a>异步文件写入</h4><p>• fs.write(fd, buffer, offset, length[, position], callback)<br>• fs.write(fd, data[, position[, encoding]], callback)</p>
<p>• 要使用异步写入文件，先需要通过open()打开文件，然后在回调函数中通过write()写入。</p>
<p>• 参数：<br>    – fd 文件描述符<br>    – data 要写入的数据（String 或 Buffer）<br>    – offset buffer写入的偏移量<br>    – length 写入的长度<br>    – position 写入的起始位置<br>    – encoding 写入编码</p>
<p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    异步文件写入</span></span><br><span class="line"><span class="comment">        fs.open(path, flags[, mode], callback)</span></span><br><span class="line"><span class="comment">            - 用来打开一个文件</span></span><br><span class="line"><span class="comment">            - 异步调用的方法，结果都是通过回调函数的参数返回的</span></span><br><span class="line"><span class="comment">            - 回调函数的两个参数：</span></span><br><span class="line"><span class="comment">                - err 错误对象，如果没有错误则为null</span></span><br><span class="line"><span class="comment">                - fd 文件的描述符</span></span><br><span class="line"><span class="comment">        fs.write(fd, string[, position[, encoding]], callback)</span></span><br><span class="line"><span class="comment">            - 用来异步写入一个文件</span></span><br><span class="line"><span class="comment">        fs.close(fd, callback)</span></span><br><span class="line"><span class="comment">            - 用来关闭文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line">fs.open(<span class="string">"hello2.txt"</span>, <span class="string">"w"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, fd</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        fs.write(fd, <span class="string">"这是异步写入的内容"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"写入成功~~~"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭文件</span></span><br><span class="line">            fs.close(fd, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">"文件已关闭~~~"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="简单文件写入"><a href="#简单文件写入" class="headerlink" title="简单文件写入"></a>简单文件写入</h4><p>• fs.writeFile(file, data[, options], callback)<br>• fs.writeFileSync(file, data[, options])</p>
<p>• 参数：<br>    – file 文件路径<br>    – data 被写入的内容，可以是String或Buffer<br>    – options 对象，包含属性（encoding、mode、flag）<br>    – callback 回调函数</p>
<p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    简单文件写入</span></span><br><span class="line"><span class="comment">    fs.writeFile(file, data[, options], callback)</span></span><br><span class="line"><span class="comment">    fs.writeFileSync(file, data[, options])</span></span><br><span class="line"><span class="comment">        - file 要操作的文件路径</span></span><br><span class="line"><span class="comment">        - data 要写入的数据</span></span><br><span class="line"><span class="comment">        - options 选项，可以对写入进行一些设置</span></span><br><span class="line"><span class="comment">            - flag</span></span><br><span class="line"><span class="comment">                r 只读</span></span><br><span class="line"><span class="comment">                w 可写</span></span><br><span class="line"><span class="comment">                a 追加</span></span><br><span class="line"><span class="comment">        - callback 当写入完成以后执行的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line">fs.writeFile(<span class="string">"hello3.txt"</span>, <span class="string">"这是通过writeFile写入的内容"</span>, &#123;<span class="attr">flag</span>: <span class="string">"a"</span>&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"写入成功~~~"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="流式文件写入"><a href="#流式文件写入" class="headerlink" title="流式文件写入"></a>流式文件写入</h4><p>• 往一个文件中写入大量数据时，最好的方法之一是使用流。<br>• 若要将数据异步传送到文件，首需要使用以下语法创建一个Writable对象：<br>    – fs.createWriteStream(path[, options])<br>        • path 文件路径<br>        • options {encoding:””,mode:””,flag:””}<br>• 一旦你打开了Writable文件流，就可以使用write()方法来写入它，写入完成后，再<strong>调用end()方法来关闭流</strong>。</p>
<p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    同步、异步、简单文件的写入，都不适合大文件的写入，性能较差，容易导致内存溢出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 流式文件写入</span></span><br><span class="line"><span class="comment">// 创建一个可写流</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    fs.createWriteStram(path[, options])</span></span><br><span class="line"><span class="comment">        - 可以用来创建一个可写流</span></span><br><span class="line"><span class="comment">        - path 文件路径</span></span><br><span class="line"><span class="comment">        - options 配置的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> ws = fs.createWriteStream(<span class="string">"hello5.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过监听流的open和close事件来监听流的打开和关闭</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    on(事件字符串， 回调函数)</span></span><br><span class="line"><span class="comment">        - 可以为对象绑定一个事件</span></span><br><span class="line"><span class="comment">    once(事件字符串， 回调函数)</span></span><br><span class="line"><span class="comment">        - 可以为对象绑定一个一次性的事件，该事件将会在触发一次之后自动失效</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ws.once(<span class="string">"open"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"流打开了~"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">ws.once(<span class="string">"close"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"流关闭了~"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过ws向文件中输出内容</span></span><br><span class="line">ws.write(<span class="string">"通过可写流写入文件的内容1"</span>);</span><br><span class="line">ws.write(<span class="string">"通过可写流写入文件的内容2"</span>);</span><br><span class="line">ws.write(<span class="string">"通过可写流写入文件的内容3"</span>);</span><br><span class="line">ws.write(<span class="string">"通过可写流写入文件的内容4"</span>);</span><br><span class="line">ws.write(<span class="string">"通过可写流写入文件的内容5"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭流</span></span><br><span class="line">ws.end();</span><br></pre></td></tr></table></figure>



<h4 id="同步文件读取"><a href="#同步文件读取" class="headerlink" title="同步文件读取"></a>同步文件读取</h4><p>• fs.readSync(fd, buffer, offset, length, position)</p>
<p>– 参数：<br>    • fd 文件描述符<br>    • buffer 读取文件的缓冲区<br>    • offset buffer的开始写入的位置<br>    • length 要读取的字节数<br>    • position 开始读取文件的位置</p>
<h4 id="异步文件读取"><a href="#异步文件读取" class="headerlink" title="异步文件读取"></a>异步文件读取</h4><p>• fs.read(fd, buffer, offset, length, position, callback)</p>
<p>– 参数：<br>    • fd 文件描述符<br>    • buffer 读取文件的缓冲区<br>    • offset buffer的开始写入的位置<br>    • length 要读取的字节数<br>    • position 开始读取文件的位置<br>    • callback 回调函数 参数err , bytesRead , buffer</p>
<h4 id="简单文件读取"><a href="#简单文件读取" class="headerlink" title="简单文件读取"></a>简单文件读取</h4><p>• fs.readFile(file[, options], callback)<br>• fs.readFileSync(file[, options])</p>
<p>– 参数：<br>    • file 文件路径或文件描述符<br>    • options<br>        – encoding  默认 = null<br>        – flag  默认 = ‘r’<br>    • callback 回调函数，有两个参数err 、data</p>
<p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    简单文件读取</span></span><br><span class="line"><span class="comment">        fs.readFile(path[, options], callback)</span></span><br><span class="line"><span class="comment">        fs.readFileSync(path[, options])</span></span><br><span class="line"><span class="comment">            - path 要读取的文件路径</span></span><br><span class="line"><span class="comment">            - options 读取的选项</span></span><br><span class="line"><span class="comment">            - callback 回调函数，通过回调函数将读取到内容返回(err, data)</span></span><br><span class="line"><span class="comment">                err 错误对象</span></span><br><span class="line"><span class="comment">                data 读取到的数据，会返回一个Buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">"hello3.txt"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data.toString())</span><br><span class="line">        <span class="comment">// 将data写入到文件中</span></span><br><span class="line">        fs.writeFile(<span class="string">"copyOf_hello3.txt"</span>, data, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"文件写入成功"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="流式文件读取"><a href="#流式文件读取" class="headerlink" title="流式文件读取"></a>流式文件读取</h4><p>• 从一个文件中读取大量的数据时，最好的方法之一就是流式读取，这样将把一个文件作为Readable流的形式打开。<br>• 要从异步从文件传输数据，首先需要通过以下语法创建一个Readable流对象：<br>    – fs.createReadStream(path[, options])<br>        • path 文件路径<br>        • options {encoding:””,mode:””,flag:””}<br>• 当你打开Readable文件流以后，可以通过readable事件和read()请求，或通过data事件处理程序轻松地从它读出。</p>
<p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    流式文件读取也适用于一些比较大的文件，可以分多次将文件读取到内存中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个可读流</span></span><br><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">"avatar.jpg"</span>);</span><br><span class="line"><span class="comment">// 创建一个可写流</span></span><br><span class="line"><span class="keyword">var</span> ws = fs.createWriteStream(<span class="string">"test.jpg"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听流的打开和关闭</span></span><br><span class="line">rs.once(<span class="string">"open"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"可读流打开了~"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">rs.once(<span class="string">"close"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"可读流关闭了~"</span>);</span><br><span class="line">    <span class="comment">// 数据读取完毕，关闭可写流</span></span><br><span class="line">    ws.end();</span><br><span class="line">&#125;)</span><br><span class="line">ws.once(<span class="string">"open"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"可写流打开了~"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">ws.once(<span class="string">"close"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"可写流关闭了~"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果要读取一个可读流中的数据，必须要为可读流绑定一个data事件，data事件绑定完毕，它会自动开始读取数据</span></span><br><span class="line">rs.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="comment">// 将读取到的数据写入到可写流中</span></span><br><span class="line">    ws.write(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>利用pipe()实现更简洁的文件复制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个可读流</span></span><br><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">"avatar.jpg"</span>);</span><br><span class="line"><span class="comment">// 创建一个可写流</span></span><br><span class="line"><span class="keyword">var</span> ws = fs.createWriteStream(<span class="string">"test.jpg"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pipe()可以将可读流中的内容，直接输出到可写流中</span></span><br><span class="line">rs.pipe(ws);</span><br></pre></td></tr></table></figure>



<h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><p>• 验证路径是否存在<br>    – fs.exists(path，callback)<br>    – fs.existsSync(path)</p>
<p>• 获取文件信息<br>    – fs.stat(path, callback)<br>    – fs.statSync(path)</p>
<p>• 删除文件<br>    – fs.unlink(path, callback)<br>    – fs.unlinkSync(path)</p>
<p>• 列出文件<br>    – fs.readdir(path[, options], callback)<br>    – fs.readdirSync(path[, options])</p>
<p>• 截断文件<br>    – fs.truncate(path, len, callback)<br>    – fs.truncateSync(path, len)</p>
<p>• 建立目录<br>    – fs.mkdir(path[, mode], callback)<br>    – fs.mkdirSync(path[, mode])</p>
<p>• 删除目录<br>    – fs.rmdir(path, callback)<br>    – fs.rmdirSync(path)</p>
<p>• 重命名文件和目录（可实现剪切的功能）<br>    – fs.rename(oldPath, newPath, callback)<br>    – fs.renameSync(oldPath, newPath)</p>
<p>• 监视文件更改写入<br>    – fs.watchFile(filename[, options], listener)</p>
</div><div class="post-copyright"><blockquote><p>原文作者: zwq</p><p>原文链接: <a href="https://sunshine-zwq.github.io/2020/09/06/Node.js入门/">https://sunshine-zwq.github.io/2020/09/06/Node.js入门/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/jQuery/">jQuery</a><a href="/tags/Node-js/">Node.js</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2020/09/13/JS%E6%A8%A1%E5%9D%97%E5%8C%96/" class="pre">JS模块化</a><a href="/2020/08/29/jQuery%E5%8C%85%E8%A3%B9%E8%8A%82%E7%82%B9%E6%96%B9%E6%B3%95wrap()%E3%80%81wrapAll()%E3%80%81wrapInner()%E7%9A%84%E5%8C%BA%E5%88%AB/" class="next">jQuery包裹节点方法wrap()、wrapAll()、wrapInner()的区别</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Node-js简介"><span class="toc-text">Node.js简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Node的基本使用"><span class="toc-text">Node的基本使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CommonJS规范"><span class="toc-text">CommonJS规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#模块引用"><span class="toc-text">模块引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模块定义"><span class="toc-text">模块定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模块标识"><span class="toc-text">模块标识</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NPM"><span class="toc-text">NPM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#包-package"><span class="toc-text">包 package</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NPM命令"><span class="toc-text">NPM命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件系统"><span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer"><span class="toc-text">Buffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fs（文件系统）"><span class="toc-text">fs（文件系统）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#同步文件写入"><span class="toc-text">同步文件写入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异步文件写入"><span class="toc-text">异步文件写入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简单文件写入"><span class="toc-text">简单文件写入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#流式文件写入"><span class="toc-text">流式文件写入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步文件读取"><span class="toc-text">同步文件读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异步文件读取"><span class="toc-text">异步文件读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简单文件读取"><span class="toc-text">简单文件读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#流式文件读取"><span class="toc-text">流式文件读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他操作"><span class="toc-text">其他操作</span></a></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/12/01/element-ui%E7%9A%84Tree%20%E6%A0%91%E5%BD%A2%E6%8E%A7%E4%BB%B6%E8%A7%A6%E5%8F%91%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9%E7%82%B9%E5%87%BB%E5%A4%84%E7%90%86/">element-ui的Tree 树形控件触发指定节点点击处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/24/%E5%B8%B8%E7%94%A8js%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95/">常用js工具方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/16/%E5%88%A9%E7%94%A8LinkedHashMap%E5%AE%9E%E7%8E%B0LRU%E7%AE%97%E6%B3%95/">利用LinkedHashMap实现LRU算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/30/Java8%E7%89%B9%E6%80%A7/">Java8特性</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/13/JS%E6%A8%A1%E5%9D%97%E5%8C%96/">JS模块化</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/06/Node.js%E5%85%A5%E9%97%A8/">Node.js入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/29/jQuery%E5%8C%85%E8%A3%B9%E8%8A%82%E7%82%B9%E6%96%B9%E6%B3%95wrap()%E3%80%81wrapAll()%E3%80%81wrapInner()%E7%9A%84%E5%8C%BA%E5%88%AB/">jQuery包裹节点方法wrap()、wrapAll()、wrapInner()的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/23/%E7%94%A8apache%E7%9A%84ftpserver%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1%E5%99%A8/">用apache的ftpserver搭建FTP服务器</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/12/json%E8%BD%AC%E6%8D%A2/">json转换</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Node-js/">Node.js</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue-js/">Vue.js</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ftp/">ftp</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/json/" style="font-size: 15px;">json</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/ftp/" style="font-size: 15px;">ftp</a> <a href="/tags/element-ui/" style="font-size: 15px;">element-ui</a> <a href="/tags/js%E6%A8%A1%E5%9D%97%E5%8C%96/" style="font-size: 15px;">js模块化</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 15px;">正则表达式</a> <a href="/tags/Node-js/" style="font-size: 15px;">Node.js</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 15px;">工具</a> <a href="/tags/ECMAScript/" style="font-size: 15px;">ECMAScript</a> <a href="/tags/java8/" style="font-size: 15px;">java8</a> <a href="/tags/Lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/Stream/" style="font-size: 15px;">Stream</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://github.com/sunshine-zwq" title="我的Github" target="_blank">我的Github</a><ul></ul><a href="https://blog.csdn.net/zwq1105" title="我的CSDN博客" target="_blank">我的CSDN博客</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">zwq.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.5"></script><div id="fullscreen-img" class="hide"><span class="close"></span></div><script type="text/javascript" src="/js/imgview.js?v=2.0.5" async></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.5" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>