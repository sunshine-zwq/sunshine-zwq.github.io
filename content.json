[{"title":"双重校验锁实现的单例，已经使用了synchronized，为什么还需要volatile？","date":"2020-12-05T05:00:00.000Z","path":"2020/12/05/双重校验锁实现的单例，已经使用了synchronized，为什么还需要volatile？/","text":"问题双重校验锁实现的单例，已经使用了synchronized，为什么还需要volatile？ 1234567891011121314public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 原因解析synchronized 能保证临界区的原子性、有序性和可见性。volatile 也能保证所修饰对象的可见性，并且还能禁止重排序。 那么问题就来了：既然 volatile 的功能 synchronized基本都具备，那为啥还需要 volatile 修饰单例对象呢？ 答：new 操作不是原子操作，在 JVM 层面会导致重排序。synchronized关于有序性的准确解释：synchronized只能保证有序性却不能禁止重排序。 1234567891011121314151617181920public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; // #1 synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); // #2 &#125; &#125; &#125; return singleton; &#125; &#125; // 当两个线程A和B同时进入方法时，加入A抢夺到锁，则A继续执行，当A执行到new操作时，由于new操作不是原子操作，且synchronized也不能禁止重排序，// 我们首先将new操作原子化：a-开辟内存空间；b-初始化对象；c-将引用赋值给变量// 正常的执行顺序应该是a-b-c，不禁止重排序的情况下可能是：a-c-b// 当线程A执行a-c，即将执行b的时候，由于cpu时间片结束，则有可能会让步给线程B，// 线程B进行第一次判断，singleton由于已经有了内存指向，并不为空，此时，对象还没有执行初始化，但已经判断为true，并且返回了。// 此时，就产生了严重的错误，因此需要 volatile 来禁止重排序。 既然synchronized无法禁止指令重排，那synchronized可以保证有序性怎么理解？ 答：这个有序性是相对语义来看的，线程与线程间，每一个 synchronized 块可以看成是一个原子操作，它保证每个时刻只有一个线程执行同步代码，相当于单线程，而单线程的指令重排是没有问题的。这就满足了as-if-serial语义的一个关键前提，那就是单线程，因为有as-if-serial语义保证，单线程的有序性就天然存在了。 参考链接https://www.cnblogs.com/melonman/p/13067678.html https://blog.csdn.net/chinaleesunnyboy/article/details/107530702 https://blog.csdn.net/qq_45401061/article/details/104415653","tags":[{"name":"java","slug":"java","permalink":"https://sunshine-zwq.github.io/tags/java/"},{"name":"并发编程","slug":"并发编程","permalink":"https://sunshine-zwq.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"面试","slug":"面试","permalink":"https://sunshine-zwq.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"[转载]Java并发编程：volatile的使用及其原理","date":"2020-12-04T16:01:00.000Z","path":"2020/12/05/[转载]Java并发编程：volatile的使用及其原理/","text":"原文链接https://www.cnblogs.com/paddix/p/5428507.html作者：liuxiaopeng博客地址：http://www.cnblogs.com/paddix/ 一、volatile的作用在《Java并发编程：核心理论》一文中，我们已经提到过可见性、有序性及原子性问题，通常情况下我们可以通过Synchronized关键字来解决这些个问题，不过如果对Synchronized原理有了解的话，应该知道Synchronized是一个比较重量级的操作，对系统的性能有比较大的影响，所以，如果有其他解决方案，我们通常都避免使用Synchronized来解决问题。而volatile关键字就是Java中提供的另一种解决可见性和有序性问题的方案。对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读/写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。 二、volatile的使用关于volatile的使用，我们可以通过几个例子来说明其使用方式和场景。 1、防止重排序我们从一个最经典的例子来分析重排序问题。大家应该都很熟悉单例模式的实现，而在并发环境下的单例实现方式，我们通常可以采用双重检查加锁（DCL）的方式来实现。其源码如下： 123456789101112131415161718192021package com.paddx.test.concurrent;public class Singleton &#123; public static volatile Singleton singleton; /** * 构造函数私有，禁止外部实例化 */ private Singleton() &#123;&#125;; public static Singleton getInstance() &#123; if (singleton == null) &#123; synchronized (singleton) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 现在我们分析一下为什么要在变量singleton之间加上volatile关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤： （1）分配内存空间。 （2）初始化对象。 （3）将内存空间的地址赋值给对应的引用。 但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程： （1）分配内存空间。 （2）将内存空间的地址赋值给对应的引用。 （3）初始化对象 如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。 2、实现可见性可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。volatile关键字能有效的解决这个问题，我们看下下面的例子，就可以知道其作用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.paddx.test.concurrent;public class VolatileTest &#123; int a = 1; int b = 2; public void change()&#123; a = 3; b = a; &#125; public void print()&#123; System.out.println(\"b=\"+b+\";a=\"+a); &#125; public static void main(String[] args) &#123; while (true)&#123; final VolatileTest test = new VolatileTest(); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; test.change(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; test.print(); &#125; &#125;).start(); &#125; &#125;&#125; 直观上说，这段代码的结果只可能有两种：b=3;a=3 或 b=2;a=1。不过运行上面的代码（可能时间上要长一点），你会发现除了上两种结果之外，还出现了第三种结果： 1234567891011......b&#x3D;2;a&#x3D;1b&#x3D;2;a&#x3D;1b&#x3D;3;a&#x3D;3b&#x3D;3;a&#x3D;3b&#x3D;3;a&#x3D;1b&#x3D;3;a&#x3D;3b&#x3D;2;a&#x3D;1b&#x3D;3;a&#x3D;3b&#x3D;3;a&#x3D;3...... 为什么会出现b=3;a=1这种结果呢？正常情况下，如果先执行change方法，再执行print方法，输出结果应该为b=3;a=3。相反，如果先执行的print方法，再执行change方法，结果应该是 b=2;a=1。那b=3;a=1的结果是怎么出来的？原因就是第一个线程将值a=3修改后，但是对第二个线程是不可见的，所以才出现这一结果。如果将a和b都改成volatile类型的变量再执行，则再也不会出现b=3;a=1的结果了。 3、保证原子性关于原子性的问题，上面已经解释过。volatile只能保证对单次读/写的原子性。这个问题可以看下JLS中的描述： 123456789101117.7 Non-Atomic Treatment of double and longFor the purposes of the Java programming language memory model, a single write to a non-volatile long or double value is treated as two separate writes: one to each 32-bit half. This can result in a situation where a thread sees the first 32 bits of a 64-bit value from one write, and the second 32 bits from another write.Writes and reads of volatile long and double values are always atomic.Writes to and reads of references are always atomic, regardless of whether they are implemented as 32-bit or 64-bit values.Some implementations may find it convenient to divide a single write action on a 64-bit long or double value into two write actions on adjacent 32-bit values. For efficiency&#39;s sake, this behavior is implementation-specific; an implementation of the Java Virtual Machine is free to perform writes to long and double values atomically or in two parts.Implementations of the Java Virtual Machine are encouraged to avoid splitting 64-bit values where possible. Programmers are encouraged to declare shared 64-bit values as volatile or synchronize their programs correctly to avoid possible complications. 这段话的内容跟我前面的描述内容大致类似。因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读/写可能不是原子的。因此，鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读/写操作都具有原子性。 关于volatile变量对原子性保证，有一个问题容易被误解。现在我们就通过下列程序来演示一下这个问题： 123456789101112131415161718192021222324252627282930package com.paddx.test.concurrent;public class VolatileTest01 &#123; volatile int i; public void addI()&#123; i++; &#125; public static void main(String[] args) throws InterruptedException &#123; final VolatileTest01 test01 = new VolatileTest01(); for (int n = 0; n &lt; 1000; n++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; test01.addI(); &#125; &#125;).start(); &#125; Thread.sleep(10000);//等待10秒，保证上面程序执行完成 System.out.println(test01.i); &#125;&#125; 大家可能会误认为对变量i加上关键字volatile后，这段程序就是线程安全的。大家可以尝试运行上面的程序。下面是我本地运行的结果： 可能每个人运行的结果不相同。不过应该能看出，volatile是无法保证原子性的（否则结果应该是1000）。原因也很简单，i++其实是一个复合操作，包括三步骤： （1）读取i的值。 （2）对i加1。 （3）将i的值写回内存。 volatile是无法保证这三个操作是具有原子性的，我们可以通过AtomicInteger或者Synchronized来保证+1操作的原子性。 注：上面几段代码中多处执行了Thread.sleep()方法，目的是为了增加并发问题的产生几率，无其他作用。 三、volatile的原理通过上面的例子，我们基本应该知道了volatile是什么以及怎么使用。现在我们再来看看volatile的底层是怎么实现的。 1、可见性实现在前文中已经提及过，线程本身并不直接与主内存进行数据的交互，而是通过线程的工作内存来完成相应的操作。这也是导致线程间数据不可见的本质原因。因此要实现volatile变量的可见性，直接从这方面入手即可。对volatile变量的写操作与普通变量的主要区别有两点： （1）修改volatile变量时会强制将修改后的值刷新的主内存中。 （2）修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。 通过这两个操作，就可以解决volatile变量的可见性问题。 2、有序性实现在解释这个问题前，我们先来了解一下Java中的happen-before规则，JSR 133中对Happen-before的定义如下： 1Two actions can be ordered by a happens-before relationship.If one action happens before another, then the first is visible to and ordered before the second. 通俗一点说就是如果a happen-before b，则a所做的任何操作对b是可见的。（这一点大家务必记住，因为happen-before这个词容易被误解为是时间的前后）。我们再来看看JSR 133中定义了哪些happen-before规则： 123456• Each action in a thread happens before every subsequent action in that thread.• An unlock on a monitor happens before every subsequent lock on that monitor.• A write to a volatile field happens before every subsequent read of that volatile.• A call to start() on a thread happens before any actions in the started thread.• All actions in a thread happen before any other thread successfully returns from a join() on that thread.• If an action a happens before an action b, and b happens before an action c, then a happens before c. 翻译过来为： 同一个线程中的，前面的操作 happen-before 后续的操作。（即单线程内按代码顺序执行。但是，在不影响在单线程环境执行结果的前提下，编译器和处理器可以进行重排序，这是合法的。换句话说，这一是规则无法保证编译重排和指令重排）。 监视器上的解锁操作 happen-before 其后续的加锁操作。（Synchronized 规则） 对volatile变量的写操作 happen-before 后续的读操作。（volatile 规则） 线程的start() 方法 happen-before 该线程所有的后续操作。（线程启动规则） 线程所有的操作 happen-before 其他线程在该线程上调用 join 返回成功后的操作。 如果 a happen-before b，b happen-before c，则a happen-before c（传递性）。 这里我们主要看下第三条：volatile变量的保证有序性的规则。《Java并发编程：核心理论》一文中提到过重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM会对volatile变量限制这两种类型的重排序。下面是JMM针对volatile变量所规定的重排序规则表： 3、内存屏障为了实现volatile可见性和happen-befor的语义。JVM底层是通过一个叫做“内存屏障”的东西来完成。内存屏障，也叫做内存栅栏，是一组处理器指令，用于实现对内存操作的顺序限制。下面是完成上述规则所要求的内存屏障： （1）LoadLoad 屏障执行顺序：Load1—&gt;Loadload—&gt;Load2确保Load2及后续Load指令加载数据之前能访问到Load1加载的数据。 （2）StoreStore 屏障执行顺序：Store1—&gt;StoreStore—&gt;Store2确保Store2以及后续Store指令执行前，Store1操作的数据对其它处理器可见。 （3）LoadStore 屏障执行顺序： Load1—&gt;LoadStore—&gt;Store2确保Store2和后续Store指令执行前，可以访问到Load1加载的数据。 （4）StoreLoad 屏障执行顺序: Store1—&gt; StoreLoad—&gt;Load2确保Load2和后续的Load指令读取之前，Store1的数据对其他处理器是可见的。 最后我可以通过一个实例来说明一下JVM中是如何插入内存屏障的： 1234567891011121314151617181920212223242526272829package com.paddx.test.concurrent;public class MemoryBarrier &#123; int a, b; volatile int v, u; void f() &#123; int i, j; i = a; j = b; i = v; //LoadLoad j = u; //LoadStore a = i; b = j; //StoreStore v = i; //StoreStore u = j; //StoreLoad i = u; //LoadLoad //LoadStore j = b; a = i; &#125;&#125; 四、总结总体上来说volatile的理解还是比较困难的，如果不是特别理解，也不用急，完全理解需要一个过程，在后续的文章中也还会多次看到volatile的使用场景。这里暂且对volatile的基础知识和原来有一个基本的了解。总体来说，volatile是并发编程中的一种优化，在某些场景下可以代替Synchronized。但是，volatile不能完全取代Synchronized的位置，只有在一些特殊的场景下，才能适用volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全： （1）对变量的写操作不依赖于当前值。 （2）该变量没有包含在具有其他变量的不变式中。","tags":[{"name":"java","slug":"java","permalink":"https://sunshine-zwq.github.io/tags/java/"},{"name":"并发编程","slug":"并发编程","permalink":"https://sunshine-zwq.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"[转载]Java并发编程：线程间的协作(wait、notify、sleep、yield、join)","date":"2020-12-04T16:00:00.000Z","path":"2020/12/05/[转载]Java并发编程：线程间的协作(wait、notify、sleep、yield、join)/","text":"原文链接https://www.cnblogs.com/paddix/p/5381958.html作者：liuxiaopeng博客地址：http://www.cnblogs.com/paddix/ 一、线程的状态Java中线程中状态可分为五种：New（新建状态），Runnable（就绪状态），Running（运行状态），Blocked（阻塞状态），Dead（死亡状态）。 New：新建状态，当线程创建完成时为新建状态，即new Thread(…)，还没有调用start方法时，线程处于新建状态。 Runnable：就绪状态，当调用线程的的start方法后，线程进入就绪状态，等待CPU资源。处于就绪状态的线程由Java运行时系统的线程调度程序(thread scheduler)来调度。 Running：运行状态，就绪状态的线程获取到CPU执行权以后进入运行状态，开始执行run方法。 Blocked：阻塞状态，线程没有执行完，由于某种原因（如，I/O操作等）让出CPU执行权，自身进入阻塞状态。 Dead：死亡状态，线程执行完成或者执行过程中出现异常，线程就会进入死亡状态。 这五种状态之间的转换关系如下图所示： 有了对这五种状态的基本了解，现在我们来看看Java中是如何实现这几种状态的转换的。 二、wait/notify/notifyAll方法的使用1、wait方法 void wait() Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. void wait(long timeout) Causes the current thread to wait until either another thread invokes the notify() method or the notifyAll() method for this object, or a specified amount of time has elapsed. void wait(long timeout, int nanos) Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object, or some other thread interrupts the current thread, or a certain amount of real time has elapsed. JDK中一共提供了这三个版本的方法， （1）wait()方法的作用是将当前运行的线程挂起（即让其进入阻塞状态），直到notify或notifyAll方法来唤醒线程. （2）wait(long timeout)，该方法与wait()方法类似，唯一的区别就是在指定时间内，如果没有notify或notifAll方法的唤醒，也会自动唤醒。 （3）至于wait(long timeout,long nanos)，本意在于更精确的控制调度时间，不过从目前版本来看，该方法貌似没有完整的实现该功能，其源码(JDK1.8)如下： 12345678910111213141516public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException(\"timeout value is negative\"); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( \"nanosecond timeout value out of range\"); &#125; if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; timeout == 0)) &#123; timeout++; &#125; wait(timeout); &#125; 从源码来看，JDK8中对纳秒的处理，只做了四舍五入，所以还是按照毫秒来处理的，可能在未来的某个时间点会用到纳秒级别的精度。虽然JDK提供了这三个版本，其实最后都是调用wait(long timeout)方法来实现的，wait()方法与wait(0)等效，而wait(long timeout,int nanos)从上面的源码可以看到也是通过wait(long timeout)来完成的。 下面我们通过一个简单的例子来演示wait()方法的使用： 123456789101112131415161718192021222324package com.paddx.test.concurrent;public class WaitTest &#123; public void testWait()&#123; System.out.println(\"Start-----\"); try &#123; wait(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"End-------\"); &#125; public static void main(String[] args) &#123; final WaitTest test = new WaitTest(); new Thread(new Runnable() &#123; @Override public void run() &#123; test.testWait(); &#125; &#125;).start(); &#125;&#125; 这段代码的意图很简单，就是程序执行以后，让其暂停一秒，然后再执行。运行上述代码，查看结果： 123456Start-----Exception in thread &quot;Thread-0&quot; java.lang.IllegalMonitorStateException at java.lang.Object.wait(Native Method) at com.paddx.test.concurrent.WaitTest.testWait(WaitTest.java:8) at com.paddx.test.concurrent.WaitTest$1.run(WaitTest.java:20) at java.lang.Thread.run(Thread.java:745) 这段程序并没有按我们的预期输出相应结果，而是抛出了一个异常。大家可能会觉得奇怪为什么会抛出异常？而抛出的IllegalMonitorStateException异常又是什么？我们可以看一下JDK中对IllegalMonitorStateException的描述： 1Thrown to indicate that a thread has attempted to wait on an object&#39;s monitor or to notify other threads waiting on an object&#39;s monitor without owning the specified monitor. 这句话的意思大概就是：线程试图等待对象的监视器或者试图通知其他正在等待对象监视器的线程，但本身没有对应的监视器的所有权。其实这个问题在《Java并发编程：Synchronized及其实现原理》一文中有提到过，wait方法是一个本地方法，其底层是通过一个叫做监视器锁的对象来完成的。所以上面之所以会抛出异常，是因为在调用wait方式时没有获取到monitor对象的所有权，那如何获取monitor对象所有权？Java中只能通过Synchronized关键字来完成，修改上述代码，增加Synchronized关键字： 123456789101112131415161718192021222324package com.paddx.test.concurrent;public class WaitTest &#123; public synchronized void testWait()&#123;//增加Synchronized关键字 System.out.println(\"Start-----\"); try &#123; wait(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"End-------\"); &#125; public static void main(String[] args) &#123; final WaitTest test = new WaitTest(); new Thread(new Runnable() &#123; @Override public void run() &#123; test.testWait(); &#125; &#125;).start(); &#125;&#125; 现在再运行上述代码，就能看到预期的效果了： 12Start-----End------- 所以，通过这个例子，大家应该很清楚，wait方法的使用必须在同步的范围内，否则就会抛出IllegalMonitorStateException异常，wait方法的作用就是阻塞当前线程等待notify/notifyAll方法的唤醒，或等待超时后自动唤醒。 2、notify/notifyAll方法 void notify() Wakes up a single thread that is waiting on this object’s monitor. void notifyAll() Wakes up all threads that are waiting on this object’s monitor. 有了对wait方法原理的理解，notify方法和notifyAll方法就很容易理解了。既然wait方式是通过对象的monitor对象来实现的，所以只要在同一对象上去调用notify/notifyAll方法，就可以唤醒对应对象monitor上等待的线程了。notify和notifyAll的区别在于前者只能唤醒monitor上的一个线程，对其他线程没有影响，而notifyAll则唤醒所有的线程，看下面的例子很容易理解这两者的差别： 1234567891011121314151617181920212223242526272829303132333435package com.paddx.test.concurrent;public class NotifyTest &#123; public synchronized void testWait()&#123; System.out.println(Thread.currentThread().getName() +\" Start-----\"); try &#123; wait(0); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() +\" End-------\"); &#125; public static void main(String[] args) throws InterruptedException &#123; final NotifyTest test = new NotifyTest(); for(int i=0;i&lt;5;i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; test.testWait(); &#125; &#125;).start(); &#125; synchronized (test) &#123; test.notify(); &#125; Thread.sleep(3000); System.out.println(\"-----------分割线-------------\"); synchronized (test) &#123; test.notifyAll(); &#125; &#125;&#125; 输出结果如下： 1234567891011Thread-0 Start-----Thread-1 Start-----Thread-2 Start-----Thread-3 Start-----Thread-4 Start-----Thread-0 End------------------分割线-------------Thread-4 End-------Thread-3 End-------Thread-2 End-------Thread-1 End------- 从结果可以看出：调用notify方法时只有线程Thread-0被唤醒，但是调用notifyAll时，所有的线程都被唤醒了。 最后，有两点需要注意： （1）调用wait方法后，线程是会释放对monitor对象的所有权的。 （2）一个通过wait方法阻塞的线程，必须同时满足以下两个条件才能被真正执行： 线程需要被唤醒（超时唤醒或调用notify/notifyll）。 线程唤醒后需要竞争到锁（monitor）。 ​ 三、sleep/yield/join方法解析上面我们已经清楚了wait和notify方法的使用和原理，现在我们再来看另外一组线程间协作的方法。这组方法跟上面方法的最明显区别是：这几个方法都位于Thread类中，而上面三个方法都位于Object类中。至于为什么，大家可以先思考一下。现在我们逐个分析sleep/yield/join方法： 1、sleepsleep方法的作用是让当前线程暂停指定的时间（毫秒），sleep方法是最简单的方法，在上述的例子中也用到过，比较容易理解。唯一需要注意的是其与wait方法的区别。最简单的区别是，wait方法依赖于同步，而sleep方法可以直接调用。而更深层次的区别在于sleep方法只是暂时让出CPU的执行权，并不释放锁。而wait方法则需要释放锁。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.paddx.test.concurrent;public class SleepTest &#123; public synchronized void sleepMethod()&#123; System.out.println(\"Sleep start-----\"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"Sleep end-----\"); &#125; public synchronized void waitMethod()&#123; System.out.println(\"Wait start-----\"); synchronized (this)&#123; try &#123; wait(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"Wait end-----\"); &#125; public static void main(String[] args) &#123; final SleepTest test1 = new SleepTest(); for(int i = 0;i&lt;3;i++)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; test1.sleepMethod(); &#125; &#125;).start(); &#125; try &#123; Thread.sleep(10000);//暂停十秒，等上面程序执行完成 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"-----分割线-----\"); final SleepTest test2 = new SleepTest(); for(int i = 0;i&lt;3;i++)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; test2.waitMethod(); &#125; &#125;).start(); &#125; &#125;&#125; 执行结果： 12345678910111213Sleep start-----Sleep end-----Sleep start-----Sleep end-----Sleep start-----Sleep end----------分割线-----Wait start-----Wait start-----Wait start-----Wait end-----Wait end-----Wait end----- 这个结果的区别很明显，通过sleep方法实现的暂停，程序是顺序进入同步块的，只有当上一个线程执行完成的时候，下一个线程才能进入同步方法，sleep暂停期间一直持有monitor对象锁，其他线程是不能进入的。而wait方法则不同，当调用wait方法后，当前线程会释放持有的monitor对象锁，因此，其他线程还可以进入到同步方法，线程被唤醒后，需要竞争锁，获取到锁之后再继续执行。 2、yield方法yield方法的作用是暂停当前线程，以便其他线程有机会执行，不过不能指定暂停的时间，并且也不能保证当前线程马上停止。yield方法只是将Running状态转变为Runnable状态。我们还是通过一个例子来演示其使用： 1234567891011121314151617181920212223242526package com.paddx.test.concurrent;public class YieldTest implements Runnable &#123; @Override public void run() &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; for(int i=0;i&lt;5;i++)&#123; System.out.println(Thread.currentThread().getName() + \": \" + i); Thread.yield(); &#125; &#125; public static void main(String[] args) &#123; YieldTest runn = new YieldTest(); Thread t1 = new Thread(runn,\"FirstThread\"); Thread t2 = new Thread(runn,\"SecondThread\"); t1.start(); t2.start(); &#125;&#125; 运行结果如下： 12345678910FirstThread: 0SecondThread: 0FirstThread: 1SecondThread: 1FirstThread: 2SecondThread: 2FirstThread: 3SecondThread: 3FirstThread: 4SecondThread: 4 这个例子就是通过yield方法来实现两个线程的交替执行。不过请注意：这种交替并不一定能得到保证，源码中也对这个问题进行说明： 1234567891011121314151617&#x2F;** * A hint to the scheduler that the current thread is willing to yield * its current use of a processor. The scheduler is free to ignore this * hint. * * &lt;p&gt; Yield is a heuristic attempt to improve relative progression * between threads that would otherwise over-utilise a CPU. Its use * should be combined with detailed profiling and benchmarking to * ensure that it actually has the desired effect. * * &lt;p&gt; It is rarely appropriate to use this method. It may be useful * for debugging or testing purposes, where it may help to reproduce * bugs due to race conditions. It may also be useful when designing * concurrency control constructs such as the ones in the * &#123;@link java.util.concurrent.locks&#125; package.*&#x2F; 这段话主要说明了三个问题： 调度器可能会忽略该方法。 使用的时候要仔细分析和测试，确保能达到预期的效果。 很少有场景要用到该方法，主要使用的地方是调试和测试。 ​ 3、join方法 void join() Waits for this thread to die. void join(long millis) Waits at most millis milliseconds for this thread to die. void join(long millis, int nanos) Waits at most millis milliseconds plus nanos nanoseconds for this thread to die. join方法的作用是父线程等待子线程执行完成后再执行，换句话说就是将异步执行的线程合并为同步的线程。JDK中提供三个版本的join方法，其实现与wait方法类似，join()方法实际上执行的join(0)，而join(long millis, int nanos)也与wait(long millis, int nanos)的实现方式一致，暂时对纳秒的支持也是不完整的。我们可以看下join方法的源码，这样更容易理解： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public final void join() throws InterruptedException &#123; join(0); &#125; public final synchronized void join(long millis) throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException(\"timeout value is negative\"); &#125; if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; else &#123; while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125; &#125;public final synchronized void join(long millis, int nanos) throws InterruptedException &#123; if (millis &lt; 0) &#123; throw new IllegalArgumentException(\"timeout value is negative\"); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( \"nanosecond timeout value out of range\"); &#125; if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; millis == 0)) &#123; millis++; &#125; join(millis); &#125; 大家重点关注一下join(long millis)方法的实现，可以看出join方法就是通过wait方法来将线程的阻塞，如果join的线程还在执行，则将当前线程阻塞起来，直到join的线程执行完成，当前线程才能执行。不过有一点需要注意，这里的join只调用了wait方法，却没有对应的notify方法，原因是Thread的start方法中做了相应的处理，所以当join的线程执行完成以后，会自动唤醒主线程继续往下执行。下面我们通过一个例子来演示join方法的作用： （1）不使用join方法： 123456789101112131415161718192021222324package com.paddx.test.concurrent;public class JoinTest implements Runnable&#123; @Override public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName() + \" start-----\"); Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + \" end------\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; for (int i=0;i&lt;5;i++) &#123; Thread test = new Thread(new JoinTest()); test.start(); &#125; System.out.println(\"Finished~~~\"); &#125;&#125; 执行结果如下： 1234567891011Thread-0 start-----Thread-1 start-----Thread-2 start-----Thread-3 start-----Finished~~~Thread-4 start-----Thread-2 end------Thread-4 end------Thread-1 end------Thread-0 end------Thread-3 end------ （2）使用join方法： 1234567891011121314151617181920212223242526272829package com.paddx.test.concurrent;public class JoinTest implements Runnable&#123; @Override public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName() + \" start-----\"); Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + \" end------\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; for (int i=0;i&lt;5;i++) &#123; Thread test = new Thread(new JoinTest()); test.start(); try &#123; test.join(); //调用join方法 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"Finished~~~\"); &#125;&#125; 执行结果如下： 1234567891011Thread-0 start-----Thread-0 end------Thread-1 start-----Thread-1 end------Thread-2 start-----Thread-2 end------Thread-3 start-----Thread-3 end------Thread-4 start-----Thread-4 end------Finished~~~ 对比两段代码的执行结果很容易发现，在没有使用join方法之间，线程是并发执行的，而使用join方法后，所有线程是顺序执行的。 四、总结本文主要详细讲解了wait/notify/notifyAll和sleep/yield/join方法。最后回答一下上面提出的问题：wait/notify/notifyAll方法的作用是实现线程间的协作，那为什么这三个方法不是位于Thread类中，而是位于Object类中？位于Object中，也就相当于所有类都包含这三个方法（因为Java中所有的类都继承自Object类）。要回答这个问题，还是得回过来看wait方法的实现原理，大家需要明白的是，wait等待的到底是什么东西？如果对上面内容理解的比较好的话，我相信大家应该很容易知道wait等待其实是对象monitor，由于Java中的每一个对象都有一个内置的monitor对象，自然所有的类都理应有wait/notify方法。","tags":[{"name":"java","slug":"java","permalink":"https://sunshine-zwq.github.io/tags/java/"},{"name":"并发编程","slug":"并发编程","permalink":"https://sunshine-zwq.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"[转载]Java并发编程：Synchronized及其实现原理","date":"2020-12-01T16:01:00.000Z","path":"2020/12/02/[转载]Java并发编程：Synchronized及其实现原理/","text":"原文链接https://www.cnblogs.com/paddix/p/5367116.html作者：liuxiaopeng博客地址：http://www.cnblogs.com/paddix/ 一、Synchronized的基本使用Synchronized是Java中解决并发问题的一种最常用的方法，也是最简单的一种方法。Synchronized的作用主要有三个：（1）确保线程互斥的访问同步代码（2）保证共享变量的修改能够及时可见（3）有效解决重排序问题。从语法上讲，Synchronized总共有三种用法： （1）修饰普通方法 （2）修饰静态方法 （3）修饰代码块 接下来我就通过几个例子程序来说明一下这三种使用方式（为了便于比较，三段代码除了Synchronized的使用方式不同以外，其他基本保持一致）。 1、没有同步的情况： 代码段一： 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.paddx.test.concurrent;public class SynchronizedTest &#123; public void method1()&#123; System.out.println(\"Method 1 start\"); try &#123; System.out.println(\"Method 1 execute\"); Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"Method 1 end\"); &#125; public void method2()&#123; System.out.println(\"Method 2 start\"); try &#123; System.out.println(\"Method 2 execute\"); Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"Method 2 end\"); &#125; public static void main(String[] args) &#123; final SynchronizedTest test = new SynchronizedTest(); new Thread(new Runnable() &#123; @Override public void run() &#123; test.method1(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; test.method2(); &#125; &#125;).start(); &#125;&#125; 执行结果如下，线程1和线程2同时进入执行状态，线程2执行速度比线程1快，所以线程2先执行完成，这个过程中线程1和线程2是同时执行的。 123456Method 1 startMethod 1 executeMethod 2 startMethod 2 executeMethod 2 endMethod 1 end 2、对普通方法同步： 代码段二： 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.paddx.test.concurrent;public class SynchronizedTest &#123; public synchronized void method1()&#123; System.out.println(\"Method 1 start\"); try &#123; System.out.println(\"Method 1 execute\"); Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"Method 1 end\"); &#125; public synchronized void method2()&#123; System.out.println(\"Method 2 start\"); try &#123; System.out.println(\"Method 2 execute\"); Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"Method 2 end\"); &#125; public static void main(String[] args) &#123; final SynchronizedTest test = new SynchronizedTest(); new Thread(new Runnable() &#123; @Override public void run() &#123; test.method1(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; test.method2(); &#125; &#125;).start(); &#125;&#125; 执行结果如下，跟代码段一比较，可以很明显的看出，线程2需要等待线程1的method1执行完成才能开始执行method2方法。 123456Method 1 startMethod 1 executeMethod 1 endMethod 2 startMethod 2 executeMethod 2 end 3、静态方法（类）同步 代码段三： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.paddx.test.concurrent; public class SynchronizedTest &#123; public static synchronized void method1()&#123; System.out.println(\"Method 1 start\"); try &#123; System.out.println(\"Method 1 execute\"); Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"Method 1 end\"); &#125; public static synchronized void method2()&#123; System.out.println(\"Method 2 start\"); try &#123; System.out.println(\"Method 2 execute\"); Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"Method 2 end\"); &#125; public static void main(String[] args) &#123; final SynchronizedTest test = new SynchronizedTest(); final SynchronizedTest test2 = new SynchronizedTest(); new Thread(new Runnable() &#123; @Override public void run() &#123; test.method1(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; test2.method2(); &#125; &#125;).start(); &#125; &#125; 执行结果如下，对静态方法的同步本质上是对类的同步（静态方法本质上是属于类的方法，而不是对象上的方法），所以即使test和test2属于不同的对象，但是它们都属于SynchronizedTest类的实例，所以也只能顺序的执行method1和method2，不能并发执行。 123456Method 1 startMethod 1 executeMethod 1 endMethod 2 startMethod 2 executeMethod 2 end 4、代码块同步 代码段四： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.paddx.test.concurrent;public class SynchronizedTest &#123; public void method1()&#123; System.out.println(\"Method 1 start\"); try &#123; synchronized (this) &#123; System.out.println(\"Method 1 execute\"); Thread.sleep(3000); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"Method 1 end\"); &#125; public void method2()&#123; System.out.println(\"Method 2 start\"); try &#123; synchronized (this) &#123; System.out.println(\"Method 2 execute\"); Thread.sleep(1000); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"Method 2 end\"); &#125; public static void main(String[] args) &#123; final SynchronizedTest test = new SynchronizedTest(); new Thread(new Runnable() &#123; @Override public void run() &#123; test.method1(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; test.method2(); &#125; &#125;).start(); &#125;&#125; 执行结果如下，虽然线程1和线程2都进入了对应的方法开始执行，但是线程2在进入同步块之前，需要等待线程1中同步块执行完成。 123456Method 1 startMethod 1 executeMethod 2 startMethod 1 endMethod 2 executeMethod 2 end 二、Synchronized原理如果对上面的执行结果还有疑问，也先不用急，我们先来了解Synchronized的原理，再回头上面的问题就一目了然了。我们先通过反编译下面的代码来看看Synchronized是如何实现对代码块进行同步的： 123456789package com.paddx.test.concurrent;public class SynchronizedDemo &#123; public void method() &#123; synchronized (this) &#123; System.out.println(\"Method 1 start\"); &#125; &#125;&#125; 反编译结果： 关于这两条指令的作用，我们直接参考JVM规范中描述： monitorenter ： 1234Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:• If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.• If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.• If another thread already owns the monitor associated with objectref, the thread blocks until the monitor&#39;s entry count is zero, then tries again to gain ownership. 这段话的大概意思为： 每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下： 1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。 2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1. 3、如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。 monitorexit： 12The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so. 这段话的大概意思为： 执行monitorexit的线程必须是objectref所对应的monitor的所有者。 指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。 通过这两段描述，我们应该能很清楚的看出Synchronized的实现原理，Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。 我们再来看一下同步方法的反编译结果： 源代码： 1234567package com.paddx.test.concurrent;public class SynchronizedMethod &#123; public synchronized void method() &#123; System.out.println(&quot;Hello World!&quot;); &#125;&#125; 反编译结果： 从反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。 三、运行结果解释有了对Synchronized原理的认识，再来看上面的程序就可以迎刃而解了。 1、代码段2结果： 虽然method1和method2是不同的方法，但是这两个方法都进行了同步，并且是通过同一个对象去调用的，所以调用之前都需要先去竞争同一个对象上的锁（monitor），也就只能互斥的获取到锁，因此，method1和method2只能顺序的执行。 2、代码段3结果： 虽然test和test2属于不同对象，但是test和test2属于同一个类的不同实例，由于method1和method2都属于静态同步方法，所以调用的时候需要获取同一个类上monitor（每个类只对应一个class对象），所以也只能顺序的执行。 3、代码段4结果： 对于代码块的同步实质上需要获取Synchronized关键字后面括号中对象的monitor，由于这段代码中括号的内容都是this，而method1和method2又是通过同一的对象去调用的，所以进入同步块之前需要去竞争同一个对象上的锁，因此只能顺序执行同步块。 四、总结Synchronized是Java并发编程中最常用的用于保证线程安全的方式，其使用相对也比较简单。但是如果能够深入了解其原理，对监视器锁等底层知识有所了解，一方面可以帮助我们正确的使用Synchronized关键字，另一方面也能够帮助我们更好的理解并发编程机制，有助我们在不同的情况下选择更优的并发策略来完成任务。对平时遇到的各种并发问题，也能够从容的应对。","tags":[{"name":"java","slug":"java","permalink":"https://sunshine-zwq.github.io/tags/java/"},{"name":"并发编程","slug":"并发编程","permalink":"https://sunshine-zwq.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"[转载]Java并发编程：核心理论","date":"2020-12-01T16:00:00.000Z","path":"2020/12/02/[转载]Java并发编程：核心理论/","text":"并发编程是Java程序员最重要的技能之一，也是最难掌握的一种技能。它要求编程者对计算机最底层的运作原理有深刻的理解，同时要求编程者逻辑清晰、思维缜密，这样才能写出高效、安全、可靠的多线程并发程序。本系列会从线程间协调的方式（wait、notify、notifyAll）、Synchronized及Volatile的本质入手，详细解释JDK为我们提供的每种并发工具和底层实现机制。在此基础上，我们会进一步分析java.util.concurrent包的工具类，包括其使用方式、实现源码及其背后的原理。本文是该系列的第一篇文章，是这系列中最核心的理论部分，之后的文章都会以此为基础来分析和解释。 原文链接https://www.cnblogs.com/paddix/p/5374810.html作者：liuxiaopeng博客地址：http://www.cnblogs.com/paddix/ 一、共享性数据共享性是线程安全的主要原因之一。如果所有的数据只是在线程内有效，那就不存在线程安全性问题，这也是我们在编程的时候经常不需要考虑线程安全的主要原因之一。但是，在多线程编程中，数据共享是不可避免的。最典型的场景是数据库中的数据，为了保证数据的一致性，我们通常需要共享同一个数据库中数据，即使是在主从的情况下，访问的也同一份数据，主从只是为了访问的效率和数据安全，而对同一份数据做的副本。我们现在，通过一个简单的示例来演示多线程下共享数据导致的问题： 代码段一： 1234567891011121314151617181920212223242526272829303132333435363738package com.paddx.test.concurrent; public class ShareData &#123; public static int count = 0; public static void main(String[] args) &#123; final ShareData data = new ShareData(); for (int i = 0; i &lt; 10; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; //进入的时候暂停1毫秒，增加并发问题出现的几率 Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; for (int j = 0; j &lt; 100; j++) &#123; data.addCount(); &#125; System.out.print(count + \" \"); &#125; &#125;).start(); &#125; try &#123; //主程序暂停3秒，以保证上面的程序执行完成 Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"count=\" + count); &#125; public void addCount() &#123; count++; &#125;&#125; 上述代码的目的是对count进行加一操作，执行1000次，不过这里是通过10个线程来实现的，每个线程执行100次，正常情况下，应该输出1000。不过，如果你运行上面的程序，你会发现结果却不是这样。下面是某次的执行结果（每次运行的结果不一定相同，有时候也可能获取到正确的结果）： 可以看出，对共享变量操作，在多线程环境下很容易出现各种意想不到的的结果。 二、互斥性资源互斥是指同时只允许一个访问者对其进行访问，具有唯一性和排它性。我们通常允许多个线程同时对数据进行读操作，但同一时间内只允许一个线程对数据进行写操作。所以我们通常将锁分为共享锁和排它锁，也叫做读锁和写锁。如果资源不具有互斥性，即使是共享资源，我们也不需要担心线程安全。例如，对于不可变的数据共享，所有线程都只能对其进行读操作，所以不用考虑线程安全问题。但是对共享数据的写操作，一般就需要保证互斥性，上述例子中就是因为没有保证互斥性才导致数据的修改产生问题。 Java中提供多种机制来保证互斥性，最简单的方式是使用Synchronized。现在我们在上面程序中加上Synchronized再执行： 代码段二： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.paddx.test.concurrent; public class ShareData &#123; public static int count = 0; public static void main(String[] args) &#123; final ShareData data = new ShareData(); for (int i = 0; i &lt; 10; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; //进入的时候暂停1毫秒，增加并发问题出现的几率 Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; for (int j = 0; j &lt; 100; j++) &#123; data.addCount(); &#125; System.out.print(count + \" \"); &#125; &#125;).start(); &#125; try &#123; //主程序暂停3秒，以保证上面的程序执行完成 Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"count=\" + count); &#125; /** * 增加 synchronized 关键字 */ public synchronized void addCount() &#123; count++; &#125;&#125; 现在再执行上述代码，会发现无论执行多少次，返回的最终结果都是1000。 三、原子性原子性就是指对数据的操作是一个独立的、不可分割的整体。换句话说，就是一次操作，是一个连续不可中断的过程，数据不会执行的一半的时候被其他线程所修改。保证原子性的最简单方式是操作系统指令，就是说如果一次操作对应一条操作系统指令，这样肯定可以能保证原子性。但是很多操作不能通过一条指令就完成。例如，对long类型的运算，很多系统就需要分成多条指令分别对高位和低位进行操作才能完成。还比如，我们经常使用的整数 i++ 的操作，其实需要分成三个步骤：（1）读取整数 i 的值；（2）对 i 进行加一操作；（3）将结果写回内存。这个过程在多线程下就可能出现如下现象： 这也是代码段一执行的结果为什么不正确的原因。对于这种组合操作，要保证原子性，最常见的方式是加锁，如Java中的Synchronized或Lock都可以实现，代码段二就是通过Synchronized实现的。除了锁以外，还有一种方式就是CAS（Compare And Swap），即修改数据之前先比较与之前读取到的值是否一致，如果一致，则进行修改，如果不一致则重新执行，这也是乐观锁的实现原理。不过CAS在某些场景下不一定有效，比如另一线程先修改了某个值，然后再改回原来值，这种情况下，CAS是无法判断的。 四、可见性要理解可见性，需要先对JVM的内存模型有一定的了解，JVM的内存模型与操作系统类似，如图所示： 从这个图中我们可以看出，每个线程都有一个自己的工作内存（相当于CPU高级缓冲区，这么做的目的还是在于进一步缩小存储系统与CPU之间速度的差异，提高性能），对于共享变量，线程每次读取的是工作内存中共享变量的副本，写入的时候也直接修改工作内存中副本的值，然后在某个时间点上再将工作内存与主内存中的值进行同步。这样导致的问题是，如果线程1对某个变量进行了修改，线程2却有可能看不到线程1对共享变量所做的修改。通过下面这段程序我们可以演示一下不可见的问题： 12345678910111213141516171819202122232425262728293031323334353637package com.paddx.test.concurrent; public class VisibilityTest &#123; private static boolean ready; private static int number; private static class ReaderThread extends Thread &#123; public void run() &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (!ready) &#123; System.out.println(ready); &#125; System.out.println(number); &#125; &#125; private static class WriterThread extends Thread &#123; public void run() &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; number = 100; ready = true; &#125; &#125; public static void main(String[] args) &#123; new WriterThread().start(); new ReaderThread().start(); &#125;&#125; 从直观上理解，这段程序应该只会输出100，ready的值是不会打印出来的。实际上，如果多次执行上面代码的话，可能会出现多种不同的结果，下面是我运行出来的某两次的结果： 当然，这个结果也只能说是有可能是可见性造成的，当写线程（WriterThread）设置ready=true后，读线程（ReaderThread）看不到修改后的结果，所以会打印false，对于第二个结果，也就是执行if(!ready)时还没有读取到写线程的结果，但执行System.out.println(ready)时读取到了写线程执行的结果。不过，这个结果也有可能是线程的交替执行所造成的。Java中可通过Synchronized或Volatile来保证可见性，具体细节会在后续的文章中分析。 五、有序性为了提高性能，编译器和处理器可能会对指令做重排序。重排序可以分为三种： （1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 （2）指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。（3）内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。 我们可以直接参考一下JSR 133 中对重排序问题的描述： （1） （2） 先看上图中的（1）源码部分，从源码来看，要么指令 1 先执行要么指令 3先执行。如果指令 1 先执行，r2不应该能看到指令 4 中写入的值。如果指令 3 先执行，r1不应该能看到指令 2 写的值。但是运行结果却可能出现r2==2，r1==1的情况，这就是“重排序”导致的结果。上图（2）即是一种可能出现的合法的编译结果，编译后，指令1和指令2的顺序可能就互换了。因此，才会出现r2==2，r1==1的结果。Java中也可通过Synchronized或Volatile来保证顺序性。 六、总结本文对Java 并发编程中的理论基础进行了讲解，有些东西在后续的分析中还会做更详细的讨论，如可见性、顺序性等。后续的文章都会以本章内容作为理论基础来讨论。如果大家能够很好的理解上述内容，相信无论是去理解其他并发编程的文章还是在平时的并发编程的工作中，都能够对大家有很好的帮助。","tags":[{"name":"java","slug":"java","permalink":"https://sunshine-zwq.github.io/tags/java/"},{"name":"并发编程","slug":"并发编程","permalink":"https://sunshine-zwq.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"element-ui的Tree树形控件触发指定节点点击处理","date":"2020-11-30T16:00:00.000Z","path":"2020/12/01/element-ui的Tree树形控件触发指定节点点击处理/","text":"项目需求有个多路搜索框（从服务器搜索），可支持同时根据关键字搜索科室和医生，页面左侧是科室树，右侧是医生列表表格，当选择关键字搜索结果的某个科室（可获取到科室id），需要触发选中左侧的科室节点，并查询出相应的科室所有医生信息。所以这个不适合直接采用element-ui的节点过滤搜索框来过滤节点，而element-ui也没有直接根据tree节点值触发节点点击的事件，所以需要额外写代码来实现这个交互效果。 效果图 主要实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;template&gt; &lt;el-select class=\"searchInput\" v-model=\"selectedSearchItem\" filterable remote reserve-keyword size=\"mini\" placeholder=\"搜索成员或科室\" :remote-method=\"queryDeptOrDoctor\" @change=\"selectSearchItem\" :loading=\"searchLoading\"&gt; &lt;el-option-group v-for=\"group in searchOptionGroups\" :key=\"group.name\" :label=\"group.name\"&gt; &lt;el-option v-for=\"item in group.options\" :key=\"item.id\" :label=\"item.name\" :value=\"item.id\"&gt; &lt;/el-option&gt; &lt;/el-option-group&gt; &lt;/el-select&gt; &lt;el-tree class=\"deptTreeCntr\" ref=\"deptTree\" :data=\"treeData\" :props=\"treeProps\" node-key=\"id\" :default-expanded-keys=\"['0']\" :expand-on-click-node=\"false\" @node-click=\"handleTreeNodeClick\"&gt; &lt;/el-tree&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; selectedSearchItem: '', searchLoading: false, searchOptionGroups: [], treeData: [], treeProps: &#123; value: 'id', children: 'children', label: 'title' &#125;, &#125; &#125;, methods: &#123; // 根据关键字搜索科室或医生 queryDeptOrDoctor(keyword)&#123; this.searchOptionGroups = []; if(keyword == '')&#123; return; &#125; this.searchLoading = true; // 发起服务器查询，并组装this.searchOptionGroups数据 // ... this.searchLoading = false; &#125;, // 多路搜索框选择了搜索的item处理 selectSearchItem(selectedVal)&#123; // selectedVal的前缀用于区分是科室还是医生，科室是“dept-”开头，医生是“doct-”开头 let type = selectedVal.substring(0, 4); // 截取实际的科室id或者医生id let val = selectedVal.substring(5); if(type == 'dept') &#123;// 科室 // 设置当前选中key this.$refs.deptTree.setCurrentKey(val); // 根据el-tree的getNode方法获取到val相应的Node let node = this.$refs.deptTree.getNode(val); // 触发点击处理（由于elem参数没用到，所以这里忽略不传） this.handleTreeNodeClick(node.data, node); // 除了选中相应的科室节点及触发查询，还有件事要做：就是有可能这个节点处于树比较深的位置，那应该把这个节点的所有父节点都展开（默认不展开） // 获取自身及所有父节点的id let selfAndParentIdArr = this.findTreeParentDataAttr(node, 'id'); if(selfAndParentIdArr.length &gt; 1)&#123; // 这里只展开所有父节点，当前节点不处理 for(let i = 0; i &lt; selfAndParentIdArr.length - 1; i++)&#123; // 这里通过设置节点数据的expanded属性来展开指定节点 this.$refs.deptTree.store.nodesMap[selfAndParentIdArr[i]].expanded = true; &#125; &#125; &#125;else if(type == 'doct') &#123;// 医生 // 触发查询指定医生的处理... &#125; &#125;, // 点击树节点事件处理 handleTreeNodeClick(data, node, elem)&#123; // data.id即为科室id，根据这个科室id触发医生表格数据的查询... &#125;, // 递归找出选择科室及所有上级科室的data指定属性（如title、id） findTreeParentDataAttr(node, attrName, parentNameArr)&#123; if(!parentNameArr)&#123; parentNameArr = []; &#125; // 因为是一层一层往上找，这里把父节点放最前面 parentNameArr.unshift(node.data[attrName]); if(node.data.id == '0')&#123;// 根节点 &#125;else&#123; this.findTreeParentDataAttr(node.parent, attrName, parentNameArr); &#125; // 返回找到的所有节点名称 return parentNameArr; &#125; &#125; &#125;&lt;/script&gt; 一些属性、方法说明el-tree： data =》 tree的展示数据，类型：array，需要在后端封装好 props =》 配置选项，类型：object。这个主要用于匹配tree相应节点属性和后端返回数据的属性 label：指定节点标签（即显示的节点文本）为节点对象的某个属性值 children：指定子树为节点对象的某个属性值 node-key =》 每个树节点用来作为唯一标识的属性，整棵树应该是唯一的 default-expanded-keys =》 默认展开的节点的 key 的数组，由于科室树都有个默认的根节点id为0，所以这里会默认展开根节点下的一级节点 expand-on-click-node =》 是否在点击节点的时候展开或者收缩节点， 默认值为 true，如果为 false，则只有点箭头图标的时候才会展开或者收缩节点。 node-click =》 节点被点击时的回调。共三个参数，依次为：传递给 data 属性的数组中该节点所对应的对象、节点对应的 Node、节点组件本身。 setCurrentKey =》 通过 key 设置某个节点的当前选中状态，使用此方法必须设置 node-key 属性 getNode =》 根据 data 或者 key 拿到 Tree 组件中的 node","tags":[{"name":"vue","slug":"vue","permalink":"https://sunshine-zwq.github.io/tags/vue/"},{"name":"element-ui","slug":"element-ui","permalink":"https://sunshine-zwq.github.io/tags/element-ui/"}]},{"title":"正则表达式","date":"2020-11-24T16:00:00.000Z","path":"2020/11/25/正则表达式/","text":"简介 正则表达式，用来匹配一系列符合某个规则的字符串的表达式。正则的意思是正规、规则。正则表达式的英文名是 Regular Expression，可以直译为描述某种规则的表达式，一般缩写为 regex。 语法正则表达式的便利之处示例（校验手机号码）： 未使用正则表达式的代码： 123456789public static boolean isValidPhoneNumber(String number) &#123; // 判断是否是 11 位 if (number.length() != 11) return false; // 判断每一位是否全为数字 for (int i = 0; i &lt; number.length(); i++) &#123; if (number.charAt(i) &lt; '0' || number.charAt(i) &gt; '9') return false; &#125; return true;&#125; 使用正则表达式的代码： 123public static boolean isValidPhoneNumber(String number) &#123; return number.matches(\"\\\\d&#123;11&#125;\");&#125; 精确匹配 一个普通的字符串，比如 abc，它如果用来做正则表达式匹配的话，只能匹配自己。也就是说它只能匹配字符串 abc，不能匹配 ab，Abc 等其他任何字符串。 示例代码： 123System.out.println(\"abc\".matches(\"abc\")); // 输出为 trueSystem.out.println(\"ab\".matches(\"abc\")); // 输出为 falseSystem.out.println(\"Abc\".matches(\"abc\")); // 输出为 false 特殊字符 如果需要匹配的字符串含有特殊字符，那就需要用 \\转义。比如 a&amp;b，在用正则表达式匹配时，需要使用 a\\&amp;b，又由于在 Java 字符串中，\\ 也是特殊字符，它也需要转义，所以 a\\&amp;b 对应的 Java 字符串是 a\\\\&amp;b，它是用来匹配 a&amp;b 的。 示例代码： 1System.out.println(\"a&amp;b\".matches(\"a\\\\&amp;b\")); // 输出为 true 数字、字符、空格 \\d：d 是 digital 的简写，在正则表达式中表示匹配任意数字。 \\w：w 是 word 的简写，表示匹配一个常用字符，包括字母、数字、下划线。 \\s：s 是 space 的简写，表示匹配一个空格，包括三种：空格键打出来的空格、Tab 键打出来的空格、回车键打出来的空格 示例代码： 1234567System.out.println(\"1\".matches(\"\\\\d\\\\d\")); // 输出为 falseSystem.out.println(\"11\".matches(\"\\\\d\\\\d\")); // 输出为 trueSystem.out.println(\"111\".matches(\"\\\\d\\\\d\")); // 输出为 falseSystem.out.println(\"LeetCode_666\".matches(\"\\\\w&#123;12&#125;\")); // 输出为 trueSystem.out.println(\"\\t \\n\".matches(\"\\\\s&#123;3&#125;\")); // 输出为 trueSystem.out.println(\"Leet\\tCode 666\".matches(\"\\\\w&#123;4&#125;\\\\s\\\\w&#123;4&#125;\\\\s\\\\d&#123;3&#125;\")); // 输出为 true 相反 将字母换成大写，就表示相反的意思。用 \\d 你可以匹配一个数字，\\D 则表示匹配一个非数字。 示例代码： 12345System.out.println(\"a\".matches(\"\\\\d\")); // 输出为 falseSystem.out.println(\"1\".matches(\"\\\\d\")); // 输出为 trueSystem.out.println(\"a\".matches(\"\\\\D\")); // 输出为 trueSystem.out.println(\"1\".matches(\"\\\\D\")); // 输出为 false 匹配次数 . ：匹配任意字符； * ：匹配任意次，包括 0 次； + ：匹配至少 1 次； ? ：匹配 0 次或 1 次； {}：指定次数，{n} 表示匹配 n 次， {n,m} 表示匹配 n ~ m 次，{n,} 表示匹配至少n次，{0,m} 表示匹配最多m次 示例代码： 1234567891011121314151617181920System.out.println(\"a0b\".matches(\"a.b\")); // 输出为 trueSystem.out.println(\"a_b\".matches(\"a.b\")); // 输出为 trueSystem.out.println(\"a b\".matches(\"a.b\")); // 输出为 trueSystem.out.println(\"1\".matches(\"\\\\d*\")); // 输出为 trueSystem.out.println(\"123\".matches(\"\\\\d*\")); // 输出为 trueSystem.out.println(\"\".matches(\"\\\\d*\")); // 输出为 trueSystem.out.println(\"1\".matches(\"\\\\d+\")); // 输出为 trueSystem.out.println(\"123\".matches(\"\\\\d+\")); // 输出为 trueSystem.out.println(\"\".matches(\"\\\\d+\")); // 输出为 falseSystem.out.println(\"\".matches(\"\\\\d?\")); // 输出为 trueSystem.out.println(\"1\".matches(\"\\\\d?\")); // 输出为 trueSystem.out.println(\"123\".matches(\"\\\\d?\")); // 输出为 falseSystem.out.println(\"1\".matches(\"\\\\d&#123;1,2&#125;\")); // 输出为 trueSystem.out.println(\"12\".matches(\"\\\\d&#123;1,2&#125;\")); // 输出为 trueSystem.out.println(\"123\".matches(\"\\\\d&#123;1,2&#125;\")); // 输出为 falseSystem.out.println(\"123\".matches(\"\\\\d&#123;2,&#125;\")); // 输出为 true 指定范围 [] 用于匹配指定范围内的字符，比如[123456789] 可以匹配 19，也可以写作 [1-9]。[a-g] 表示 [abcdefg]，[U-Z] 表示 [UVWXYZ]。[1-9a-gU-Z] 表示既可以是数字 19，又可以是字母 ag，还可以是字母 UZ。 或 运算符：正则的 或 运算符是 |，[0189] 也可以写作 0|1|8|9。 [] 取反的方式是：[^]，比如不能是 [123] 的表示方法为 [^123] 或者 [^1-3] 示例代码： 1234567891011121314System.out.println(\"1\".matches(\"[1-9a-gU-Z]\")); // 输出为 trueSystem.out.println(\"b\".matches(\"[1-9a-gU-Z]\")); // 输出为 trueSystem.out.println(\"X\".matches(\"[1-9a-gU-Z]\")); // 输出为 trueSystem.out.println(\"A\".matches(\"[1-9a-gU-Z]\")); // 输出为 falseSystem.out.println(\"1\".matches(\"[0-18-9]\")); // 输出为 true，由于正则一次只匹配一个字符，所以这样写并不会有歧义，也就是说计算机不会把这种写法误解成要匹配 0~18 之类的。System.out.println(\"5\".matches(\"[0-18-9]\")); // 输出为 falseSystem.out.println(\"1\".matches(\"0|1|8|9\")); // 输出为 trueSystem.out.println(\"5\".matches(\"0|1|8|9\")); // 输出为 falseSystem.out.println(\"abc\".matches(\"abc|ABC\")); // 输出为 trueSystem.out.println(\"ABC\".matches(\"abc|ABC\")); // 输出为 trueSystem.out.println(\"123\".matches(\"abc|ABC\")); // 输出为 false 匹配取值考虑一个实际需求，有许许多多以下格式的字符串，你需要用正则表达式匹配出其姓名和年龄。 Name：Aurora Age：18 其中还夹杂着一些无关紧要的数据 Name：Bob Age：20 错误的数据有着各种各样错误的格式 Name：Cassin Age：22 … 示例代码： 12345System.out.println(\"Name:Aurora Age:18\".matches(\"Name:\\\\w+\\\\s*Age:\\\\d&#123;1,3&#125;\")); // 输出为 trueSystem.out.println(\"其中还夹杂着一些无关紧要的数据\".matches(\"Name:\\\\w+\\\\s*Age:\\\\d&#123;1,3&#125;\")); // 输出为 falseSystem.out.println(\"Name:Bob Age:20\".matches(\"Name:\\\\w+\\\\s*Age:\\\\d&#123;1,3&#125;\")); // 输出为 trueSystem.out.println(\"错误的数据有着各种各样错误的格式\".matches(\"Name:\\\\w+\\\\s*Age:\\\\d&#123;1,3&#125;\")); // 输出为 falseSystem.out.println(\"Name:Cassin Age:22\".matches(\"Name:\\\\w+\\\\s*Age:\\\\d&#123;1,3&#125;\")); // 输出为 true 下一步，取出这些表达式中的姓名和年龄。 示例代码： 12345678910Pattern pattern = Pattern.compile(\"Name:(\\\\w+)\\\\s*Age:(\\\\d&#123;1,3&#125;)\");Matcher matcher = pattern.matcher(\"Name:Aurora Age:18\");if(matcher.matches()) &#123; // group(0) 被用来保存整个匹配的字符串了，所以从1开始 String group1 = matcher.group(1); String group2 = matcher.group(2); System.out.println(matcher.group(0)); // 输出为 Name:Aurora Age:18 System.out.println(group1); // 输出为 Aurora System.out.println(group2); // 输出为 18&#125; tips：每次调用 String.matches 函数，都会新建出一个 Pattern 对象。所以如果要用同一个正则表达式多次匹配字符串的话，最佳的做法不是直接调用 String.matches 方法，而应该先用正则表达式新建一个 Pattern 对象，然后反复使用，以提高程序运行效率。 示例代码： 12345678910111213// 错误的做法，每次都会新建一个 Pattern，效率低boolean result1 = \"Name:Aurora Age:18\".matches(\"Name:(\\\\w+)\\\\s*Age:(\\\\d&#123;1,3&#125;)\"); boolean result2 = \"Name:Bob Age:20\".matches(\"Name:(\\\\w+)\\\\s*Age:(\\\\d&#123;1,3&#125;)\");boolean result3 = \"Name:Cassin Age:22\".matches(\"Name:(\\\\w+)\\\\s*Age:(\\\\d&#123;1,3&#125;)\"); // 正确的做法，复用同一个 Pattern，效率高Pattern pattern = Pattern.compile(\"Name:(\\\\w+)\\\\s*Age:(\\\\d&#123;1,3&#125;)\");boolean result4 = pattern.matcher(\"Name:Aurora Age:18\").matches();boolean result5 = pattern.matcher(\"Name:Bob Age:20\").matches();boolean result6 = pattern.matcher(\"Name:Cassin Age:22\").matches(); 贪婪匹配和非贪婪匹配给出一些字符串，统计其末尾 e 的个数 LeetCode LeetCodeeee LeetCodeee 错误示例： 12345678Pattern pattern = Pattern.compile(\"(\\\\w+)(e*)\");Matcher matcher = pattern.matcher(\"LeetCode\");if (matcher.matches()) &#123; String group1 = matcher.group(1); String group2 = matcher.group(2); System.out.println(\"group1 = \" + group1 + \", length = \" + group1.length()); System.out.println(\"group2 = \" + group2 + \", length = \" + group2.length());&#125; 输出结果： 12group1 &#x3D; LeetCode, length &#x3D; 8group2 &#x3D; , length &#x3D; 0 这是因为 e 仍然属于 \\w 能匹配的范畴，正则表达式默认会尽可能多地向后匹配，这个称为 贪婪匹配。与之对应的匹配方式叫做 非贪婪匹配，非贪婪匹配 会在能匹配目标字符串的前提下，尽可能少的向后匹配。在需要非贪婪匹配的正则表达式后面加个 ? 即可表示非贪婪匹配。 正确示例： 12345678Pattern pattern = Pattern.compile(\"(\\\\w+?)(e*)\");Matcher matcher = pattern.matcher(\"LeetCode\");if (matcher.matches()) &#123; String group1 = matcher.group(1); String group2 = matcher.group(2); System.out.println(\"group1 = \" + group1 + \", length = \" + group1.length()); System.out.println(\"group2 = \" + group2 + \", length = \" + group2.length());&#125; 输出结果： 12group1 &#x3D; LeetCod, length &#x3D; 7group2 &#x3D; e, length &#x3D; 1 java中的一些应用split split 函数传入的参数实际上是一个正则表达式 一个实际场景：你有一个让用户输入标签的输入框，用户可以输入多个标签。可是你并没有提示用户，标签之前用什么间隔符号隔开。用户的输入五花八门，有用逗号的，有用分号的，有用空格的，还有用制表符的…… 二分，回溯，递归，分治 搜索；查找；旋转；遍历 数论 图论 逻辑 概率 示例代码（未使用正则表达式）： 123456789101112public static String[] splitTabs(String tabs) &#123; if(tabs.split(\",\").length == 4) return tabs.split(\",\"); if(tabs.split(\";\").length == 4) return tabs.split(\";\"); if(tabs.split(\" \").length == 4) return tabs.split(\" \"); return new String[0];&#125;public static void main(final String[] args)&#123; System.out.println(Arrays.toString(splitTabs(\"二分,回溯,递归,分治\"))); System.out.println(Arrays.toString(splitTabs(\"搜索;查找;旋转;遍历\"))); System.out.println(Arrays.toString(splitTabs(\"数论 图论 逻辑 概率\")));&#125; 输出为： 123[二分, 回溯, 递归, 分治][搜索, 查找, 旋转, 遍历][数论, 图论, 逻辑, 概率] 示例代码（使用正则表达式）： 123System.out.println(Arrays.toString(\"二分,回溯,递归,分治\".split(\"[,;\\\\s]\")));System.out.println(Arrays.toString(\"搜索;查找;旋转;遍历\".split(\"[,;\\\\s]\")));System.out.println(Arrays.toString(\"数论 图论 逻辑 概率\".split(\"[,;\\\\s]\"))); 输出为： 123[二分, 回溯, 递归, 分治][搜索, 查找, 旋转, 遍历][数论, 图论, 逻辑, 概率] replaceAll上面这个例子，我们可以把用户输入的所有数据统一规范为使用 ; 分隔，那我们就可以这样写。 示例代码： 123System.out.println(\"二分,回溯,递归,分治\".replaceAll(\"[,;\\\\s]+\", \";\"));System.out.println(\"搜索;查找;旋转;遍历\".replaceAll(\"[,;\\\\s]+\", \";\"));System.out.println(\"数论 图论 逻辑 概率\".replaceAll(\"[,;\\\\s]+\", \";\")); 输出为： 123二分;回溯;递归;分治搜索;查找;旋转;遍历数论;图论;逻辑;概率 在 replaceAll 的第二个参数中，我们可以通过 $1，$2，…来反向引用匹配到的子串。只要将需要引用的部分用 () 括起来就可以了。 示例代码： 123System.out.println(\"二分,回溯,递归,分治\".replaceAll(\"([,;\\\\s]+)\", \"---$1---\"));System.out.println(\"搜索;查找;旋转;遍历\".replaceAll(\"([,;\\\\s]+)\", \"---$1---\"));System.out.println(\"数论 图论 逻辑 概率\".replaceAll(\"([,;\\\\s]+)\", \"---$1---\")); 输出为： 123二分---,---回溯---,---递归---,---分治搜索---;---查找---;---旋转---;---遍历数论--- ---图论--- ---逻辑--- ---概率 参考链接https://mp.weixin.qq.com/s/zxQ-itkICaZlhevvwuBGsw","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://sunshine-zwq.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"常用js工具方法","date":"2020-11-23T16:00:00.000Z","path":"2020/11/24/常用js工具方法/","text":"比较通用的一些js工具方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644/********************日期时间相关-start********************//** * 获取指定天数后的日期 * @param addDays 指定天数，如果要获取过去时间则传负数值 * @param fillZero 是否给小于10的补零，默认否 * @returns 指定天数后的日期，格式为“2017-05-04” */function getDayAdd(addDays, fillZero)&#123; var date1 = new Date(); var date2 = new Date(date1); date2.setDate(date1.getDate() + addDays); var month = date2.getMonth() + 1; if(month &lt; 10 &amp;&amp; fillZero)&#123; month = \"0\" + month; &#125; var date = date2.getDate(); if(date &lt; 10 &amp;&amp; fillZero)&#123; date = \"0\" + date; &#125; var time = date2.getFullYear() + \"-\" + month + \"-\" + date; return time;&#125;/** * 获取当前日期 * @param type 格式，0（默认）表示“2017-05-04”，1表示“2017/05/04”，2表示“2017年05月04日” * @param fillZero 是否给小于10的补零，默认否 * @returns 当前日期 */function getTodayDate(type, fillZero)&#123; var date1 = new Date(); var month = date1.getMonth() + 1; if(month &lt; 10 &amp;&amp; fillZero)&#123; month = \"0\" + month; &#125; var date = date1.getDate(); if(date &lt; 10 &amp;&amp; fillZero)&#123; date = \"0\" + date; &#125; var time = date1.getFullYear() + \"-\" + month + \"-\" + date; if(type)&#123; if(type == 1)&#123; time = date1.getFullYear() + \"/\" + month + \"/\" + date; &#125;else if(type == 2)&#123; time = date1.getFullYear() + \"年\" + month + \"月\" + date + \"日\"; &#125; &#125; return time;&#125;/** * 获取指定月后的年月 * @param addMonths 指定月数，如果要获取过去时间则传负数值 * @returns 指定月数后的年月，格式为“2017-05” */function getMonthAdd(addMonths)&#123; var date1 = new Date(); var date2 = new Date(date1); date2.setMonth(date2.getMonth() + addMonths); var month = date2.getMonth() + 1; if(month &lt; 10)&#123; month = \"0\" + month; &#125; var time = date2.getFullYear() + \"-\" + month; return time;&#125;/** * 获取n个月后的日期，格式为yyyy-MM-dd * @param addMonths * @returns &#123;*&#125; */function getAfterMonths(addMonths)&#123; var date = new Date(); date.setMonth(date.getMonth() + addMonths); return dateFormat(date);&#125;/** * 获取当前年月 * @returns 当前年月，格式为“2017-05” */function getCurrMonth()&#123; var date1 = new Date(); var month = date1.getMonth() + 1; if(month &lt; 10)&#123; month = \"0\" + month; &#125; var time = date1.getFullYear() + \"-\" + month; return time;&#125;/** * 计算两个日期之间相差的天数 * @param startDate 开始日期，格式为2017-05-19 * @param endDate 结束日期，格式为2017-05-19 * @returns 相差天数 */function getDateDiff(startDate,endDate)&#123; var startTime = new Date(Date.parse(startDate.replace(/-/g, \"/\"))).getTime(); var endTime = new Date(Date.parse(endDate.replace(/-/g, \"/\"))).getTime(); var dates = Math.abs((startTime - endTime))/(1000*60*60*24); return dates;&#125;/** * 计算两个日期之间相差的月数 * @param startDate 开始日期，格式为2017-05-19 * @param endDate 结束日期，格式为2017-05-19 * @returns 相差月数 */function getMonthDiff(startDate,endDate)&#123; var year1 = startDate.split('-')[0]; var year2 = endDate.split('-')[0]; var month1 = startDate.split('-')[1]; var month2 = endDate.split('-')[1]; var len = (year2 - year1) * 12 + (month2 - month1); return len;&#125;/** * 获取指定日期是星期几 */function getWeekDate(date) &#123; var day = date.getDay(); var weeks = new Array(\"星期日\", \"星期一\", \"星期二\", \"星期三\", \"星期四\", \"星期五\", \"星期六\"); var week = weeks[day]; return week;&#125;/** * 获取当前星期几 */function getTodayWeekDate() &#123; var now = new Date(); return getWeekDate(now);&#125;/** * 获取当前时间 * @returns &#123;string&#125; */function getCurrTime()&#123; var date1 = new Date(); var hour = date1.getHours(); //获取系统时 var minute = date1.getMinutes(); //分 var second = date1.getSeconds(); //秒 if(hour &lt; 10)&#123; hour = \"0\" + hour; &#125; if(minute &lt; 10)&#123; minute = \"0\" + minute; &#125; if(second &lt; 10)&#123; second = \"0\" + second; &#125; var time = hour + \":\" + minute + \":\" + second; return time;&#125;/** * 获取当前时段的名称 * @returns &#123;string&#125; */function getTimePeriodText()&#123; // 获取当前时间 let timeNow = new Date(); // 获取当前小时 let hours = timeNow.getHours(); // 设置默认文字 let text = ''; // 判断当前时间段 if (hours &gt;= 0 &amp;&amp; hours &lt; 6) &#123; text = '早上'; &#125; else if (hours &gt;= 6 &amp;&amp; hours &lt; 12) &#123; text = '上午'; &#125; else if (hours &gt;= 12 &amp;&amp; hours &lt; 14) &#123; text = '中午'; &#125; else if (hours &gt;= 14 &amp;&amp; hours &lt; 18) &#123; text = '下午'; &#125; else if (hours &gt;= 18 &amp;&amp; hours &lt; 24) &#123; text = '晚上'; &#125; // 返回当前时间段名称 return text;&#125;/** * 计算某月1号是星期几 * @param year * @param month * @returns &#123;number&#125; */function getWeekInMonth(year, month) &#123; return new Date(year + '/' + month + '/' + '01').getDay();&#125;/** * 判断指定年份是否是闰年 * @param year * @returns &#123;boolean&#125; */function isLeapYear(year) &#123; return year % 400 == 0 || year % 4 == 0 &amp;&amp; year % 100 != 0&#125;/** * 计算某年某月有多少天 * @param year * @param month * @returns &#123;*|number&#125; */function getDaysInMonth(year, month) &#123; return [null, 31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month] || (isLeapYear(year) ? 29 : 28)&#125;/** * 计算得到指定月日历的所有日期arr，并对第一周和最后一周进行补位（如有需要） * @param year * @param month * @returns &#123;Array&#125; */function getMonthCalendarDay(year, month)&#123; // 0是星期日，1是星期一...6是星期六 let monthFirstDay = getWeekInMonth(year, month); if(monthFirstDay == 0)&#123; monthFirstDay = 7; &#125; let dayArr = []; // 如果1号是星期一，不补位；否则要把1号本周的前几天补位 if(monthFirstDay != 1)&#123; for(let i = 0; i &lt; monthFirstDay - 1; i++)&#123; dayArr.push(\"\"); &#125; &#125; // 本月所有常规日期 let days = getDaysInMonth(parseInt(year), parseInt(month)); for(let i = 1; i &lt;= days; i++)&#123; dayArr.push(i+''); &#125; // 如果最后一天是星期日，不补位；否则最后一天所在周的剩余后几天补位 if(dayArr.length % 7 != 0)&#123; let lastWeekDays = dayArr.length % 7; for(let i = 0; i &lt; 7 - lastWeekDays; i++)&#123; dayArr.push(\"\"); &#125; &#125; return dayArr;&#125;/** * 获取指定年月的前n月，后n月 * @param date 代表指定的年月，格式：2018-09 * @param day 传-1表始前一月，传1表始后一月 * @returns &#123;string&#125; 格式：2018-09 */function getNextMonth(monthDate, month) &#123; var arr = monthDate.split(/[-]/); let dd = new Date(arr[0], arr[1] - 1); dd.setMonth(dd.getMonth() + month); var y = dd.getFullYear(); var m = dd.getMonth() + 1 &lt; 10 ? \"0\" + (dd.getMonth() + 1) : dd.getMonth() + 1; return y + \"-\" + m;&#125;/** * 获取指定日期的前n天，后n天 * @param date 代表指定的日期，格式：2018-09-27 * @param day 传-1表始前一天，传1表始后一天 * @returns &#123;string&#125; 格式：2018-09-27 */function getNextDate(date, day) &#123; var arr = date.split(/[-]/); let dd = new Date(arr[0], arr[1] - 1, arr[2]); dd.setDate(dd.getDate() + day); var y = dd.getFullYear(); var m = dd.getMonth() + 1 &lt; 10 ? \"0\" + (dd.getMonth() + 1) : dd.getMonth() + 1; var d = dd.getDate() &lt; 10 ? \"0\" + dd.getDate() : dd.getDate(); return y + \"-\" + m + \"-\" + d;&#125;/** * 获取当前日期，格式2019-07-15 * @returns &#123;string&#125; */function getNowFormatDate() &#123; var date = new Date(); return dateFormat(date);&#125;/** * 日期格式化 * @param date */function dateFormat(date) &#123; if (!date || typeof (date) === \"string\") &#123; console.error(\"参数异常，请检查...\"); return null; &#125; var separator = \"-\"; var year = date.getFullYear(); var month = date.getMonth() + 1; var strDate = date.getDate(); if (month &gt;= 1 &amp;&amp; month &lt;= 9) &#123; month = \"0\" + month; &#125; if (strDate &gt;= 0 &amp;&amp; strDate &lt;= 9) &#123; strDate = \"0\" + strDate; &#125; var formatDate = year + separator + month + separator + strDate; return formatDate;&#125;/** * 计算距离etime剩余时间 * @param etime * @returns &#123;*&#125; */function formatLeftTime(etime) &#123; var timestamp = Date.parse(new Date()); var surplus = etime - timestamp; if (surplus &gt; 0) &#123; var secondTime = surplus / 1000;// 毫秒转为秒 var second = Math.floor(secondTime % 60); // 计算秒 var minute = Math.floor((secondTime / 60) % 60); // 计算分 var hour = Math.floor((secondTime / 3600)); // 计算小时 return [hour, minute, second].map(formatNumber).join(':') &#125; return null;&#125;/** * 获取指定日期之间的所有日期（包含开始结束日期） * @param stime * @param etime * @returns &#123;any[]&#125; */function getBetweenDateStr(stime,etime)&#123; //初始化日期列表，数组 var dateStrArr = new Array(); var i=0; //开始日期小于等于结束日期,并循环 while(stime&lt;=etime)&#123; dateStrArr[i] = stime; //获取开始日期时间戳 var stime_ts = new Date(stime).getTime(); //增加一天时间戳后的日期 var next_date = stime_ts + (24*60*60*1000); //拼接年月日，这里的月份会返回（0-11），所以要+1 var next_dates_y = new Date(next_date).getFullYear()+'-'; var next_dates_m = (new Date(next_date).getMonth()+1 &lt; 10)?'0'+(new Date(next_date).getMonth()+1)+'-':(new Date(next_date).getMonth()+1)+'-'; var next_dates_d = (new Date(next_date).getDate() &lt; 10)?'0'+new Date(next_date).getDate():new Date(next_date).getDate(); stime = next_dates_y+next_dates_m+next_dates_d; //增加数组key i++; &#125; return dateStrArr;&#125;// 获取本周的周一日期function getFirstDayOfWeek()&#123; var date = new Date(); var weekday = date.getDay()||7; //获取星期几,getDay()返回值是 0（周日） 到 6（周六） 之间的一个整数。0||7为7，即weekday的值为1-7 date.setDate(date.getDate()-weekday+1);//往前算（weekday-1）天，年份、月份会自动变化 return dateFormat(date);&#125;/** * 如果是yyyy-MM-dd HH:mm:ss格式直接转Date，在iOS上不支持 * @param dateStr * @returns &#123;number&#125; */function parseDate(dateStr) &#123; var arr = dateStr.split(/[- :]/); let nndate = new Date(arr[0], arr[1] - 1, arr[2], arr[3], arr[4], arr[5]); return Date.parse(nndate);&#125;/********************日期时间相关-end********************//********************验证相关-start********************//** * 验证手机号是否合法 * @param phone * @returns &#123;boolean&#125; */function validMobile(phone)&#123; var reg=/^1[3456789]\\d&#123;9&#125;$/; if(!reg.test(phone))&#123; return false; &#125; return true;&#125;/** * 验证固定电话号码是否合法 * @param phone * @returns &#123;boolean&#125; */function validPhone(phone)&#123; var reg=/^0\\d&#123;2,3&#125;-?\\d&#123;7,8&#125;$/; if(!reg.test(phone))&#123; return false; &#125; return true;&#125;/** * 验证网址是否合法 * @param website * @returns &#123;boolean&#125; */function validWebsite(website)&#123; var reg=/^(?:http(s)?:\\/\\/)?[\\w.-]+(?:\\.[\\w\\.-]+)+[\\w\\-\\._~:/?#[\\]@!\\$&amp;'\\*\\+,;=.]+$/; if(!reg.test(website))&#123; return false; &#125; return true;&#125;/** * 校验身份证号 * @param cardNo * @returns &#123;boolean&#125; */function validIDCardNo(cardNo)&#123; var reg=/^[1-9]&#123;1&#125;[0-9]&#123;14&#125;$|^[1-9]&#123;1&#125;[0-9]&#123;16&#125;([0-9]|[xX])$/; if(!reg.test(cardNo))&#123; return false; &#125; return true;&#125;/** * 验证邮编是否合法 * @param postcode * @returns &#123;boolean&#125; */function validPostcode(postcode)&#123; var reg=/^[0-9]&#123;6&#125;$/; if(!reg.test(postcode))&#123; return false; &#125; return true;&#125;/** * 验证邮箱是否合法 * @param email * @returns &#123;boolean&#125; */function validEmail(email)&#123; var reg=/^[a-zA-Z0-9]+([-_.][a-zA-Z0-9]+)*@[a-zA-Z0-9]+([-_.][a-zA-Z0-9]+)*\\.[a-z]&#123;2,&#125;$/; if(!reg.test(email))&#123; return false; &#125; return true;&#125;/** * 校验金额是否合法，返回true校验通过 */function verifyAmount(amount)&#123; var exp = /^(([1-9]\\d*)|\\d)(\\.\\d&#123;1,2&#125;)?$/; if(!exp.test(amount))&#123; return false; &#125; return true;&#125;/********************验证相关-end********************//********************数字相关-start********************//** * 小于10的前面补0 * @param n * @returns &#123;string&#125; */function formatNumber(n) &#123; n = n.toString() return n[1] ? n : '0' + n&#125;/** * 千位分隔符处理 * @param strNum * @returns &#123;*|string&#125; */function thousandBitSeparator(strNum) &#123; if(strNum.length &lt;= 3) &#123; return strNum; &#125; if(!/^(\\+|-)?(\\d+)(\\.\\d+)?$/.test(strNum)) &#123; return strNum; &#125; var a = RegExp.$1, b = RegExp.$2, c = RegExp.$3; var re = new RegExp(); re.compile(\"(\\\\d)(\\\\d&#123;3&#125;)(,|$)\"); while(re.test(b)) &#123; b = b.replace(re, \"$1,$2$3\"); &#125; return a + \"\" + b + \"\" + c;&#125;/** * 返回beginNum和endNum之间的所有数字数组 * @param beginNum 开始数字 * @param endNum 结束数字（包含） * @param fillZeroFlag 小于10的数是否补0 */function getNumArr(beginNum, endNum, fillZeroFlag)&#123; var numArr = [] for(var i = beginNum; i &lt;= endNum; i++)&#123; if(fillZeroFlag &amp;&amp; i &lt; 10)&#123; numArr.push('0' + i); &#125;else&#123; numArr.push('' + i); &#125; &#125; return numArr;&#125;// 以下方法主要用于小数的基本运算，防止丢精// 除法function accDivide(arg1,arg2)&#123; var t1=0,t2=0,r1,r2; try&#123;t1=arg1.toString().split(\".\")[1].length&#125;catch(e)&#123;&#125; try&#123;t2=arg2.toString().split(\".\")[1].length&#125;catch(e)&#123;&#125; with(Math)&#123; r1=Number(arg1.toString().replace(\".\",\"\")) r2=Number(arg2.toString().replace(\".\",\"\")) return accMulti((r1/r2),pow(10,t2-t1)); &#125;&#125;//乘法function accMulti(arg1,arg2)&#123; var m=0,s1=arg1.toString(),s2=arg2.toString(); try&#123;m+=s1.split(\".\")[1].length&#125;catch(e)&#123;&#125; try&#123;m+=s2.split(\".\")[1].length&#125;catch(e)&#123;&#125; return Number(s1.replace(\".\",\"\"))*Number(s2.replace(\".\",\"\"))/Math.pow(10,m)&#125;//加法function accAdd(arg1,arg2)&#123; var r1,r2,m; try&#123;r1=arg1.toString().split(\".\")[1].length&#125;catch(e)&#123;r1=0&#125; try&#123;r2=arg2.toString().split(\".\")[1].length&#125;catch(e)&#123;r2=0&#125; m=Math.pow(10,Math.max(r1,r2)) return (arg1*m+arg2*m)/m&#125;//减法function accMinus(arg1,arg2)&#123; var r1,r2,m,n; try&#123;r1=arg1.toString().split(\".\")[1].length&#125;catch(e)&#123;r1=0&#125; try&#123;r2=arg2.toString().split(\".\")[1].length&#125;catch(e)&#123;r2=0&#125; m=Math.pow(10,Math.max(r1,r2)); n=(r1&gt;=r2)?r1:r2; return ((arg1*m-arg2*m)/m).toFixed(n);&#125;/********************数字相关-end********************//********************金额相关-start********************//** * 金额统一保留2位小数 * @param amount 金额，单位为元 * @returns &#123;string&#125; */function formatPayAmount(amount)&#123; return parseFloat(amount).toFixed(2);&#125;/********************金额相关-end********************//********************其他相关-start********************/// 原生js实现addClass,removeClass,hasClass方法function hasClass(elem, cls) &#123; cls = cls || ''; if (cls.replace(/\\s/g, '').length == 0) return false; //当cls没有参数时，返回false return new RegExp(' ' + cls + ' ').test(' ' + elem.className + ' ');&#125;function addClass(elem, cls) &#123; if (!hasClass(elem, cls)) &#123; elem.className = elem.className == '' ? cls : elem.className + ' ' + cls; &#125;&#125;function removeClass(elem, cls) &#123; if (hasClass(elem, cls)) &#123; var newClass = ' ' + elem.className.replace(/[\\t\\r\\n]/g, '') + ' '; while (newClass.indexOf(' ' + cls + ' ') &gt;= 0) &#123; newClass = newClass.replace(' ' + cls + ' ', ' '); &#125; elem.className = newClass.replace(/^\\s+|\\s+$/g, ''); &#125;&#125;/** * 根据身份证号获取性别 * @param cardNo * @returns &#123;string&#125; */function getSexByIDCardNo(cardNo)&#123; if(cardNo.length == 18)&#123; if (parseInt(cardNo.substr(16, 1)) % 2 == 1) &#123; return \"男\"; &#125; else &#123; return \"女\"; &#125; &#125;else if(cardNo.length == 15)&#123; if (parseInt(cardNo.substr(14, 1)) % 2 == 1) &#123; return \"男\"; &#125; else &#123; return \"女\"; &#125; &#125; return '';&#125;/** * 查找元素在js数组的索引，不存在则返回-1 * @param arr * @param obj * @returns &#123;*&#125; */function findIndexOfArr(arr, obj) &#123; var i = arr.length; while (i--) &#123; if (arr[i] === obj) &#123; return i; &#125; &#125; return -1;&#125;// 调用微信关闭浏览器function closeWxWindow()&#123; WeixinJSBridge.invoke('closeWindow',&#123;&#125;,function(res)&#123; &#125;);&#125;/********************其他相关-end********************/","tags":[{"name":"js","slug":"js","permalink":"https://sunshine-zwq.github.io/tags/js/"},{"name":"工具","slug":"工具","permalink":"https://sunshine-zwq.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"利用LinkedHashMap实现LRU算法","date":"2020-11-15T16:00:00.000Z","path":"2020/11/16/利用LinkedHashMap实现LRU算法/","text":"LRU LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.util.ArrayList;import java.util.Collection;import java.util.LinkedHashMap;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;import java.util.Map;/** * 类说明：利用LinkedHashMap实现简单的缓存， 必须实现removeEldestEntry方法，具体参见JDK文档 * * @author dennis * * @param &lt;K&gt; * @param &lt;V&gt; */public class LRULinkedHashMap&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123; private final int maxCapacity; private static final float DEFAULT_LOAD_FACTOR = 0.75f; private final Lock lock = new ReentrantLock(); public LRULinkedHashMap(int maxCapacity) &#123; super(maxCapacity, DEFAULT_LOAD_FACTOR, true); this.maxCapacity = maxCapacity; &#125; @Override protected boolean removeEldestEntry(java.util.Map.Entry&lt;K, V&gt; eldest) &#123; return size() &gt; maxCapacity; &#125; @Override public boolean containsKey(Object key) &#123; try &#123; lock.lock(); return super.containsKey(key); &#125; finally &#123; lock.unlock(); &#125; &#125; @Override public V get(Object key) &#123; try &#123; lock.lock(); return super.get(key); &#125; finally &#123; lock.unlock(); &#125; &#125; @Override public V put(K key, V value) &#123; try &#123; lock.lock(); return super.put(key, value); &#125; finally &#123; lock.unlock(); &#125; &#125; public int size() &#123; try &#123; lock.lock(); return super.size(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void clear() &#123; try &#123; lock.lock(); super.clear(); &#125; finally &#123; lock.unlock(); &#125; &#125; public Collection&lt;Map.Entry&lt;K, V&gt;&gt; getAll() &#123; try &#123; lock.lock(); return new ArrayList&lt;Map.Entry&lt;K, V&gt;&gt;(super.entrySet()); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 参考链接： 缓存淘汰算法–LRU算法(java代码实现)","tags":[{"name":"java","slug":"java","permalink":"https://sunshine-zwq.github.io/tags/java/"},{"name":"算法","slug":"算法","permalink":"https://sunshine-zwq.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Java8特性","date":"2020-09-29T16:00:00.000Z","path":"2020/09/30/Java8特性/","text":"Java 8 新特性简介 速度更快 代码更少（增加了新的语法 Lambda 表达式） 强大的 Stream API 便于并行 最大化减少空指针异常 Optional 1.Lambda 表达式简介： Lambda 是一个 匿名函数。Lambda 表达式在Java 语言中引入了一个新的语法元素和操作符 “-&gt;” ，该操作符被称为 Lambda 操作符或箭头操作符。它将 Lambda 分为两个部分： 左侧：指定了 Lambda 表达式需要的所有参数右侧：指定了 Lambda 体，即 Lambda 表达式要执行的功能。 从匿名类到 Lambda 的转换： 12345678910// 匿名内部类Runnable r1 = new Runnable() &#123; @Override public void run() &#123; System.out.println(\"Hello World\"); &#125;&#125;// Lambda表达式Runnable r1 = () -&gt; System.out.println(\"Hello World\"); Lambda 表达式语法： 12345678910111213141516171819202122// 语法格式1：无参，无返回值，Lambda体只需要一条语句Runnable r1 = () -&gt; System.out.println(\"Hello Lambda!\");// 语法格式2：Lambda只需要一个参数Consumer&lt;String&gt; fun = (args) -&gt; System.out.println(args);// 只有一个参数时，参数的括号可省略（参数有2个或以上时，括号不能省略）Consumer&lt;String&gt; fun = args -&gt; System.out.println(args);// 语法格式3：Lambda需要2个参数，并且有返回值BinaryOperator&lt;Long&gt; bo = (x, y) -&gt; &#123; System.out.println(\"实现函数接口方法\"); return x + y;&#125;// 语法格式4：当Lambda体有返回值且只有一条语句时，return与大括号可以省略BinaryOperator&lt;Long&gt; bo = (x, y) -&gt; x + y;// 语法格式5：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”BinaryOperator&lt;Long&gt; bo = (Long x, Long y) -&gt; &#123; System.out.println(\"实现函数接口方法\"); return x + y;&#125; 类型推断 上述 Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac根据程序的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的。 2.函数式接口简介： 只包含一个抽象方法的接口，称为 函数式接口。 可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明）。 我们可以在任意函数式接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口，同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口 自定义函数式接口： 12345678910@FunctionalInterfacepublic interface MyNumber &#123; public double getValue();&#125;// 函数式接口中使用泛型@FunctionalInterfacepublic interface MyFunc&lt;T&gt; &#123; public T getValue(T t);&#125; 作为参数传递Lambda表达式： 123456public String toUpperString(MyFunc&lt;String&gt; mf, String str)&#123; return mf.getValue(str);&#125;String newStr = toUpperString((str) -&gt; str.toUpperCase(), \"abcdef\");System.out.println(newStr); Java内置四大核心函数式接口： 函数式接口 参数类型 返回类型 用途 Consumer：消费型接口 T void 对类型为T的对象应用操作，包含方法：void accept(T t) Supplier：供给型接口 无 T 返回类型为T的对象，包含方法：T get(); Function&lt;T, R&gt;：函数型接口 T R 对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：R apply(T t); Predicate：断定型接口 T boolean 确定类型为T的对象是否满足某约束，并返回boolean 值。包含方法：boolean test(T t); 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// Consumer&lt;T&gt; 消费型接口 @Test public void test1()&#123; buy(1000, (m) -&gt; System.out.println(\"本次超市购物消费\" + m + \"元\")); &#125; public void buy(double money, Consumer&lt;Double&gt; con)&#123; con.accept(money); &#125; // Supplier&lt;T&gt; 供给型接口 @Test public void test2()&#123; List&lt;Integer&gt; numList = getNumList(10, () -&gt; (int)(Math.random() * 100)); for (Integer num : numList) &#123; System.out.println(num); &#125; &#125; // 需求：产生指定个数的整数，并放入集合中 public List&lt;Integer&gt; getNumList(int num, Supplier&lt;Integer&gt; sup)&#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; num; i++)&#123; list.add(sup.get()); &#125; return list; &#125; // Function&lt;T, R&gt; 函数型接口 @Test public void test3()&#123; String newStr = strHandler(\" 测试Function函数式接口 \", (s) -&gt; s.trim()); System.out.println(newStr); String subStr = strHandler(\"测试Function函数式接口\", (s) -&gt; s.substring(2, 5)); System.out.println(subStr); &#125; public String strHandler(String str, Function&lt;String, String&gt; fun)&#123; return fun.apply(str); &#125; // Predicate&lt;T&gt; 断言型接口 @Test public void test4()&#123; List&lt;String&gt; list = Arrays.asList(\"Hello\", \"www\", \"ok\", \"Lambda\", \"test\"); List&lt;String&gt; resultList = filterStr(list, (s) -&gt; s.contains(\"e\")); for (String s : resultList) &#123; System.out.println(s); &#125; &#125; public List&lt;String&gt; filterStr(List&lt;String&gt; list, Predicate&lt;String&gt; pre)&#123; List&lt;String&gt; strList = new ArrayList&lt;&gt;(); for (String s : list) &#123; if(pre.test(s))&#123; strList.add(s); &#125; &#125; return strList; &#125; 其他接口： 函数式接口 参数类型 返回类型 用途 BiFunction&lt;T, U, R&gt; T, U R 对类型为 T, U 参数应用操作，返回 R 类型的结果。包含方法：R apply(T t, U u); UnaryOperator(Function 子接口) T T 对类型为T的对象进行一元运算，并返回T类型的结果。包含方法：T apply(T t); BinaryOperator(BiFunction 子接口) T, T T 对类型为T的对象进行二元运算，并返回T类型的结果。包含方法：T apply(T t1, T t2); BiConsumer&lt;T, U&gt; T, U void 对类型为T, U 参数应用操作。包含方法：void accept(T t, U u) ToIntFunctionToLongFunctionToDoubleFunction T intlongdouble 分别计算int 、 long 、double值的函数 IntFunctionLongFunctionDoubleFunction intlongdouble R 参数分别为int、long、double 类型的函数 3.方法引用与构造器引用简介： 当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用 可以理解为，方法引用是lambda表达式的另外一种表现形式。 实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致 方法引用，使用操作符 :: 将方法名和对象或类的名字分隔开来。 (1).对象::实例方法 1234(x) -&gt; System.out.println(x)// 等同于System.out::println (2).类::静态方法 1234BinaryOperator&lt;Double&gt; bo = (x, y) -&gt; Math.pow(x, y);// 等同于BinaryOperator&lt;Double&gt; bo = Math::pow; (3).类::实例方法 当需要引用方法的第一个参数是调用对象，并且第二个参数是需要引用方法的第二个 参数( 或无参数 ) 时：ClassName::methodName 1234compare((x, y) -&gt; x.equals(y), \"abcdef\", \"abcdef\");// 等同于compare(String::equals, \"abcdef\", \"abcdef\"); (4).构造器引用 格式：Class::new 与函数式接口相结合，自动与函数式接口中方法兼容。可以把构造器引用赋值给定义的方法，与构造器参数列表要与接口中抽象方法的参数列表一致！ 1234Function&lt;Integer, MyClass&gt; fun = (n) -&gt; new MyClass(n);// 等同于Function&lt;Integer, MyClass&gt; fun = MyClass::new; (5).数组引用 格式：type[]::new 1234Function&lt;Integer, Integer[]&gt; fun = (n) -&gt; new Integer[n];// 等同于Function&lt;Integer, Integer[]&gt; fun = Integer[]::new; 4.Stream API简介： Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。 什么是Stream？ Stream是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。“集合讲的是数据，流讲的是计算！ 注意：①Stream 自己不会存储元素。②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。 Stream的操作三个步骤： 创建Stream 一个数据源（如：集合、数组），获取一个流 中间操作 一个中间操作链，对数据源的数据进行处理 终止操作（终端操作） 一个终止操作，执行中间操作链，并产生结果 创建Stream(1).通过Collection接口方法 Java8 中的 Collection 接口被扩展，提供了两个获取流的方法 ： default Stream stream() : 返回一个顺序流 default Stream parallelStream() : 返回一个并行流 (2).由数组创建流 Java8 中的 Arrays 的静态方法 stream() 可以获取数组流： static Stream stream(T[] array): 返回一个流 (3).由值创建流 可以使用静态方法 Stream.of(), 通过显示值创建一个流。它可以接收任意数量的参数。 public static Stream of(T… values) : 返回一个流 (4).由函数创建流：创建无限流 可以使用静态方法 Stream.iterate() 和Stream.generate()，创建无限流。 迭代 public static Stream iterate(final T seed, final UnaryOperator f) 生成 public static Stream generate(Supplier s) 示例代码： 12345678910111213141516171819202122// 1.可以通过Collection系列集合提供的stream()或parallelStream() List&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;String&gt; stream1 = list.stream(); // 2.通过Arrays中的静态方法stream()获取数据流 Employee[] emps = new Employee[10]; Stream&lt;Employee&gt; stream2 = Arrays.stream(emps); // 3.通过Stream类中的静态方法of Stream&lt;String&gt; stream3 = Stream.of(\"aa\", \"bb\", \"cc\"); // 4.创建无限流 // 迭代 Stream&lt;Integer&gt; stream4 = Stream.iterate(0, (x) -&gt; x + 2); stream4.limit(10).forEach(System.out::println); System.out.println(\"===========================================\"); // 生成 Stream.generate(() -&gt; Math.random()) .limit(5) .forEach(System.out::println); 中间操作多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。 筛选与切片 方法 描述 filter(Predicate p) 接收 Lambda ， 从流中排除某些元素 distinct() 筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素 limit(long maxSize) 截断流，使其元素不超过给定数量 skip(long n) 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546List&lt;Employee&gt; emps = Arrays.asList( new Employee(101, \"张三\", 18, 9999.99), new Employee(102, \"李四\", 59, 6666.66), new Employee(103, \"王五\", 28, 3333.33), new Employee(104, \"赵六\", 8, 7777.77), new Employee(105, \"田七\", 38, 5555.55), new Employee(105, \"田七\", 38, 5555.55), new Employee(105, \"田七\", 38, 5555.55) ); // filter @Test public void test1()&#123; Stream&lt;Employee&gt; stream = emps.stream() .filter((e) -&gt; e.getAge() &gt; 35); stream.forEach(System.out::println); &#125; // limit @Test public void test2()&#123; emps.stream() .filter((e) -&gt; e.getSalary() &gt; 5000) .limit(2) .forEach(System.out::println); &#125; // skip @Test public void test3()&#123; emps.stream() .filter((e) -&gt; e.getSalary() &gt; 5000) .skip(2) .forEach(System.out::println); &#125; // distinct @Test public void test4()&#123; emps.stream() .filter((e) -&gt; e.getSalary() &gt; 5000) .skip(2) .distinct() .forEach(System.out::println); &#125; 映射 方法 描述 map(Function f) 接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。 mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。 mapToInt(ToIntFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream。 mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。 flatMap(Function f) 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 示例代码： 12345678910111213141516171819202122232425262728293031323334 // map @Test public void test5()&#123; List&lt;String&gt; list = Arrays.asList(\"aaa\", \"bbb\", \"ccc\", \"ddd\"); list.stream() .map((str) -&gt; str.toUpperCase()) .forEach(System.out::println); System.out.println(\"===========================================\"); emps.stream() .map((e) -&gt; e.getName()) .forEach(System.out::println); System.out.println(\"===========================================\");// Stream&lt;Stream&lt;Character&gt;&gt; stream = list.stream()// .map((s) -&gt; filterCharacter(s));// stream.forEach((sm) -&gt; &#123;// sm.forEach(System.out::println);// &#125;); list.stream() .flatMap((s) -&gt; filterCharacter(s)) .forEach(System.out::println); &#125; public static Stream&lt;Character&gt; filterCharacter(String str)&#123; List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for (char ch : str.toCharArray()) &#123; list.add(ch); &#125; return list.stream(); &#125; 排序 方法 描述 sorted() 产生一个新流，其中按自然顺序排序 sorted(Comparator comp) 产生一个新流，其中按比较器顺序排序 示例代码： 123456789101112131415161718@Test public void test6()&#123; List&lt;String&gt; list = Arrays.asList(\"ccc\", \"aaa\", \"ddd\", \"eee\", \"bbb\"); list.stream() .sorted() .forEach(System.out::println); System.out.println(\"===========================================\"); emps.stream() .sorted((e1, e2) -&gt; &#123; if(e1.getAge() == e2.getAge())&#123; return e1.getName().compareTo(e2.getName()); &#125;else&#123; return e1.getAge() - e2.getAge(); &#125; &#125;).forEach(System.out::println); &#125; 终止操作终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void。 查找与匹配 方法 描述 allMatch(Predicate p) 检查是否匹配所有元素 anyMatch(Predicate p) 检查是否至少匹配一个元素 noneMatch(Predicate p) 检查是否没有匹配所有元素 findFirst() 返回第一个元素 findAny() 返回当前流中的任意元素 count() 返回流中元素总数 max(Comparator c) 返回流中最大值 min(Comparator c) 返回流中最小值 forEach(Consumer c) 内部迭代(使用 Collection 接口需要用户去做迭代，称为外部迭代 。相反， Stream API 使用内部迭代 —— 它帮你把迭代做了) 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647List&lt;Employee&gt; emps = Arrays.asList( new Employee(101, \"张三\", 18, 9999.99), new Employee(102, \"李四\", 59, 6666.66), new Employee(103, \"王五\", 28, 3333.33), new Employee(104, \"赵六\", 8, 7777.77), new Employee(105, \"田七\", 38, 5555.55) ); @Test public void test1()&#123; boolean b1 = emps.stream() .allMatch((e) -&gt; e.getSalary() &gt; 5000); System.out.println(b1); boolean b2 = emps.stream() .anyMatch((e) -&gt; e.getSalary() &gt; 5000); System.out.println(b2); boolean b3 = emps.stream() .noneMatch((e) -&gt; e.getSalary() &gt; 5000); System.out.println(b3); Optional&lt;Employee&gt; op = emps.stream() .sorted((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())) .findFirst(); System.out.println(op.get()); Optional&lt;Employee&gt; op2 = emps.parallelStream() .filter((e) -&gt; e.getSalary() &gt; 5000) .findAny(); System.out.println(op2.get()); &#125; @Test public void test2()&#123; long count = emps.stream().count(); System.out.println(count); Optional&lt;Employee&gt; op1 = emps.stream() .max((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())); System.out.println(op1.get()); Optional&lt;Double&gt; op2 = emps.stream() .map(Employee::getSalary) .min(Double::compare); System.out.println(op2.get()); &#125; 规约 方法 描述 reduce(T iden, BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 T reduce(BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 Optional 示例代码： 12345678910111213@Test public void test3()&#123; List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,9,10); Integer sum = list.stream() .reduce(0, (x, y) -&gt; x + y); System.out.println(sum); Optional&lt;Double&gt; op = emps.stream() .map(Employee::getSalary) .reduce(Double::sum); System.out.println(op.get()); &#125; 收集 方法 描述 collect(Collector c) 将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法 Collector 接口中方法的实现决定了如何对流执行收集操作(如收集到 List、Set、Map)。但是 Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表： 方法 返回类型 作用 示例 toList List 把流中元素收集到List List emps = list.stream().collect(Collectors.toList()); toSet Set 把流中元素收集到Set Set emps= list.stream().collect(Collectors.toSet()); toCollection Collection 把流中元素收集到创建的集合 Collectionemps=list.stream().collect(Collectors.toCollection(ArrayList::new)); counting Long 计算流中元素的个数 long count = list.stream().collect(Collectors.counting()); summingInt Integer 对流中元素的整数属性求和 inttotal=list.stream().collect(Collectors.summingInt(Employee::getSalary)); averagingInt Double 计算流中元素Integer属性的平均值 doubleavg= list.stream().collect(Collectors.averagingInt(Employee::getSalary)); summarizingInt IntSummaryStatistics 收集流中Integer属性的统计值。如：平均值 IntSummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary)); joining String 连接流中每个字符串 String str= list.stream().map(Employee::getName).collect(Collectors.joining()); maxBy Optional 根据比较器选择最大值 Optionalmax= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary))); minBy Optional 根据比较器选择最小值 Optional min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary))); reducing 归约产生的类型 从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值 inttotal=list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum)); collectingAndThen 转换函数返回的类型 包裹另一个收集器，对其结果转换函数 inthow= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size)); groupingBy Map&lt;K, List&gt; 根据某属性值对流分组，属性为K，结果为V Map&lt;Emp.Status, List&gt; map= list.stream().collect(Collectors.groupingBy(Employee::getStatus)); partitioningBy Map&lt;Boolean, List&gt; 根据true或false进行分区 Map&lt;Boolean,List&gt;vd= list.stream().collect(Collectors.partitioningBy(Employee::getManage)); 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485@Test public void test4()&#123; List&lt;String&gt; list = emps.stream() .map(Employee::getName) .collect(Collectors.toList()); list.forEach(System.out::println); Set&lt;String&gt; set = emps.stream() .map(Employee::getName) .collect(Collectors.toSet()); set.forEach(System.out::println); HashSet&lt;String&gt; hs = emps.stream() .map(Employee::getName) .collect(Collectors.toCollection(HashSet::new)); hs.forEach(System.out::println); &#125; @Test public void test5()&#123; // 总数 Long count = emps.stream() .collect(Collectors.counting()); System.out.println(count); // 平均值 Double avg = emps.stream() .collect(Collectors.averagingDouble(Employee::getSalary)); System.out.println(avg); // 总和 Double sum = emps.stream() .collect(Collectors.summingDouble(Employee::getSalary)); System.out.println(sum); // 最大值 Optional&lt;Employee&gt; max = emps.stream() .collect(Collectors.maxBy((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()))); System.out.println(max.get()); // 最小值 Optional&lt;Double&gt; min = emps.stream() .map(Employee::getSalary) .collect(Collectors.minBy(Double::compare)); System.out.println(min.get()); &#125; @Test public void test6()&#123; // 分组 Map&lt;String, List&lt;Employee&gt;&gt; map = emps.stream() .collect(Collectors.groupingBy((e) -&gt; &#123; if (((Employee) e).getSalary() &gt; 7000) &#123; return \"高薪\"; &#125; else &#123; return \"低薪\"; &#125; &#125;)); System.out.println(map); &#125; @Test public void test7()&#123; // 分区 Map&lt;Boolean, List&lt;Employee&gt;&gt; map = emps.stream() .collect(Collectors.partitioningBy((e) -&gt; e.getSalary() &gt; 7000)); System.out.println(map); &#125; @Test public void test8()&#123; DoubleSummaryStatistics dss = emps.stream() .collect(Collectors.summarizingDouble(Employee::getSalary)); System.out.println(dss.getSum()); System.out.println(dss.getAverage()); System.out.println(dss.getMax()); &#125; @Test public void test9()&#123; String str = emps.stream() .map(Employee::getName) .collect(Collectors.joining(\",\")); System.out.println(str); &#125; 并行流与串行流 并行流 就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。 Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与sequential() 在并行流与顺序流之间进行切换。 5.Optional类简介： Optional 类(java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。 常用方法： Optional.of(T t)：创建一个 Optional 实例 Optional.empty()：创建一个空的 Optional 实例 Optional.ofNullable(T t)：若 t 不为 null,创建 Optional 实例,否则创建空实例 isPresent()：判断是否包含值 orElse(T t)：如果调用对象包含值，返回该值，否则返回t orElseGet(Supplier s) ：如果调用对象包含值，返回该值，否则返回 s 获取的值 map(Function f)：如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty() flatMap(Function mapper)：与 map 类似，要求返回值必须是Optional 示例代码： 12345678910111213141516171819202122232425262728293031323334353637@Test public void test1()&#123; Optional&lt;Employee&gt; op = Optional.of(new Employee()); Employee emp = op.get(); System.out.println(emp); &#125; @Test public void test2()&#123; Optional&lt;Employee&gt; op = Optional.empty(); System.out.println(op); &#125; @Test public void test3()&#123; Optional&lt;Employee&gt; op = Optional.ofNullable(null); if(op.isPresent())&#123; System.out.println(op.get()); &#125; Employee emp1 = op.orElse(new Employee(\"张三\", 28)); System.out.println(emp1); Employee emp2 = op.orElseGet(Employee::new); System.out.println(emp2); &#125; @Test public void test4()&#123; Optional&lt;Employee&gt; op = Optional.ofNullable(new Employee(\"张三\", 28)); Optional&lt;String&gt; str = op.map((e) -&gt; e.getName()); System.out.println(str.get()); Optional&lt;String&gt; str2 = op.flatMap((e) -&gt; Optional.of(e.getName())); System.out.println(str2.get()); &#125; 尽量避免使用的地方： 1、避免使用Optional.isPresent()来检查实例是否存在，因为这种方式和null != obj没有区别，这样用就没什么意义了。 2、避免使用Optional.get()方式来获取实例对象，因为使用前需要使用Optional.isPresent()来检查实例是否存在，否则会出现NPE问题。 3、避免使用Optional作为类或者实例的属性，而应该在返回值中用来包装返回实例对象。 4、避免使用Optional作为方法的参数，原因同3。 使用Optional优化的经典案例： 1234567891011121314151617181920212223// java8之前的多重if判断private String getIsoCode(User user)&#123; if (user != null) &#123; Address address = user.getAddress(); if (address != null) &#123; Country country = address.getCountry(); if (country != null) &#123; String isocode = country.getIsocode(); if (isocode != null) &#123; return isocode; &#125; &#125; &#125; &#125; return \"\";&#125;// 用java8的Optional优化后String isoCode = Optional.ofNullable(user) .map(User::getAddress) //Optional&lt;Address&gt; .map(Address::getCountry) //Optional&lt;Country&gt; .map(Country::getIsocode) // Optional&lt;String&gt; .orElse(\"\"); 6.接口中的默认方法与静态方法接口中的默认方法 Java 8中允许接口中包含具有具体实现的方法，该方法称为“默认方法”，默认方法使用 default 关键字修饰。 示例代码： 1234567public interface MyFunc &#123; default String getName()&#123; return \"Hello Java8\"; &#125;&#125; 接口默认方法的 ” 类优先 ”原则 若一个接口中定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时： 选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。 接口冲突。如果一个父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否是默认方法），那么必须覆盖该方法来解决冲突 示例代码： 1234567891011121314151617interface MyFunc&#123; default String getName()&#123; return \"Hello Java8\"; &#125;&#125;interface Named&#123; default String getName()&#123; return \"Hello World\"; &#125;&#125;class MyClass implements MyFunc, Named&#123; public String getName()&#123; return Named.super.getName(); &#125;&#125; 接口中的静态方法 Java8 中，接口中允许添加静态方法。 示例代码： 123456789101112interface Named&#123; public Integer myFun(); default String getName()&#123; return \"Hello World\"; &#125; static void show()&#123; System.out.println(\"Hi\"); &#125;&#125; 7.新时间日期 API在旧版的 Java 中，日期时间 API 存在诸多问题，其中有： 非线程安全 − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。 设计很差 − Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。 时区处理麻烦 − 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。 使用 LocalDate 、LocalTime 、LocalDateTime LocalDate、LocalTime、LocalDateTime 类的实例是不可变的对象，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息。也不包含与时区相关的信息。 方法 描述 示例 now() 静态方法，根据当前时间创建对象 LocalDate localDate = LocalDate.now();LocalTime localTime = LocalTime.now();LocalDateTime localDateTime = LocalDateTime.now(); of() 静态方法，根据指定日期/时间创建对象 LocalDate localDate = LocalDate.of(2016, 10, 26);LocalTime localTime = LocalTime.of(02, 22, 56);LocalDateTime localDateTime = LocalDateTime.of(2016, 10,26, 12, 10, 55); plusDays, plusWeeks,plusMonths, plusYears 向当前 LocalDate 对象添加几天、几周、几个月、几年 minusDays, minusWeeks,minusMonths, minusYears 从当前 LocalDate 对象减去几天、几周、几个月、几年 plus, minus 添加或减少一个 Duration 或 Period withDayOfMonth,withDayOfYear,withMonth,withYear 将月份天数、年份天数、月份、年份修改为指定的值并返回新的LocalDate 对象 getDayOfMonth 获得月份天数(1-31) getDayOfYear 获得年份天数(1-366) getDayOfWeek 获得星期几(返回一个 DayOfWeek枚举值) getMonth 获得月份, 返回一个 Month 枚举值 getMonthValue 获得月份(1-12) getYear 获得年份 until 获得两个日期之间的 Period 对象，或者指定 ChronoUnits 的数字 isBefore, isAfter 比较两个 LocalDate isLeapYear 判断是否是闰年 Instant 时间戳 用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算 Duration 和 Period Duration: 用于计算两个“时间”间隔 Period: 用于计算两个“日期”间隔 日期的操纵 emporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下个周日”等操作。 TemporalAdjusters : 该类通过静态方法提供了大量的常用 TemporalAdjuster 的实现。 解析与格式化 java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法： 预定义的标准格式 语言环境相关的格式 自定义的格式 时区的处理 Java8 中加入了对时区的支持，带时区的时间为分别为：ZonedDate、ZonedTime、ZonedDateTime 其中每个时区都对应着 ID，地区ID都为 “{区域}/{城市}”的格式，例如 ：Asia/Shanghai 等 ZoneId：该类中包含了所有的时区信息 getAvailableZoneIds() : 可以获取所有时区时区信息 of(id) : 用指定的时区信息获取 ZoneId 对象 与传统日期处理的转换 类 To遗留类 From遗留类 java.time.Instantjava.util.Date Date.from(instant) date.toInstant() java.time.Instantjava.sql.Timestamp Timestamp.from(instant) timestamp.toInstant() java.time.ZonedDateTimejava.util.GregorianCalendar GregorianCalendar.from(zonedDateTime) cal.toZonedDateTime() java.time.LocalDatejava.sql.Time Date.valueOf(localDate) date.toLocalDate() java.time.LocalTimejava.sql.Time Date.valueOf(localDate) date.toLocalTime() java.time.LocalDateTimejava.sql.Timestamp Timestamp.valueOf(localDateTime) timestamp.toLocalDateTime() java.time.ZoneIdjava.util.TimeZone Timezone.getTimeZone(id) timeZone.toZoneId() java.time.format.DateTimeFormatterjava.text.DateFormat formatter.toFormat() 无 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126@Test public void test1()&#123; LocalDateTime ldt = LocalDateTime.now(); System.out.println(ldt); System.out.println(ldt.getYear()); System.out.println(ldt.getMonthValue()); System.out.println(ldt.getDayOfMonth()); System.out.println(ldt.getHour()); System.out.println(ldt.getMinute()); System.out.println(ldt.getSecond()); LocalDateTime ldt2 = ldt.plusYears(2); System.out.println(ldt2); LocalDateTime ldt3 = ldt.plusMonths(2); System.out.println(ldt3); &#125; @Test public void test2()&#123; Instant ins = Instant.now(); System.out.println(ins);// 默认获取UTC时区 OffsetDateTime odt = ins.atOffset(ZoneOffset.ofHours(8)); System.out.println(odt); System.out.println(odt.toEpochSecond()); Instant ins2 = Instant.ofEpochSecond(1000); System.out.println(ins2); &#125; @Test public void test3()&#123; Instant ins1 = Instant.now(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Instant ins2 = Instant.now(); Duration duration = Duration.between(ins1, ins2); System.out.println(duration.toMillis()); System.out.println(\"======================================\"); LocalTime lt1 = LocalTime.now(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; LocalTime lt2 = LocalTime.now(); System.out.println(Duration.between(lt1, lt2).toMillis()); &#125; @Test public void test4()&#123; LocalDate ld1 = LocalDate.of(2015, 6, 1); LocalDate ld2 = LocalDate.now(); Period period = Period.between(ld1, ld2); System.out.println(period); System.out.println(period.getYears()); System.out.println(period.getMonths()); System.out.println(period.getDays()); &#125; // TemporalAdjuster: 时间校正器 @Test public void test5()&#123; LocalDateTime ldt = LocalDateTime.now(); System.out.println(ldt); LocalDateTime ldt2 = ldt.withDayOfMonth(10); System.out.println(ldt2); LocalDateTime ldt3 = ldt.with(TemporalAdjusters.next(DayOfWeek.SUNDAY)); System.out.println(ldt3); // 自定义：下一个工作日 LocalDateTime ldt5 = ldt.with((l) -&gt; &#123; LocalDateTime ldt4 = (LocalDateTime) l; DayOfWeek dow = ldt4.getDayOfWeek(); if (dow.equals(DayOfWeek.FRIDAY)) &#123; return ldt4.plusDays(3); &#125; else if (dow.equals(DayOfWeek.SATURDAY)) &#123; return ldt4.plusDays(2); &#125; else &#123; return ldt4.plusDays(1); &#125; &#125;); System.out.println(ldt5); &#125; // DateTimeFormatter @Test public void test6()&#123; DateTimeFormatter dtf = DateTimeFormatter.ISO_DATE; LocalDateTime ldt = LocalDateTime.now(); String strDate = ldt.format(dtf); System.out.println(strDate); DateTimeFormatter dtf2 = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日 HH:mm:ss\"); String strDate2 = ldt.format(dtf2); System.out.println(strDate2); LocalDateTime newDate = ldt.parse(strDate2, dtf2); System.out.println(newDate); &#125; // ZonedDate、ZonedTime、ZonedDateTime @Test public void test7()&#123; LocalDateTime ldt = LocalDateTime.now(ZoneId.of(\"Asia/Shanghai\")); System.out.println(ldt); ZonedDateTime zdt = ldt.atZone(ZoneId.of(\"Asia/Shanghai\")); System.out.println(zdt); &#125; 8.其他新特性重复注解与类型注解 Java 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。","tags":[{"name":"java","slug":"java","permalink":"https://sunshine-zwq.github.io/tags/java/"},{"name":"java8","slug":"java8","permalink":"https://sunshine-zwq.github.io/tags/java8/"},{"name":"Lambda","slug":"Lambda","permalink":"https://sunshine-zwq.github.io/tags/Lambda/"},{"name":"Stream","slug":"Stream","permalink":"https://sunshine-zwq.github.io/tags/Stream/"}]},{"title":"JS模块化","date":"2020-09-12T16:00:00.000Z","path":"2020/09/13/JS模块化/","text":"简介 什么是模块? 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起 块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信 一个模块的组成 数据—&gt;内部的属性 操作数据的行为—&gt;内部的函数 模块化 编码时是按照模块一个一个编码的, 整个项目就是一个模块化的项目 模块化的好处 避免命名冲突（减少命名空间污染） 更好的分离，按需加载 更高复用性 高可维护性 CommonJS 说明 每个文件都可当作一个模块 在服务器端：模块的加载是运行时同步加载的 在浏览器端：模块需要提前编译打包处理 基本语法 暴露模块 module.exports = value exports.xxx = value 引入模块 require(xxx) 第三方模块：xxx为模块名 自定义模块：xxx为模块文件路径 基于服务端应用（Node.js） 项目结构 12345678910|-modules |-module1.js |-module2.js |-module3.js|-app.js|-package.json &#123; &quot;name&quot;: &quot;commonJS-node&quot;, &quot;version&quot;: &quot;1.0.0&quot; &#125; 下载第三方模块 npm install uniq –save 模块化编码 module1.js12345module.exports = &#123; foo() &#123; console.log('moudle1 foo()') &#125;&#125; module2.js123module.exports = function () &#123; console.log('module2()')&#125; module3.js1234567exports.foo = function () &#123; console.log('module3 foo()')&#125;exports.bar = function () &#123; console.log('module3 bar()')&#125; app.js 12345678910111213141516171819202122/** 1. 定义暴露模块: module.exports = value; exports.xxx = value; 2. 引入模块: var module = require(模块名或模块路径); */\"use strict\";//引用模块let module1 = require('./modules/module1')let module2 = require('./modules/module2')let module3 = require('./modules/module3')let uniq = require('uniq')//使用模块module1.foo()module2()module3.foo()module3.bar()console.log(uniq([1, 3, 1, 4, 3])) 通过node运行app.js 命令: node app.js 工具: 右键–&gt;运行 基于浏览器端应用（Browserify ） 项目结构12345678910111213|-js |-dist &#x2F;&#x2F;打包生成文件的目录 |-src &#x2F;&#x2F;源码所在的目录 |-module1.js |-module2.js |-module3.js |-app.js &#x2F;&#x2F;应用主源文件|-index.html|-package.json &#123; &quot;name&quot;: &quot;browserify-test&quot;, &quot;version&quot;: &quot;1.0.0&quot; &#125; 下载browserify 全局: npm install browserify -g 局部: npm install browserify –save-dev 定义模块代码 module1.js12345module.exports = &#123; foo() &#123; console.log('moudle1 foo()') &#125;&#125; module2.js123module.exports = function () &#123; console.log('module2()')&#125; module3.js1234567exports.foo = function () &#123; console.log('module3 foo()')&#125;exports.bar = function () &#123; console.log('module3 bar()')&#125; app.js (应用的主js)1234567891011121314//引用模块let module1 = require('./module1')let module2 = require('./module2')let module3 = require('./module3')let uniq = require('uniq')//使用模块module1.foo()module2()module3.foo()module3.bar()console.log(uniq([1, 3, 1, 4, 3])) 打包处理js: browserify js/src/app.js -o js/dist/bundle.js 页面使用引入: 1&lt;script type=\"text/javascript\" src=\"js/dist/bundle.js\"&gt;&lt;/script&gt; AMD（浏览器端） require.js 基本语法 定义暴露模块 定义没有依赖的模块：define(function(){return 模块}) 定义有依赖的模块：define([‘module1’, ‘module2’], function(m1, m2){return 模块}) 引入模块: require([‘module1’, ‘module2’], function(m1, m2){//使用模块对象}) 配置: 123456789101112131415161718192021require.config(&#123; //基本路径 baseUrl : 'js/', //标识名称与路径的映射 paths : &#123; '模块1' : 'modules/模块1', '模块2' : 'modules/模块2', 'angular' : 'libs/angular', 'angular-messages' : 'libs/angular-messages' &#125;, //非AMD的模块 shim : &#123; 'angular' : &#123; exports : 'angular' &#125;, 'angular-messages' : &#123; exports : 'angular-messages', deps : ['angular'] &#125; &#125;&#125;) 代码实现： 下载require.js, 并引入 官网: http://www.requirejs.cn/ github : https://github.com/requirejs/requirejs 将require.js导入项目: js/libs/require.js 项目结构 12345678|-js |-libs |-require.js |-modules |-alerter.js |-dataService.js |-main.js|-index.html 定义require.js的模块代码 dataService.js 123456789define(function () &#123; let msg = 'Hello world' function getMsg() &#123; return msg.toUpperCase() &#125; return &#123;getMsg&#125;&#125;) alerter.js 12345678910define(['dataService', 'jquery'], function (dataService, $) &#123; let name = 'Tom2' function showMsg() &#123; $('body').css('background', 'gray') alert(dataService.getMsg() + ', ' + name) &#125; return &#123;showMsg&#125;&#125;) 应用主(入口)js: main.js 1234567891011121314151617(function () &#123; //配置 requirejs.config(&#123; //基本路径 baseUrl: \"js/\", //模块标识名与模块路径映射 paths: &#123; \"alerter\": \"modules/alerter\", \"dataService\": \"modules/dataService\", &#125; &#125;) //引入使用模块 requirejs( ['alerter'], function(alerter) &#123; alerter.showMsg() &#125;)&#125;)() 页面使用模块: 1&lt;script data-main=\"js/main\" src=\"js/libs/require.js\"&gt;&lt;/script&gt; 使用第三方基于require.js的框架(jquery) 将jquery的库文件导入到项目: js/libs/jquery-1.10.1.js 在main.js中配置jquery路径 123paths: &#123; &#39;jquery&#39;: &#39;libs&#x2F;jquery-1.10.1&#39; &#125; 在alerter.js中使用jquery 12345678define([&#39;dataService&#39;, &#39;jquery&#39;], function (dataService, $) &#123; var name &#x3D; &#39;xfzhang&#39; function showMsg() &#123; $(&#39;body&#39;).css(&#123;background : &#39;red&#39;&#125;) alert(name + &#39; &#39;+dataService.getMsg()) &#125; return &#123;showMsg&#125;&#125;) 使用第三方不基于require.js的框架(angular) 将angular.js导入项目 js/libs/angular.js 在main.js中配置 1234567891011121314151617181920212223242526272829(function () &#123; require.config(&#123; //基本路径 baseUrl: \"js/\", //模块标识名与模块路径映射 paths: &#123; //第三方库 'jquery' : './libs/jquery-1.10.1', 'angular' : './libs/angular', //自定义模块 \"alerter\": \"./modules/alerter\", \"dataService\": \"./modules/dataService\" &#125;, /* 配置不兼容AMD的模块 exports : 指定与相对应的模块名对应的模块对象 */ shim: &#123; 'angular' : &#123; exports : 'angular' &#125; &#125; &#125;) //引入使用模块 require( ['alerter', 'angular'], function(alerter, angular) &#123; alerter.showMsg() console.log(angular); &#125;)&#125;)() CMD（浏览器端） sea.js 基本语法 定义暴露模块: 定义没有依赖的模块 1234define(function(require, exports, module)&#123; exports.xxx = value module.exports = value&#125;) 定义有依赖的模块 12345678910define(function(require, exports, module)&#123; //引入依赖模块(同步) var module2 = require('./module2') //引入依赖模块(异步) require.async('./module3', function (m3) &#123; &#125;) //暴露模块 exports.xxx = value&#125;) 引入使用模块 123456define(function (require) &#123; var m1 = require('./module1') var m4 = require('./module4') m1.show() m4.show()&#125;) 使用模块seajs.use([‘模块1’, ‘模块2’]) 代码实现： 下载sea.js, 并引入 官网: http://seajs.org/ github : https://github.com/seajs/seajs 将sea.js导入项目: js/libs/sea.js 创建项目结构 12345678910|-js |-libs |-sea.js |-modules |-module1.js |-module2.js |-module3.js |-module4.js |-main.js|-index.html 定义sea.js的模块代码 module1.js 1234567891011define(function (require, exports, module) &#123; //内部变量数据 var data = 'Hello world' //内部函数 function show() &#123; console.log('module1 show() ' + data) &#125; //向外暴露 exports.show = show&#125;) module2.js 12345define(function (require, exports, module) &#123; module.exports = &#123; msg: 'I Will Back' &#125;&#125;) module3.js 1234define(function (require, exports, module) &#123; const API_KEY = 'abc123' exports.API_KEY = API_KEY&#125;) module4.js 1234567891011121314define(function (require, exports, module) &#123; //引入依赖模块(同步) var module2 = require('./module2') function show() &#123; console.log('module4 show() ' + module2.msg) &#125; exports.show = show //引入依赖模块(异步) require.async('./module3', function (m3) &#123; console.log('异步引入依赖模块3 ' + m3.API_KEY) &#125;)&#125;) main.js : 主(入口)模块 123456define(function (require) &#123; var m1 = require('./module1') var m4 = require('./module4') m1.show() m4.show()&#125;) index.html: 12345678910111213141516&lt;!--使用seajs: 1. 引入sea.js库 2. 如何定义导出模块 : define() exports module.exports 3. 如何依赖模块: require() 4. 如何使用模块: seajs.use()--&gt;&lt;script type=\"text/javascript\" src=\"js/libs/sea.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; seajs.use('./js/modules/main')&lt;/script&gt; ​ ES6 ES6内置了模块化的实现 基本语法 定义暴露模块 : export 暴露一个对象: 1export default 对象 暴露多个: 123456export var xxx &#x3D; value1export let yyy &#x3D; value2var xxx &#x3D; value1let yyy &#x3D; value2export &#123;xxx, yyy&#125; 引入使用模块 : import default模块: 1import xxx from &#39;模块路径&#x2F;模块名&#39; 其它模块 12import &#123;xxx, yyy&#125; from &#39;模块路径&#x2F;模块名&#39;import * as module1 from &#39;模块路径&#x2F;模块名&#39; 问题: 所有浏览器还不能直接识别ES6模块化的语法 解决: 使用Babel将ES6—&gt;ES5(使用了CommonJS) —-浏览器还不能直接支行 使用Browserify—&gt;打包处理—-浏览器可以运行 代码实现： 定义package.json文件 1234&#123; \"name\" : \"es6-babel-browserify\", \"version\" : \"1.0.0\"&#125; 安装babel-cli, babel-preset-es2015和browserify npm install babel-cli browserify -g npm install babel-preset-es2015 –save-dev preset 预设(将es6转换成es5的所有插件打包) 定义.babelrc文件 123&#123; \"presets\": [\"es2015\"]&#125; 编码 js/src/module1.js 分别暴露 1234567export function foo() &#123; console.log('module1 foo()');&#125;export function bar() &#123; console.log('module1 bar()');&#125;export const DATA_ARR = [1, 3, 5, 1] js/src/module2.js 统一暴露 1234567891011let data = 'module2 data'function fun1() &#123; console.log('module2 fun1() ' + data);&#125;function fun2() &#123; console.log('module2 fun2() ' + data);&#125;export &#123;fun1, fun2&#125; js/src/module3.js 123456export default &#123; name: 'Tom', setName: function (name) &#123; this.name = name &#125;&#125; js/src/app.js 1234567891011121314151617import &#123;foo, bar&#125; from './module1'import &#123;DATA_ARR&#125; from './module1'import &#123;fun1, fun2&#125; from './module2'import person from './module3'import $ from 'jquery'$('body').css('background', 'red')foo()bar()console.log(DATA_ARR);fun1()fun2()person.setName('JACK')console.log(person.name); 编译 使用Babel将ES6编译为ES5代码(但包含CommonJS语法) : babel js/src -d js/lib 使用Browserify编译js : browserify js/lib/app.js -o js/lib/bundle.js 页面中引入测试 1&lt;script type=\"text/javascript\" src=\"js/lib/bundle.js\"&gt;&lt;/script&gt; 引入第三方模块(jQuery) 下载jQuery模块: npm install jquery@1 –save 在app.js中引入并使用 12import $ from 'jquery'$('body').css('background', 'red')","tags":[{"name":"js","slug":"js","permalink":"https://sunshine-zwq.github.io/tags/js/"},{"name":"js模块化","slug":"js模块化","permalink":"https://sunshine-zwq.github.io/tags/js%E6%A8%A1%E5%9D%97%E5%8C%96/"}]},{"title":"Node.js入门","date":"2020-09-05T16:00:00.000Z","path":"2020/09/06/Node.js入门/","text":"Node.js简介简介： (1).开发者：瑞安·达尔（Ryan Dahl） (2).Node.js是一个能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript运行环境。 (3).Node采用Google开发的V8引擎运行js代码，使用事件驱动、非阻塞和异步I/O模型等技术来提高性能，可优化应用程序的传输量和规模。 (4).Node大部分基本模块都用JavaScript编写。在Node出现之前，JS通常作为客户端程序设计语言使用，以JS写出的程序常在用户的浏览器上运行。 特点： (1).Node.js允许通过JS和一系列模块来编写服务器端应用和网络相关的应用。 (2).核心模块包括文件系统I/O、网络（HTTP、TCP、UDP、DNS、TLS/SSL等）、二进制数据流、加密算法、数据流等等。Node模块的API形式简单，降低了编程的复杂度。 (3).使用框架可以加速开发。常用的框架有Express.js、Socket.IO和Connect等。Node.js的程序可以在Microsoft Windows、Linux、Unix、Mac OS X等服务器上运行。 (4).Node.js也可以使用CoffeeScript、TypeScript、Dart语言，以及其他能够编译成JavaScript的语言编程。 用途： • Web服务API，比如REST• 实时多人游戏• 后端的Web服务，例如跨域、服务器端的请求• 基于Web的应用• 多客户端的通信，如即时通信 Node的基本使用使用node执行js： 1node hello.js CommonJS规范ECMAScript标准的缺陷：• 没有模块系统• 标准库较少• 没有标准接口• 缺乏管理系统 CommonJS简介：• CommonJS规范的提出，主要是为了弥补当前JavaScript没有模块化标准的缺陷。• CommonJS规范为JS指定了一个美好的愿景，希望JS能够在任何地方运行。 模块引用• 在规范中，定义了require()方法，这个方法接收模块标识，以此将一个模块引入到当前运行环境中。使用require()引入模块以后，该函数会返回一个对象，这个对象代表的就是引入的模块。 模块引用的示例代码： 1var math = require('math'); 注意： 1.require()可以传递一个文件的路径作为参数，node会自动根据该路径来引入外部模块 2.这里的路径，如果使用相对路径，必须以 ./ 或者 ../ 开头 3.路径的后缀.js可以省略 模块定义• 在运行环境中，提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一的导出的出口。• 在模块中还存在一个module对象，它代表模块自身，而exports是module的属性。• 在Node中一个文件就是一个模块。• 在Node中，每一个js文件中的js代码都是独立运行在一个函数中，而不是全局作用域，所以一个模块中的变量和函数在其他模块中无法访问。 使用exports向外暴露属性或方法示例： 123exports.x = 10;exports.xxx = function() &#123;&#125;;module.exports = &#123;&#125;; 模块标识• 模块标识其实就是模块的名字，也就是传递给require()方法的参数，它必须是符合驼峰命名法的字符串，或者是以 ./ 或 ../ 开头的相对路径、或者绝对路径。 模块分为两大类：核心模块、文件模块。 (1).核心模块 • 由node引擎提供的模块 • 核心模块的标识，就是模块的名字 (2).文件模块 • 由用户自己创建的模块 • 文件模块的标识，就是文件的路径（绝对路径，或相对路径） 在node中有一个全局变量global，它的作用和网页中window类似 • 在全局中创建的变量都会作为global的属性保存 • 在全局中创建的函数都会作为global的方法保存 当node在执行模块中的代码时，它会在代码首尾包裹一层函数，代码示例： 原始代码： 1234567891011121314var a = 10;/** 在node中有一个全局变量global，它的作用和网页中window类似 • 在全局中创建的变量都会作为global的属性保存 • 在全局中创建的函数都会作为global的方法保存 */// console.log(global.a);/** arguments.callee - 这个属性保存的是当前执行的函数对象 */console.log(arguments.callee + \"\"); 实际执行的代码： 12345678910111213141516function (exports, require, module, __filename, __dirname) &#123; var a = 10;/** 在node中有一个全局变量global，它的作用和网页中window类似 • 在全局中创建的变量都会作为global的属性保存 • 在全局中创建的函数都会作为global的方法保存 */// console.log(global.a);/** arguments.callee - 这个属性保存的是当前执行的函数对象 */console.log(arguments.callee + \"\");&#125; 实际上模块中的代码都是包装在一个函数中执行的，并且在函数执行时，同时传递进了5个实参： (1).exports：该对象用于将变量或函数暴露到外部 (2).require：函数，用来引入外部的模块 (3).module：代表的就是当前模块本身，exports就是module的属性 (4).__filename：当前模块的完整路径 (5).__dirname：当前模块所在文件夹的完整路径 exports和module.exports的区别： (1).通过exports只能使用 . 的方式来向外暴露内部变量，如exports.xxx = yyy (2).module.exports既可以通过 . 的方式，也可以直接赋值 ​ module.exports.xxx = yyy ​ module.exports = { ​ } NPM包 package• CommonJS的包规范允许我们将一组相关的模块组合到一起，形成一组完整的工具。• CommonJS的包规范由包结构和包描述文件两个部分组成 包结构：用于组织包中的各种文件 • 包实际上就是一个压缩文件，解压以后还原为目录。符合规范的目录，应该包含如下文件：– package.json 描述文件（必须要有）– bin 可执行二进制文件– lib js代码– doc 文档– test 单元测试 包描述文件：描述包的相关信息，以供外部读取分析 • 包描述文件用于表达非代码相关的信息，它是一个JSON格式的文件 – package.json，位于包的根目录下，是包的重要组成部分。• package.json中的字段– name、description、version、keywords、maintainers、contributors、bugs、licenses、repositories、dependencies、homepage、os、cpu、engine、builtin、directories、implements、scripts、author、bin、main、devDependencies。 NPM(Node Package Manager)• CommonJS包规范是理论，NPM是其中一种实践。• 对于Node而言，NPM帮助其完成了第三方模块的发布、安装和依赖等。借助NPM，Node与第三方模块之间形成了很好的一个生态系统。 NPM命令常用命令： • npm –v 查看npm的版本 • npm version 查看所有模块的版本 • npm search 包名 搜索包 • npm install / i 包名 安装包 • npm remove / r 包名 删除包 • npm install 包名 –save 安装包并添加到依赖中 • npm install 下载当前项目所依赖的包 • npm install 包名 -g 全局安装包（全局安装的包一般都是一些工具） • npm init 初始化项目生成package.json文件 • npm install 包名 –registry=地址 从镜像源安装 • npm config set registry 地址 设置镜像源 安装cnpm（使用淘宝镜像）: 1npm install -g cnpm --registry=https://registry.npm.taobao.org Node搜索包的流程： • Node在使用模块名字来引入模块时，它会首先在当前目录的node_modules中寻找是否包含有该模块 • 如果有则直接使用，如果没有则去上一级目录的node_modules中寻找 • 如果有则直接使用，如果没有则再去上一级目录寻找，直到找到为止 • 直到找到磁盘的根目录，如果依然没有，则报错 文件系统BufferBuffer(缓冲区) • 从结构上看Buffer非常像一个数组，它的元素为16进制的两位数。 • 实际上一个元素就表示内存中的一个字节。 • 实际上Buffer中的内存不是通过JavaScript分配的，而是在底层通过C++申请的。 • 也就是我们可以直接通过Buffer来创建内存中的空间。 Buffer的操作 • Buffer.from(str) 将一个字符串转换为buffer • Buffer.alloc(size) 创建一个指定大小的buffer • Buffer.allocUnsafe(size) 创建一个指定大小的buffer，但是可能包含敏感数据 • buf.toString() 将缓冲区的数据转换为字符串 写入操作• 向缓冲区中写入字符串 – buf.write(string[, offset[, length]][, encoding])• 替换指定索引位置的数据 – buf[index]• 将指定值填入到缓冲区的指定位置 – buf.fill(value[, offset[, end]][, encoding]) 读取操作• 将缓冲区中的内容，转换为一个字符串返回 – buf.toString([encoding[, start[, end]]])• 读取缓冲区指定索引的内容 – buf[index] 其他操作• 复制缓冲区 – buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])• 对缓冲区切片 – buf.slice([start[, end]])• 拼接缓冲区 – Buffer.concat(list[, totalLength]) fs（文件系统）• 在Node中，与文件系统的交互是非常重要的，服务器的本质就将本地的文件发送给远程的客户端• Node通过fs模块来和文件系统进行交互• 该模块提供了一些标准文件访问API来打开、读取、写入文件，以及与其交互。• 要使用fs模块，首先需要对其进行加载 – const fs = require(“fs”); 同步和异步调用• fs模块中所有的操作都有两种形式可供选择同步和异步。• 同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码。• 异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回。 打开和关闭文件• 打开文件 – fs.open(path, flags[, mode], callback) – fs.openSync(path, flags[, mode])• 关闭文件 – fs.close(fd, callback) – fs.closeSync(fd) 打开状态(mode)r 读取文件 , 文件不存在则出现异常r+ 读写文件 , 文件不存在则出现异常rs 在同步模式下打开文件用于读取rs+ 在同步模式下打开文件用于读写w 打开文件用于写操作 , 如果不存在则创建，如果存在则截断wx 打开文件用于写操作 , 如果 存在则打开失败w+ 打开文件用于读写 , 如果不存在则创建 , 如果存在则截断wx+ 打开文件用于读写 , 如果 存在则打开失败a 打开文件用于追加 , 如果不存在则创建ax 打开文件用于追加 , 如果路径存在则失败a+ 打开文件进行读取和追加 , 如果不存在则创建该文件ax+ 打开文件进行读取和追加 , 如果路径存在则失败 同步文件写入• fs.writeSync(fd, buffer, offset, length[, position])• fs.writeSync(fd, data[, position[, encoding]]) • 要完成同步写入文件，先需要通过openSync()打开文件来获取一个文件描述符，然后在通过writeSync()写入文件。 • 参数 – fd 文件描述符，通过openSync()获取 – data 要写入的数据（String 或 Buffer） – offset buffer写入的偏移量 – length 写入的长度 – position 写入的起始位置 – encoding 写入编码 示例代码： 123456789101112131415161718192021222324252627282930313233343536/** 文件系统（File System） - 文件系统简单来说就是通过Node来操作系统中的文件 - 使用文件系统，需要先引入fs模块，fs是核心模块，直接引入不需要下载 同步文件的写入 - 手动操作的步骤 1.打开文件 fs.openSync(path, flags[, mode]) - path 要打开的文件路径 - flags 打开文件要做的操作的类型 r 只读的 w 可写的 - mode 设置文件的操作权限，一般不传 返回值：该方法会返回一个文件的描述符作为结果，我们可以通过该描述符来对文件进行各种操作 2.向文件中写入内容 fs.writeSync(fd, string[, position[, encoding]]) - fd 文件的描述符，需要传递写入的文件的描述符 - string 要写入的内容 - position 写入的起始位置 - encoding 写入的编码，默认utf-8 3.保存并关闭文件 fs.close(fd) - fd 要关闭的文件的描述符 */var fs = require(\"fs\");// 打开文件var fd = fs.openSync(\"hello.txt\", \"w\");// 向文件中写入内容fs.writeSync(fd, \"今天天气真不错~~~\");// 关闭文件fs.closeSync(fd); 异步文件写入• fs.write(fd, buffer, offset, length[, position], callback)• fs.write(fd, data[, position[, encoding]], callback) • 要使用异步写入文件，先需要通过open()打开文件，然后在回调函数中通过write()写入。 • 参数： – fd 文件描述符 – data 要写入的数据（String 或 Buffer） – offset buffer写入的偏移量 – length 写入的长度 – position 写入的起始位置 – encoding 写入编码 示例代码： 12345678910111213141516171819202122232425262728293031323334/** 异步文件写入 fs.open(path, flags[, mode], callback) - 用来打开一个文件 - 异步调用的方法，结果都是通过回调函数的参数返回的 - 回调函数的两个参数： - err 错误对象，如果没有错误则为null - fd 文件的描述符 fs.write(fd, string[, position[, encoding]], callback) - 用来异步写入一个文件 fs.close(fd, callback) - 用来关闭文件 */var fs = require(\"fs\");// 打开文件fs.open(\"hello2.txt\", \"w\", function (err, fd) &#123; if(!err)&#123; fs.write(fd, \"这是异步写入的内容\", function (err) &#123; if(!err)&#123; console.log(\"写入成功~~~\"); &#125; // 关闭文件 fs.close(fd, function () &#123; if(!err)&#123; console.log(\"文件已关闭~~~\"); &#125; &#125;) &#125;) &#125;else&#123; console.log(err); &#125;&#125;) 简单文件写入• fs.writeFile(file, data[, options], callback)• fs.writeFileSync(file, data[, options]) • 参数： – file 文件路径 – data 被写入的内容，可以是String或Buffer – options 对象，包含属性（encoding、mode、flag） – callback 回调函数 示例代码： 12345678910111213141516171819202122/** 简单文件写入 fs.writeFile(file, data[, options], callback) fs.writeFileSync(file, data[, options]) - file 要操作的文件路径 - data 要写入的数据 - options 选项，可以对写入进行一些设置 - flag r 只读 w 可写 a 追加 - callback 当写入完成以后执行的函数 */var fs = require(\"fs\");fs.writeFile(\"hello3.txt\", \"这是通过writeFile写入的内容\", &#123;flag: \"a\"&#125;, function (err) &#123; if(!err)&#123; console.log(\"写入成功~~~\"); &#125;else&#123; console.log(err); &#125;&#125;) 流式文件写入• 往一个文件中写入大量数据时，最好的方法之一是使用流。• 若要将数据异步传送到文件，首需要使用以下语法创建一个Writable对象： – fs.createWriteStream(path[, options]) • path 文件路径 • options {encoding:””,mode:””,flag:””}• 一旦你打开了Writable文件流，就可以使用write()方法来写入它，写入完成后，再调用end()方法来关闭流。 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738/** 同步、异步、简单文件的写入，都不适合大文件的写入，性能较差，容易导致内存溢出 */var fs = require(\"fs\");// 流式文件写入// 创建一个可写流/** fs.createWriteStram(path[, options]) - 可以用来创建一个可写流 - path 文件路径 - options 配置的参数 */var ws = fs.createWriteStream(\"hello5.txt\");// 可以通过监听流的open和close事件来监听流的打开和关闭/** on(事件字符串， 回调函数) - 可以为对象绑定一个事件 once(事件字符串， 回调函数) - 可以为对象绑定一个一次性的事件，该事件将会在触发一次之后自动失效 */ws.once(\"open\", function () &#123; console.log(\"流打开了~\")&#125;)ws.once(\"close\", function () &#123; console.log(\"流关闭了~\")&#125;)// 通过ws向文件中输出内容ws.write(\"通过可写流写入文件的内容1\");ws.write(\"通过可写流写入文件的内容2\");ws.write(\"通过可写流写入文件的内容3\");ws.write(\"通过可写流写入文件的内容4\");ws.write(\"通过可写流写入文件的内容5\");// 关闭流ws.end(); 同步文件读取• fs.readSync(fd, buffer, offset, length, position) – 参数： • fd 文件描述符 • buffer 读取文件的缓冲区 • offset buffer的开始写入的位置 • length 要读取的字节数 • position 开始读取文件的位置 异步文件读取• fs.read(fd, buffer, offset, length, position, callback) – 参数： • fd 文件描述符 • buffer 读取文件的缓冲区 • offset buffer的开始写入的位置 • length 要读取的字节数 • position 开始读取文件的位置 • callback 回调函数 参数err , bytesRead , buffer 简单文件读取• fs.readFile(file[, options], callback)• fs.readFileSync(file[, options]) – 参数： • file 文件路径或文件描述符 • options – encoding 默认 = null – flag 默认 = ‘r’ • callback 回调函数，有两个参数err 、data 示例代码： 12345678910111213141516171819202122232425/** 简单文件读取 fs.readFile(path[, options], callback) fs.readFileSync(path[, options]) - path 要读取的文件路径 - options 读取的选项 - callback 回调函数，通过回调函数将读取到内容返回(err, data) err 错误对象 data 读取到的数据，会返回一个Buffer */var fs = require(\"fs\");fs.readFile(\"hello3.txt\", function (err, data) &#123; if(!err)&#123; console.log(data.toString()) // 将data写入到文件中 fs.writeFile(\"copyOf_hello3.txt\", data, function (err) &#123; if(!err)&#123; console.log(\"文件写入成功\"); &#125;else&#123; console.log(err); &#125; &#125;) &#125;&#125;) 流式文件读取• 从一个文件中读取大量的数据时，最好的方法之一就是流式读取，这样将把一个文件作为Readable流的形式打开。• 要从异步从文件传输数据，首先需要通过以下语法创建一个Readable流对象： – fs.createReadStream(path[, options]) • path 文件路径 • options {encoding:””,mode:””,flag:””}• 当你打开Readable文件流以后，可以通过readable事件和read()请求，或通过data事件处理程序轻松地从它读出。 示例代码： 1234567891011121314151617181920212223242526272829303132/** 流式文件读取也适用于一些比较大的文件，可以分多次将文件读取到内存中 */var fs = require(\"fs\");// 创建一个可读流var rs = fs.createReadStream(\"avatar.jpg\");// 创建一个可写流var ws = fs.createWriteStream(\"test.jpg\");// 监听流的打开和关闭rs.once(\"open\", function () &#123; console.log(\"可读流打开了~\")&#125;)rs.once(\"close\", function () &#123; console.log(\"可读流关闭了~\"); // 数据读取完毕，关闭可写流 ws.end();&#125;)ws.once(\"open\", function () &#123; console.log(\"可写流打开了~\")&#125;)ws.once(\"close\", function () &#123; console.log(\"可写流关闭了~\")&#125;)// 如果要读取一个可读流中的数据，必须要为可读流绑定一个data事件，data事件绑定完毕，它会自动开始读取数据rs.on(\"data\", function (data) &#123; console.log(data); // 将读取到的数据写入到可写流中 ws.write(data);&#125;) 利用pipe()实现更简洁的文件复制： 123456789var fs = require(\"fs\");// 创建一个可读流var rs = fs.createReadStream(\"avatar.jpg\");// 创建一个可写流var ws = fs.createWriteStream(\"test.jpg\");// pipe()可以将可读流中的内容，直接输出到可写流中rs.pipe(ws); 其他操作• 验证路径是否存在 – fs.exists(path，callback) – fs.existsSync(path) • 获取文件信息 – fs.stat(path, callback) – fs.statSync(path) • 删除文件 – fs.unlink(path, callback) – fs.unlinkSync(path) • 列出文件 – fs.readdir(path[, options], callback) – fs.readdirSync(path[, options]) • 截断文件 – fs.truncate(path, len, callback) – fs.truncateSync(path, len) • 建立目录 – fs.mkdir(path[, mode], callback) – fs.mkdirSync(path[, mode]) • 删除目录 – fs.rmdir(path, callback) – fs.rmdirSync(path) • 重命名文件和目录（可实现剪切的功能） – fs.rename(oldPath, newPath, callback) – fs.renameSync(oldPath, newPath) • 监视文件更改写入 – fs.watchFile(filename[, options], listener)","tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sunshine-zwq.github.io/tags/jQuery/"},{"name":"Node.js","slug":"Node-js","permalink":"https://sunshine-zwq.github.io/tags/Node-js/"}]},{"title":"jQuery包裹节点方法wrap()、wrapAll()、wrapInner()的区别","date":"2020-08-28T16:00:00.000Z","path":"2020/08/29/jQuery包裹节点方法wrap()、wrapAll()、wrapInner()的区别/","text":"1.wrap()方法原始DOM代码： 1234&lt;div id=\"container\"&gt; &lt;div&gt;姓名：小明&lt;/div&gt; &lt;div&gt;年龄：20岁&lt;/div&gt;&lt;/div&gt; 使用wrap()： 1$(\"#container\").wrap('&lt;div class=\"wrapper\"&gt;&lt;/div&gt;'); 处理后DOM代码： 123456&lt;div class=\"wrapper\"&gt; &lt;div id=\"container\"&gt; &lt;div&gt;姓名：小明&lt;/div&gt; &lt;div&gt;年龄：20岁&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 效果：给$选择器的所有元素外部包裹一层wrapper 2.wrapAll()方法原始DOM代码： 12345&lt;div id=\"container\"&gt; &lt;p&gt;姓名：小明&lt;/p&gt; &lt;p&gt;年龄：20岁&lt;/p&gt; &lt;div&gt;性别：男&lt;div&gt;&lt;/div&gt; 使用wrapAll()： 1$(\"p\").wrapAll('&lt;div class=\"wrapper\"&gt;&lt;/div&gt;'); 处理后DOM代码： 1234567&lt;div id=\"container\"&gt; &lt;div class=\"wrapper\"&gt; &lt;p&gt;姓名：小明&lt;/p&gt; &lt;p&gt;年龄：20岁&lt;/p&gt; &lt;/div&gt; &lt;div&gt;性别：男&lt;div&gt;&lt;/div&gt; 效果：给$选择器的全部匹配元素的外部包裹一层wrapper 3.wrapInner()方法原始DOM代码： 1234&lt;div id=\"container\"&gt; &lt;div&gt;姓名：小明&lt;/div&gt; &lt;div&gt;年龄：20岁&lt;/div&gt;&lt;/div&gt; 使用wrapInner()： 1$(\"#container\").wrapInner('&lt;div class=\"wrapper\"&gt;&lt;/div&gt;'); 处理后DOM代码： 123456&lt;div id=\"container\"&gt; &lt;div class=\"wrapper\"&gt; &lt;div&gt;姓名：小明&lt;/div&gt; &lt;div&gt;年龄：20岁&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 效果：给$选择器的所有元素内部包裹一层wrapper","tags":[{"name":"前端","slug":"前端","permalink":"https://sunshine-zwq.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"jQuery","slug":"jQuery","permalink":"https://sunshine-zwq.github.io/tags/jQuery/"}]},{"title":"用apache的ftpserver搭建FTP服务器","date":"2020-08-22T16:00:00.000Z","path":"2020/08/23/用apache的ftpserver搭建FTP服务器/","text":"maven依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.ftpserver&lt;/groupId&gt; &lt;artifactId&gt;ftpserver-core&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt; 主要代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import org.apache.ftpserver.FtpServer;import org.apache.ftpserver.FtpServerFactory;import org.apache.ftpserver.ftplet.Authority;import org.apache.ftpserver.listener.ListenerFactory;import org.apache.ftpserver.usermanager.impl.BaseUser;import org.apache.ftpserver.usermanager.impl.WritePermission;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.ArrayList;import java.util.List;/** * 搭建ftp服务器 * @author zhuwq * @date 2020/8/21 17:27 */public class MyFtpServer &#123; private static Logger logger = LoggerFactory.getLogger(MyFtpServer.class); /** * 启动FTP服务 * @param port 端口 * @param username ftp用户名 * @param password ftp用户密码 * @param homeDirectory 主页目录 * @return */ public static boolean startServer(int port, String username, String password, String homeDirectory)&#123; logger.info(\"MyFtpServer.startServer[port:&#123;&#125;,username:&#123;&#125;,password:&#123;&#125;,homeDirectory:&#123;&#125;]\", port, username, password, homeDirectory); try&#123; FtpServerFactory serverFactory = new FtpServerFactory(); ListenerFactory factory = new ListenerFactory(); //设置监听端口 factory.setPort(port); //替换默认监听 serverFactory.addListener(\"default\", factory.createListener()); //用户名 BaseUser user = new BaseUser(); user.setName(username); //密码 如果不设置密码就是匿名用户 user.setPassword(password); //用户主目录 user.setHomeDirectory(homeDirectory); List&lt;Authority&gt; authorities = new ArrayList&lt;Authority&gt;(); //增加写权限 authorities.add(new WritePermission()); user.setAuthorities(authorities); //增加该用户 serverFactory.getUserManager().save(user); FtpServer server = serverFactory.createServer(); server.start(); logger.info(\"MyFtpServer.startServer success!!!\"); return true; &#125;catch (Exception e)&#123; e.printStackTrace(); logger.error(e.getMessage(), e); return false; &#125; &#125;&#125; 测试代码1234567public static void main(String[] args) &#123; int port = 21; String username = \"admin\"; String password = \"123456\"; String homeDirectory = \"E:\\\\FTPServer\"; MyFtpServer.startServer(port, username, password, homeDirectory); &#125; 参考链接：https://blog.csdn.net/fengsheng5210/article/details/78140746","tags":[{"name":"java","slug":"java","permalink":"https://sunshine-zwq.github.io/tags/java/"},{"name":"ftp","slug":"ftp","permalink":"https://sunshine-zwq.github.io/tags/ftp/"}]},{"title":"json转换","date":"2020-07-11T16:00:00.000Z","path":"2020/07/12/json转换/","text":"fastjsonjson字符串转JSONObject1JSONObject jsonObject = JSON.parseObject(json); json字符串转对象1Student student = JSONObject.parseObject(json, Student.class); json字符串转List1List&lt;Student&gt; studentList = JSONObject.parseArray(json, Student.class); json字符串转Map1Map&lt;String,String&gt; map = JSONObject.parseObject(json, Map.class); 对象转json字符串1String json = JSON.toJSONString(obj);","tags":[{"name":"json","slug":"json","permalink":"https://sunshine-zwq.github.io/tags/json/"}]},{"title":"ECMAScript入门","date":"2020-03-18T16:43:38.000Z","path":"2020/03/19/ECMAScript入门/","text":"基本介绍123456789101112131. 它是一种由ECMA组织（前身为欧洲计算机制造商协会）制定和发布的脚本语言规范2. 而我们学的 JavaScript 是ECMA的实现, 但术语ECMAScript和JavaScript平时表达同一个意思3. JS包含三个部分： 1). ECMAScript（核心） 2). 扩展&#x3D;&#x3D;&gt;浏览器端 * BOM（浏览器对象模型） * DOM（文档对象模型） 3). 扩展&#x3D;&#x3D;&gt;服务器端 * Node4. ES的几个重要版本 * ES5 : 09年发布 * ES6(ES2015) : 15年发布, 也称为ECMA2015 * ES7(ES2016) : 16年发布, 也称为ECMA2016 (变化不大) ES5严格模式1234567891011121314151. 理解: * 除了正常运行模式(混杂模式)，ES5添加了第二种运行模式：&quot;严格模式&quot;（strict mode）。 * 顾名思义，这种模式使得Javascript在更严格的语法条件下运行2. 目的&#x2F;作用 * 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 * 消除代码运行的一些不安全之处，为代码的安全运行保驾护航 * 为未来新版本的Javascript做好铺垫3. 使用 * 在全局或函数的第一条语句定义为: &#39;use strict&#39;; * 如果浏览器不支持, 只解析为一条简单的语句, 没有任何副作用4. 语法和行为改变 * 必须用var声明变量 * 禁止自定义的函数中的this指向window * 创建eval作用域 * 对象不能有重名的属性 示例代码： 12345678910111213141516171819202122&lt;script type=\"text/javascript\"&gt; 'use strict'; // username = 'kobe'; var username = 'kobe'; console.log(username); function Person (name, age) &#123; this.name = name; this.age = age; &#125; // Person('kobe', 41); new Person('kobe', 41); var str = 'NBA'; eval('var str = \"CBA\"; alert(str)'); alert(str); var obj = &#123; username: 'kobe', // username: 'wade' &#125;&lt;/script&gt; JSON对象12341. JSON.stringify(obj&#x2F;arr) * js对象(数组)转换为json对象(数组)2. JSON.parse(json) * json对象(数组)转换为js对象(数组) Object扩展12345678910111213ES5给Object扩展了一些静态方法, 常用的2个:1. Object.create(prototype, [descriptors]) * 作用: 以指定对象为原型创建新的对象 * 为新的对象指定新的属性, 并对属性进行描述 - value : 指定值 - writable : 标识当前属性值是否是可修改的, 默认为false - configurable: 标识当前属性是否可以被删除 默认为false - enumerable： 标识当前属性是否能用for in 枚举 默认为false2. Object.defineProperties(object, descriptors) * 作用: 为指定对象定义扩展多个属性 * get ：用来获取当前属性值的回调函数（需要取值时才会调用，“惰性求值”） * set ：修改当前属性值得触发的回调函数，并且实参即为修改后的值 * 存取器属性：setter,getter一个用来存值，一个用来取值 示例代码： 12345678910111213141516171819202122232425262728293031323334353637var obj = &#123;username: 'damu', age: 30&#125;;var obj1 = &#123;&#125;;obj1 = Object.create(obj, &#123; sex: &#123; value: '男', writable: true, configurable: true, enumerable: true &#125;&#125;);console.log(obj1.sex);obj1.sex = '女';console.log(obj1.sex);// delete obj1.sex;console.log(obj1);for(var i in obj1)&#123; console.log(i);&#125;var obj2 = &#123;firstName: 'kobe', lastName: 'bryant'&#125;;Object.defineProperties(obj2, &#123; fullName: &#123; get: function()&#123;// 获取扩展属性的值（获取扩展属性值时get会自动调用） return this.firstName + ' ' + this.lastName; &#125;, set: function(data)&#123;// 监听扩展属性，当扩展属性发生变化的时候会自动调用（变化后的值作为实参传入） var names = data.split(' '); this.firstName = names[0]; this.lastName = names[1]; &#125; &#125;&#125;)console.log(obj2.fullName);obj2.fullName = 'tim duncan';console.log(obj2.fullName);console.log(obj2.lastName); 123对象本身的两个方法* get propertyName()&#123;&#125; 用来得到当前属性值的回调函数* set propertyName()&#123;&#125; 用来监视当前属性值变化的回调函数 示例代码： 123456789101112131415var obj = &#123; firstName: 'curry', lastName: 'stephen', get fullName()&#123; return this.firstName + ' ' + this.lastName; &#125;, set fullName(data)&#123; var names = data.split(' '); this.firstName = names[0]; this.lastName = names[1]; &#125;&#125;;console.log(obj);obj.fullName = 'kobe bryant';console.log(obj.fullName); Array扩展123451. Array.prototype.indexOf(value) : 得到值在数组中的第一个下标2. Array.prototype.lastIndexOf(value) : 得到值在数组中的最后一个下标3. Array.prototype.forEach(function(item, index)&#123;&#125;) : 遍历数组4. Array.prototype.map(function(item, index)&#123;&#125;) : 遍历数组返回一个新的数组，返回加工之后的值5. Array.prototype.filter(function(item, index)&#123;&#125;) : 遍历过滤出一个新的子数组， 返回条件为true的值 示例代码： 12345678910111213141516171819202122232425/* 需求: 1. 输出第一个6的下标 2. 输出最后一个6的下标 3. 输出所有元素的值和下标 4. 根据arr产生一个新数组,要求每个元素都比原来大10 5. 根据arr产生一个新数组, 返回的每个元素要大于4 */var arr = [2,4,3,1,2,6,5,4];console.log(arr.indexOf(4));console.log(arr.lastIndexOf(4));arr.forEach(function(item, index)&#123; console.log(item, index);&#125;)var arr1 = arr.map(function (item, index) &#123; return item + 10;&#125;)console.log(arr1);var arr2 = arr.filter(function (item, index) &#123; return item &gt; 4;&#125;)console.log(arr2); Function扩展1234561. Function.prototype.bind(obj) : * 作用: 将函数内的this绑定为obj, 并将函数返回2. 面试题: 区别bind()与call()和apply()? * 都能指定函数中的this * call()&#x2F;apply()是立即调用函数 * bind()是将函数返回 示例代码： 123456789101112131415161718192021var obj = &#123;username: 'kobe'&#125;;function foo(data)&#123; console.log(this, data);&#125;// 直接调用foo方法打印的this是Window// foo();// call和apply的方法作用一样，区别在于传参的方式foo.call(obj, 33);// 直接从第2个参数开始，依次传入foo.apply(obj, [33]);// 第二个参数必须是数组，参数放在数组里// bind的特点：绑定完this不会立即调用当前的函数，而是将函数返回var bar = foo.bind(obj);bar();// bind的传参方式和call一样foo.bind(obj, 33)();// 应用举例setTimeout(function()&#123; console.log(this);&#125;.bind(obj), 1000); ES6（常用）let关键字1234567891. 作用: * 与var类似, 用于声明一个变量2. 特点: * 在块作用域内有效 * 不能重复声明 * 不会预处理（即不能在声明之前使用，会抛出异常，而var在声明前使用值是undefined）, 不存在提升3. 应用: * 循环遍历加监听 * 使用let取代var是趋势 示例代码： 1234567891011121314151617181920212223242526272829303132333435// console.log(username);let username = 'kobe';// let username = 'wade';console.log(username);let btns = document.getElementsByTagName('button');for(var i = 0; i &lt; btns.length; i++)&#123; var btn = btns[i]; btn.onclick = function () &#123; // 打印出来的都是3 alert(i); &#125;&#125;// 解决方法1：用闭包函数btns = document.getElementsByTagName('button');for(var i = 0; i &lt; btns.length; i++)&#123; var btn = btns[i]; (function(i)&#123; btn.onclick = function () &#123; // 打印出来的都是3 alert(i); &#125; &#125;)(i)&#125;// 解决方法2：用let关键字btns = document.getElementsByTagName('button');for(let i = 0; i &lt; btns.length; i++)&#123; var btn = btns[i]; btn.onclick = function () &#123; // 打印出来的都是3 alert(i); &#125;&#125; const关键字12345671. 作用: * 定义一个常量2. 特点: * 不能修改 * 其它特点同let3. 应用: * 保存不用改变的数据 解构赋值123456781. 理解: * 从对象或数组中提取数据, 并赋值给变量(多个)2. 对象的解构赋值 let &#123;n, a&#125; &#x3D; &#123;n:&#39;tom&#39;, a:12&#125;3. 数组的解构赋值 let [a,b] &#x3D; [1, &#39;atguigu&#39;];4. 用途 * 给多个形参赋值 示例代码： 1234567891011121314let obj = &#123;username: 'kobe', age: 39&#125;;// let username = obj.username;// let age = obj.age;let &#123;username, age&#125; = obj;console.log(username, age);let arr = [1,3,5,'abc',true];let [,,a,b] = arr;console.log(a, b);function foo(&#123;username, age&#125;)&#123;// &#123;username, age&#125; = obj console.log(username, age);&#125;foo(obj); 模板字符串1231. 模板字符串 : 简化字符串的拼接 * 模板字符串必须用 &#96;&#96; 包含 * 变化的部分使用$&#123;xxx&#125;定义 示例代码： 12345let obj = &#123;username: 'kobe', age: 39&#125;;let str = '我的名字叫：' + obj.username + '，我今年的年龄是：' + obj.age;console.log(str);str = `我的名字叫：$&#123;obj.username&#125;，我今年的年龄是：$&#123;obj.age&#125;`;console.log(str); 简化的对象写法1234567891011简化的对象写法* 省略同名的属性值* 省略方法的function* 例如: let x &#x3D; 1; let y &#x3D; 2; let point &#x3D; &#123; x, y, setX (x) &#123;this.x &#x3D; x&#125; &#125;; 箭头函数123456789101112131415* 作用: 定义匿名函数* 基本语法: * 没有参数: () &#x3D;&gt; console.log(&#39;xxxx&#39;) * 一个参数: i &#x3D;&gt; i+2 * 大于一个参数: (i,j) &#x3D;&gt; i+j * 函数体不用大括号: 默认返回结果 * 函数体如果有多个语句, 需要用&#123;&#125;包围，若有需要返回的内容，需要手动返回* 使用场景: 多用来定义回调函数* 箭头函数的特点： 1、简洁 2、箭头函数没有自己的this，箭头函数的this不是调用的时候决定的，而是在定义的时候处在的对象就是它的this 3、扩展理解： 箭头函数的this看外层的是否有函数， 如果有，外层函数的this就是内部箭头函数的this， 如果没有，则this是window。 示例代码： 123456789101112131415161718192021222324252627282930313233// 不同传参的情况// 1、没有形参let fun = () =&gt; console.log('我是箭头函数');fun();// 2、只有1个形参，()可以省略let fun2 = a =&gt; console.log(a);fun2('aaa');// 3、两个及以上形参，()不能省略let fun3 = (x, y) =&gt; console.log(x, y);fun3(25, 36);// 不同函数体的情况// 1、函数体只有一条语句或是表达式的时候，&#123;&#125;可以省略。会自动返回语句执行的结果或是表达式的结果let fun4 = (x, y) =&gt; x + y;console.log(fun4(24, 36));// 2、函数体不止一条语句或表达式的情况下，&#123;&#125;不可以省略let fun5 = (x, y) =&gt; &#123; console.log(x, y); return x + y;&#125;console.log(fun5(35, 50));let obj = &#123; name: '箭头函数', // getName()&#123; getName: () =&gt; &#123; btn2.onclick = () =&gt; &#123; console.log(this); &#125; &#125;&#125;// 等价于 obj.getName = () =&gt; &#123;&#125;，所以this是Window对象obj.getName(); 三点运算符12345678910111213141516171819* 用途1. rest(可变)参数 * 用来取代arguments 但比 arguments 灵活,只能是最后部分形参参数 function fun(...values) &#123; console.log(arguments); arguments.forEach(function (item, index) &#123; console.log(item, index); &#125;); console.log(values); values.forEach(function (item, index) &#123; console.log(item, index); &#125;) &#125; fun(1,2,3);2. 扩展运算符 let arr1 &#x3D; [1,3,5]; let arr2 &#x3D; [2,...arr1,6]; console.log(arr2); console.log(...arr2); 形参默认值12345* 形参的默认值----当不传入参数的时候默认使用形参里的默认值function Point(x &#x3D; 1,y &#x3D; 2) &#123; this.x &#x3D; x; this.y &#x3D; y;&#125; Promise对象123456789101112131415161718192021222324252627282930313233341. 理解: * Promise对象: 代表了未来某个将要发生的事件(通常是一个异步操作) * 有了promise对象, 可以将异步操作以同步的流程表达出来, 避免了层层嵌套的回调函数(俗称&#39;回调地狱&#39;) * ES6的Promise是一个构造函数, 用来生成promise实例2. 使用promise基本步骤(2步): * 创建promise对象 let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123; &#x2F;&#x2F;初始化promise状态为 pending &#x2F;&#x2F;执行异步操作 if(异步操作成功) &#123; resolve(value);&#x2F;&#x2F;修改promise的状态为fullfilled &#125; else &#123; reject(errMsg);&#x2F;&#x2F;修改promise的状态为rejected &#125; &#125;) * 调用promise的then() promise.then( result &#x3D;&gt; console.log(result), errorMsg &#x3D;&gt; alert(errorMsg) )3. promise对象的3个状态 * pending: 初始化状态 * fullfilled: 成功状态 * rejected: 失败状态4. 应用: * 使用promise实现超时处理 * 使用promise封装处理ajax请求 let request &#x3D; new XMLHttpRequest(); request.onreadystatechange &#x3D; function () &#123; &#125; request.responseType &#x3D; &#39;json&#39;; request.open(&quot;GET&quot;, url); request.send(); 示例代码： 12345678910111213141516171819202122// 创建promise对象let promise = new Promise((resolve, reject) =&gt; &#123; // 初始化promise状态：pending: 初始化 console.log('111'); // 执行异步操作，通常是发送ajax请求、开启定时器 setTimeout(function () &#123; console.log('333'); // 根据异步任务的返回结果去修改promise状态 // 异步任务执行成功 resolve('哈哈');// 修改promise的状态为 fullfilled: 成功的状态 // 异步任务执行失败 // reject('555');// 修改promise的状态为 rejected: 失败的状态 &#125;, 2000);&#125;)console.log('222');promise.then((data) =&gt; &#123;// 成功的回调 console.log(data, '成功了！')&#125;, (error) =&gt; &#123;// 失败的回调 console.log(error, '失败了。。。')&#125;) 应用案例： 123456789101112131415161718192021222324252627282930313233343536373839404142// 定义获取新闻的函数function getNews(url)&#123; let promise = new Promise((resolve, reject) =&gt; &#123; // 状态：初始化 // 执行异步任务 // 创建xmlHttp实例对象 let xmlHttp = new XMLHttpRequest(); // 绑定监听 readyState xmlHttp.onreadystatechange = function()&#123; if(xmlHttp.readyState === 4)&#123; if(xmlHttp.status == 200)&#123;// 请求成功 // 修改状态 resolve(xmlHttp.responseText);// 修改promise的状态为成功的状态 &#125;else&#123;// 请求失败 reject('暂时没有新闻内容'); &#125; &#125; &#125; // open 设置请求的方式以及url xmlHttp.open('GET', url); // 发送 xmlHttp.send(); &#125;) return promise;&#125;getNews('http://localhost:3000/news?id=2').then((data) =&gt; &#123; console.log(data); // 发送请求获取评论内容准备url let commentsUrl = JSON.parse(data).commentsUrl; let url = 'http://localhost:3000' + commentsUrl; // 发送请求 return getNews(url);&#125;, (error) =&gt; &#123; console.log(error);&#125;).then((data) =&gt; &#123; console.log(data);&#125;, (error) =&gt; &#123;&#125;) Symbol123456789101112131415161718192021前言：ES5中对象的属性名都是字符串，容易造成重名，污染环境Symbol： 概念：ES6中的添加了一种原始数据类型symbol(已有的原始数据类型：String, Number, boolean, null, undefined, 对象) 特点： 1、Symbol属性对应的值是唯一的，解决命名冲突问题 2、Symbol值不能与其他数据进行计算，包括同字符串拼串 3、for in, for of遍历时不会遍历symbol属性。 使用： 1、调用Symbol函数得到symbol值 let symbol &#x3D; Symbol(); let obj &#x3D; &#123;&#125;; obj[symbol] &#x3D; &#39;hello&#39;; 2、传参标识 let symbol &#x3D; Symbol(&#39;one&#39;); let symbol2 &#x3D; Symbol(&#39;two&#39;); console.log(symbol);&#x2F;&#x2F; Symbol(&#39;one&#39;) console.log(symbol2);&#x2F;&#x2F; Symbol(&#39;two&#39;) 3、内置Symbol值 * 除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。 - Symbol.iterator * 对象的Symbol.iterator属性，指向该对象的默认遍历器方法 示例代码： 1234567891011121314151617181920// 创建Symbol属性值let symbol = Symbol();console.log(symbol);let obj = &#123;username: 'kobe', age: 39&#125;;obj[symbol] = 'hello';console.log(obj);// for in, for of遍历时不会遍历symbol属性for(let i in obj)&#123; console.log(i);&#125;let symbol2 = Symbol('one');let symbol3 = Symbol('two');console.log(symbol2 == symbol3);// falseconsole.log(symbol2, symbol3);// 可以去定义常量const Person_key = Symbol('person_key');console.log(Person_key); Iterator遍历器12345678910111213141516171819概念： iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制作用： 1、为各种数据结构，提供一个统一的、简便的访问接口； 2、使得数据结构的成员能够按某种次序排列 3、ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费。工作原理： - 创建一个指针对象(遍历器对象)，指向数据结构的起始位置。 - 第一次调用next方法，指针自动指向数据结构的第一个成员 - 接下来不断调用next方法，指针会一直往后移动，直到指向最后一个成员 - 每调用next方法返回的是一个包含value和done的对象，&#123;value: 当前成员的值,done: 布尔值&#125; * value表示当前成员的值，done对应的布尔值表示当前的数据的结构是否遍历结束。 * 当遍历结束的时候返回的value值是undefined，done值为false原生具备iterator接口的数据(可用for of遍历) 1、Array 2、arguments 3、set容器 4、map容器 5、String 。。。 实现模拟 Iterator 遍历器： 1234567891011121314151617// 模拟指针对象（遍历器对象）function myIterator(arr)&#123;// iterator接口 let nextIndex = 0;// 记录指针的位置 return &#123; next: function()&#123; return nextIndex &lt; arr.length ? &#123;value: arr[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125;&#125;// 准备一个数据let arr = [1, 4, 65, 'abc'];let iteratorObj = myIterator(arr);console.log(iteratorObj.next());console.log(iteratorObj.next());console.log(iteratorObj.next());console.log(iteratorObj.next());console.log(iteratorObj.next()); 示例代码： 12345678910111213141516let arr = [1, 4, 65, 'abc'];// 将iterator接口部署到指定的数据类型上，可以使用for of去循环遍历// 数组、字符串、arguments、set容器、map容器for(let i of arr)&#123; console.log(i);&#125;let str = 'abcdefg';for(let i of str)&#123; console.log(i);&#125;function fun()&#123; for(let i of arguments)&#123; console.log(i); &#125;&#125;fun(1,4,5,'abc'); 扩展： 1234567891011121314151617181920212223242526272829303132333435// 对象的Symbol.iterator属性，指向该对象的默认遍历器方法// 等同于在指定的数据内结构上部署了iterator接口，// 当使用for of去遍历某一个数据结构时，首先先去找Symbol.iterator，找到了就去遍历，没有找到的话不能遍历 ==》 xxx is not iterablelet targetData = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3, [Symbol.iterator]: function() &#123; let nextIndex = 0;// 记录指针的位置 return &#123; next: () =&gt; &#123; return nextIndex &lt; this.length ? &#123;value: this[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125; &#125;&#125;// 定义了Symbol.iterator之后，Object也可以用for of遍历了for(let i of targetData)&#123; console.log(i);&#125;// 用Symbol.iterator去迭代let numbers = [1,2,3,4,5];let iterator = numbers[Symbol.iterator]();console.log(iterator.next().value);console.log(iterator.next().value);// 使用三点运算符、解构赋值，默认去调用iterator接口let arr2 = [1, 6];let arr3 = [2, 3, 4, 5];arr2 = [1, ...arr3, 6];console.log(arr2);let [a, b] = arr2;console.log(a, b); Generator函数123456789101112131415161718Generator函数 概念： 1、ES6提供的解决异步编程的方案之一 2、Generator函数是一个状态机，内部封装了不同状态的数据， 3、用来生成遍历器对象 4、可暂停函数(惰性求值), yield可暂停，next方法可启动。每次返回的是yield后的表达式结果 特点： 1、function 与函数名之间有一个星号 2、内部用yield表达式来定义不同的状态 例如： function* generatorExample()&#123; let result &#x3D; yield &#39;hello&#39;; &#x2F;&#x2F; 状态值为hello yield &#39;generator&#39;; &#x2F;&#x2F; 状态值为generator &#125; 3、generator函数返回的是指针对象，而不会执行函数内部逻辑 4、调用next方法函数内部逻辑开始执行，遇到yield表达式停止，返回&#123;value: yield后的表达式结果&#x2F;undefined, done: false&#x2F;true&#125; 5、再次调用next方法会从上一次停止时的yield处开始，直到最后 6、yield语句返回结果通常为undefined， 当调用next方法时传参内容会作为启动时yield语句的返回值。 示例代码： 12345678910111213141516171819202122232425function* myGenerator()&#123; console.log('开始执行'); let result = yield 'hello'; console.log(result);// 打印结果==》传入的参数aaa console.log('暂停后，再次执行'); yield 'generator'; console.log('遍历完毕'); return '返回的结果';&#125;let mg = myGenerator();// 返回的是指针对象console.log(mg);console.log(mg.next());// &#123;value: \"hello\", done: false&#125;console.log(mg.next('传入的参数aaa'));// &#123;value: \"generator\", done: false&#125;console.log(mg.next());// &#123;value: \"返回的结果\", done: true&#125;// 对象的symbol.iterator属性 指向遍历器对象let obj = &#123;username: 'kobe', age: 39&#125;;obj[Symbol.iterator] = function* myTest()&#123; yield 1 yield 2 yield 3&#125;for(let i of obj)&#123; console.log(i);&#125; 应用案例： 12345678910111213141516171819202122/* * 需求： * 1、发送ajax请求获取新闻内容 * 2、新闻内容获取成功后再次发送请求，获取对应的新闻评论内容 * 3、新闻内容获取失败则不需要再次发送请求。 * */ function getNews(url)&#123; $.get(url, function (data)&#123; console.log(data); let url = 'http://localhost:3000' + data.commentsUrl; SX.next(url); &#125;) &#125; function* sendXml()&#123; let url = yield getNews('http://localhost:3000/news?id=3'); yield getNews(url); &#125; // 获取遍历器对象 let SX = sendXml(); SX.next(); async函数12345678910111213async函数(源自ES2017)概念： 真正意义上去解决异步回调的问题，同步流程表达异步操作本质： Generator的语法糖语法： async function foo()&#123; await 异步操作; await 异步操作； &#125;特点： 1、不需要像Generator去调用next方法，遇到await等待，当前的异步操作完成就往下执行 2、返回的总是Promise对象，可以用then方法进行下一步操作 3、async取代Generator函数的星号*，await取代Generator的yield 4、语意上更为明确，使用简单，经临床验证，暂时没有任何副作用 示例代码： 12345678910111213// async基本使用function foo()&#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, 2000); &#125;)&#125;async function test()&#123; console.log('开始执行', new Date().toTimeString()); await foo(); console.log('执行完毕。。。', new Date().toTimeString());&#125;test(); 应用案例： 12345678910111213141516171819// 获取新闻内容async function getNews(url)&#123; return new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; method: 'GET', url, success: data =&gt; resolve(data), error: error =&gt; reject(error) &#125;) &#125;)&#125;async function sendXml()&#123; let result = await getNews('http://localhost:3000/news?id=3'); console.log(result); result = await getNews('http://localhost:3000' + result.commentsUrl); console.log(result);&#125;sendXml(); class面向对象1234561. 通过class定义类&#x2F;实现类的继承2. 在类中通过constructor定义构造方法3. 通过new来创建类的实例4. 通过extends来实现类的继承5. 通过super调用父类的构造方法6. 重写从父类中继承的一般方法 示例代码： 12345678910111213141516171819202122232425262728293031// 定义一个人物的类class Person&#123; // 类的构造方法 constructor(name, age)&#123; this.name = name; this.age = age; &#125; // 类的一般方法 showName()&#123; console.log(this.name, this.age); &#125;&#125;let person = new Person('kobe', 39);console.log(person);person.showName();// 子类class StarPerson extends Person&#123; constructor(name, age, salary)&#123; super(name, age);// 调用父类的构造方法 this.salary = salary; &#125; // 子类的方法重写 showName()&#123; console.log(this.name, this.age, this.salary); &#125;&#125;let p1 = new StarPerson('wade', 36, 100000000);console.log(p1);p1.showName(); ModuleES6（其他）字符串扩展12341. includes(str) : 判断是否包含指定的字符串2. startsWith(str) : 判断是否以指定字符串开头3. endsWith(str) : 判断是否以指定字符串结尾4. repeat(count) : 重复指定次数 示例代码： 123456let str = 'abc';console.log(str.includes('t'));console.log(str.includes('a'));console.log(str.startsWith('a'));console.log(str.endsWith('f'));console.log(str.repeat(3));// abcabcabc 数值扩展1234561. 二进制与八进制数值表示法: 二进制用0b, 八进制用0o2. Number.isFinite(i) : 判断是否是有限大的数3. Number.isNaN(i) : 判断是否是NaN4. Number.isInteger(i) : 判断是否是整数5. Number.parseInt(str) : 将字符串转换为对应的数值6. Math.trunc(i) : 直接去除小数部分 示例代码： 123456789console.log(0b1010);// 10console.log(0o56);// 46console.log(Number.isFinite(Infinity));// falseconsole.log(Number.isNaN(NaN));// trueconsole.log(Number.isInteger(123.12));// falseconsole.log(Number.isInteger(123.0));// trueconsole.log(Number.parseInt('123abc222'));// 123console.log(Number.parseInt('abc222'));// NaNconsole.log(Math.trunc(123.12));// 123 数组扩展12341. Array.from(v) : 将伪数组对象或可遍历对象转换为真数组2. Array.of(v1, v2, v3) : 将一系列值转换成数组3. find(function(value, index, arr)&#123;return true&#125;) : 找出第一个满足条件返回true的元素4. findIndex(function(value, index, arr)&#123;return true&#125;) : 找出第一个满足条件返回true的元素下标 示例代码： 123456789101112131415161718let btns = document.getElementsByTagName('button');console.log(btns);Array.from(btns).forEach(function(item, index)&#123; console.log(item);&#125;)let arr = Array.of(1,3,'abc',true);console.log(arr);let arr2 = [2,3,4,2,5,7,3,6,5];let result = arr2.find(function(item, index)&#123; return item &gt; 4;&#125;)console.log(result);result = arr2.findIndex(function(item, index)&#123; return item &gt; 4;&#125;)console.log(result); Object扩展12345671. Object.is(v1, v2) * 判断2个数据是否完全相等（其实是用字符串比较）2. Object.assign(target, source1, source2..) * 将源对象的属性复制到目标对象上3. 直接操作 __proto__ 属性 let obj2 &#x3D; &#123;&#125;; obj2.__proto__ &#x3D; obj1; 示例代码： 12345678910111213141516console.log(0 == -0);// trueconsole.log(NaN == NaN);// falseconsole.log(Object.is(0, -0));// falseconsole.log(Object.is(NaN, NaN));// truelet obj = &#123;&#125;;let obj1 = &#123;username: 'iverson', age:42&#125;;let obj2 = &#123;sex: '男'&#125;;Object.assign(obj, obj1, obj2);console.log(obj);let obj3 = &#123;&#125;;let obj4 = &#123;qian: 5000000&#125;;obj3.__proto__ = obj4;console.log(obj3);console.log(obj3.qian); 深度克隆123456789101112131415161718192021221、数据类型： * 数据分为基本的数据类型(String, Number, boolean, Null, Undefined)和对象数据类型 - 基本数据类型： 特点： 存储的是该对象的实际数据 - 对象数据类型： 特点： 存储的是该对象在栈中引用，真实的数据存放在堆内存里2、复制数据 - 基本数据类型存放的就是实际的数据，可直接复制 let number2 &#x3D; 2; let number1 &#x3D; number2; - 克隆数据：对象&#x2F;数组 1、区别： 浅拷贝&#x2F;深度拷贝 判断： 拷贝是否产生了新的数据还是拷贝的是数据的引用 知识点：对象数据存放的是对象在栈内存的引用，直接复制的是对象的引用 let obj &#x3D; &#123;username: &#39;kobe&#39;&#125; let obj1 &#x3D; obj; &#x2F;&#x2F; obj1 复制了obj在栈内存的引用 2、常用的拷贝技术 1). arr.concat(): 数组浅拷贝 2). arr.slice(): 数组浅拷贝 3). JSON.parse(JSON.stringify(arr&#x2F;obj)): 数组或对象深拷贝, 但不能处理函数数据 4). 浅拷贝包含函数数据的对象&#x2F;数组 5). 深拷贝包含函数数据的对象&#x2F;数组 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 不会影响原数据let str = 'abcd';let str2 = str;console.log(str2);str2 = '';console.log(str);let bool1 = true;let bool2 = bool1;bool2 = false;console.log(bool1);// 拷贝数组/对象，没有生成新的数据而是复制了一份引用let obj = &#123;username: 'kobe', age: 39&#125;;let obj2 = obj;console.log(obj2);obj2.username = 'wade';console.log(obj.username);let arr = [1, 4, &#123;username: 'kobe', age: 39&#125;];let arr2 = arr;arr2[0] = 'abcd';console.log(arr, arr2);/** * 拷贝数据： * 基本数据类型： * 拷贝后会生成一份新的数据，修改拷贝以后的数据不会影响原数据 * 对象/数组： * 拷贝后不会生成新的数据，而是拷贝的引用。修改拷贝以后的数据会影响原来的数据 * * 拷贝数据的方法： * 1.直接赋值给一个变量 // 浅拷贝 * 2.Object.assign() // 浅拷贝 * 3.Array.prototype.concat() // 浅拷贝 * 4.Array.prototype.slice() // 浅拷贝 * 5.JSON.parse(JSON.stringify()) // 深拷贝（深度克隆），但不能处理函数数据 * * 浅拷贝（对象/数组） * 特点：拷贝的引用，修改拷贝以后的数据会影响原数据，使得原数据不安全 * 深拷贝（深度克隆） * 特点：拷贝的时候生成新数据，修改拷贝以后的数据不会影响原数据 */&#123;let obj = &#123;username: 'kobe'&#125;;let obj2 = Object.assign(obj);console.log(obj2);obj.username = 'wade';console.log(obj2);let arr = [1, 3, &#123;username: 'kobe'&#125;, function fun()&#123;&#125;];let arr2 = arr.concat();arr2[0] = 2;// 这个修改不影响arr的第一个元素，因为是复制的基本类型arr2[2].username = 'wade';// 这个修改会影响原数据，因为复制是对象的引用console.log(arr);let arr3 = arr.slice();arr3[2].username = 'iverson';// 会影响console.log(arr);let arr4 = JSON.parse(JSON.stringify(arr));console.log(arr4);arr4[2].username = 'duncan';// 不影响console.log(arr, arr4); 实现深度克隆前的知识储备： 12345678910111213141516171819202122/** * 思考：如何实现深度拷贝（克隆） * 即使有对象/数组，也可以继续遍历对象/数组拿到里边每一项值，直到拿到的是基本数据类型，然后再去复制，就是深度拷贝 * * 如何判断数据类型：arr --&gt; Array null --&gt; Null * 1.typeof返回的数据类型：String, Number, Boolean, Undefined, Object, Function * 2.Object.prototype.toString.call(this) */let result= 'abcd';result = null;result = [1, 3];console.log(Object.prototype.toString.call(result).slice(8, -1));// for in循环，对象（属性名） 数组（下标）let obj6 = &#123;username: 'kobe', age: 39&#125;;for (let i in obj6)&#123; console.log(i);&#125;let arr6 = [1, 3, 'abc'];for (let i in arr6)&#123; console.log(i);&#125; 实现深度克隆： 123456789101112131415161718192021222324252627282930313233343536373839404142// 定义检测数据类型的功能函数function checkType(target)&#123; return Object.prototype.toString.call(target).slice(8, -1);&#125;// 实现深度克隆 --&gt; 对象/数组function clone(target)&#123; // 判断拷贝的数据类型 // 初始化变量result成为最终克隆的数据 let result, targetType = checkType(target); if(targetType === 'Object')&#123; result = &#123;&#125;; &#125;else if(targetType === 'Array')&#123; result = []; &#125;else&#123; return target; &#125; // 遍历目标数据 for(let i in target)&#123; // 获取遍历数据结构的每一项值 let value = target[i]; // 判断目标结构里的每一项值是否存在对象/数组 if(checkType(value) === 'Object' || checkType(value) === 'Array')&#123;// 对象/数组里嵌套了对象/数组 // 继续遍历获取到的value值 result[i] = clone(value); &#125;else&#123;// 获取到的value值是基本的数据类型或函数 result[i] = value; &#125; &#125; return result;&#125;let arr7 = [1, 2, &#123;username: 'kobe', age:39&#125;];let arr8 = clone(arr7);console.log(arr8);arr8[2].username = 'wade';console.log(arr7, arr8);let obj7 = &#123;username: 'kobe', age: 39&#125;;let obj8 = clone(obj7);console.log(obj8);obj8.username = 'wade';console.log(obj7, obj8); Set和Map12345678910111213141516171. Set容器 : 无序不可重复的多个value的集合体 * Set() * Set(array) * add(value) * delete(value) * has(value) * clear() * size2. Map容器 : 无序的 key不重复的多个key-value的集合体 * Map() * Map(array) * set(key, value)&#x2F;&#x2F;添加 * get(key) * delete(key) * has(key) * clear() * size 示例代码： 123456789101112131415161718let set = new Set([1,2,4,5,2,3,6]);console.log(set);set.add(7);console.log(set.size, set);console.log(set.has(8));// falseconsole.log(set.has(7));// trueset.delete(4);console.log(set);set.clear();console.log(set);let map = new Map([['username', 'kobe'], [36, 'age']]);console.log(map);map.set(78, 'haha');console.log(map);map.delete(36);console.log(map);console.log(map.size); for of循环123456for(let value of target)&#123;&#125;循环遍历 1. 遍历数组 2. 遍历Set 3. 遍历Map 4. 遍历字符串 5. 遍历伪数组 示例代码： 123456789101112131415// 数组去重let arr = [1,2,4,5,5,6,2];let arr1 = arr;arr = [];let set = new Set(arr1);for (let i of set)&#123; arr.push(i);&#125;console.log(arr);// 遍历伪数组let btns = document.getElementsByTagName('button');for(let i of btns)&#123; console.log(i);&#125; ES7121. 指数运算符(幂): **2. Array.prototype.includes(value) : 判断数组中是否包含指定value 示例代码： 123console.log(3 ** 3);// 27let arr = [1,4,5,6,'abc'];console.log(arr.includes(6));// true","tags":[{"name":"前端","slug":"前端","permalink":"https://sunshine-zwq.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"https://sunshine-zwq.github.io/tags/ECMAScript/"}]}]