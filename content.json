[{"title":"JS模块化","date":"2020-09-13T06:45:51.107Z","path":"2020/09/13/JS模块化/","text":"简介 什么是模块? 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起 块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信 一个模块的组成 数据—&gt;内部的属性 操作数据的行为—&gt;内部的函数 模块化 编码时是按照模块一个一个编码的, 整个项目就是一个模块化的项目 模块化的好处 避免命名冲突（减少命名空间污染） 更好的分离，按需加载 更高复用性 高可维护性 CommonJS 说明 每个文件都可当作一个模块 在服务器端：模块的加载是运行时同步加载的 在浏览器端：模块需要提前编译打包处理 基本语法 暴露模块 module.exports = value exports.xxx = value 引入模块 require(xxx) 第三方模块：xxx为模块名 自定义模块：xxx为模块文件路径 基于服务端应用（Node.js） 项目结构 12345678910|-modules |-module1.js |-module2.js |-module3.js|-app.js|-package.json &#123; &quot;name&quot;: &quot;commonJS-node&quot;, &quot;version&quot;: &quot;1.0.0&quot; &#125; 下载第三方模块 npm install uniq –save 模块化编码 module1.js12345module.exports = &#123; foo() &#123; console.log('moudle1 foo()') &#125;&#125; module2.js123module.exports = function () &#123; console.log('module2()')&#125; module3.js1234567exports.foo = function () &#123; console.log('module3 foo()')&#125;exports.bar = function () &#123; console.log('module3 bar()')&#125; app.js 12345678910111213141516171819202122/** 1. 定义暴露模块: module.exports = value; exports.xxx = value; 2. 引入模块: var module = require(模块名或模块路径); */\"use strict\";//引用模块let module1 = require('./modules/module1')let module2 = require('./modules/module2')let module3 = require('./modules/module3')let uniq = require('uniq')//使用模块module1.foo()module2()module3.foo()module3.bar()console.log(uniq([1, 3, 1, 4, 3])) 通过node运行app.js 命令: node app.js 工具: 右键–&gt;运行 基于浏览器端应用（Browserify ） 项目结构12345678910111213|-js |-dist &#x2F;&#x2F;打包生成文件的目录 |-src &#x2F;&#x2F;源码所在的目录 |-module1.js |-module2.js |-module3.js |-app.js &#x2F;&#x2F;应用主源文件|-index.html|-package.json &#123; &quot;name&quot;: &quot;browserify-test&quot;, &quot;version&quot;: &quot;1.0.0&quot; &#125; 下载browserify 全局: npm install browserify -g 局部: npm install browserify –save-dev 定义模块代码 module1.js12345module.exports = &#123; foo() &#123; console.log('moudle1 foo()') &#125;&#125; module2.js123module.exports = function () &#123; console.log('module2()')&#125; module3.js1234567exports.foo = function () &#123; console.log('module3 foo()')&#125;exports.bar = function () &#123; console.log('module3 bar()')&#125; app.js (应用的主js)1234567891011121314//引用模块let module1 = require('./module1')let module2 = require('./module2')let module3 = require('./module3')let uniq = require('uniq')//使用模块module1.foo()module2()module3.foo()module3.bar()console.log(uniq([1, 3, 1, 4, 3])) 打包处理js: browserify js/src/app.js -o js/dist/bundle.js 页面使用引入: 1&lt;script type=\"text/javascript\" src=\"js/dist/bundle.js\"&gt;&lt;/script&gt; AMD（浏览器端） require.js 基本语法 定义暴露模块 定义没有依赖的模块：define(function(){return 模块}) 定义有依赖的模块：define([‘module1’, ‘module2’], function(m1, m2){return 模块}) 引入模块: require([‘module1’, ‘module2’], function(m1, m2){//使用模块对象}) 配置: 123456789101112131415161718192021require.config(&#123; //基本路径 baseUrl : 'js/', //标识名称与路径的映射 paths : &#123; '模块1' : 'modules/模块1', '模块2' : 'modules/模块2', 'angular' : 'libs/angular', 'angular-messages' : 'libs/angular-messages' &#125;, //非AMD的模块 shim : &#123; 'angular' : &#123; exports : 'angular' &#125;, 'angular-messages' : &#123; exports : 'angular-messages', deps : ['angular'] &#125; &#125;&#125;) 代码实现： 下载require.js, 并引入 官网: http://www.requirejs.cn/ github : https://github.com/requirejs/requirejs 将require.js导入项目: js/libs/require.js 项目结构 12345678|-js |-libs |-require.js |-modules |-alerter.js |-dataService.js |-main.js|-index.html 定义require.js的模块代码 dataService.js 123456789define(function () &#123; let msg = 'Hello world' function getMsg() &#123; return msg.toUpperCase() &#125; return &#123;getMsg&#125;&#125;) alerter.js 12345678910define(['dataService', 'jquery'], function (dataService, $) &#123; let name = 'Tom2' function showMsg() &#123; $('body').css('background', 'gray') alert(dataService.getMsg() + ', ' + name) &#125; return &#123;showMsg&#125;&#125;) 应用主(入口)js: main.js 1234567891011121314151617(function () &#123; //配置 requirejs.config(&#123; //基本路径 baseUrl: \"js/\", //模块标识名与模块路径映射 paths: &#123; \"alerter\": \"modules/alerter\", \"dataService\": \"modules/dataService\", &#125; &#125;) //引入使用模块 requirejs( ['alerter'], function(alerter) &#123; alerter.showMsg() &#125;)&#125;)() 页面使用模块: 1&lt;script data-main=\"js/main\" src=\"js/libs/require.js\"&gt;&lt;/script&gt; 使用第三方基于require.js的框架(jquery) 将jquery的库文件导入到项目: js/libs/jquery-1.10.1.js 在main.js中配置jquery路径 123paths: &#123; &#39;jquery&#39;: &#39;libs&#x2F;jquery-1.10.1&#39; &#125; 在alerter.js中使用jquery 12345678define([&#39;dataService&#39;, &#39;jquery&#39;], function (dataService, $) &#123; var name &#x3D; &#39;xfzhang&#39; function showMsg() &#123; $(&#39;body&#39;).css(&#123;background : &#39;red&#39;&#125;) alert(name + &#39; &#39;+dataService.getMsg()) &#125; return &#123;showMsg&#125;&#125;) 使用第三方不基于require.js的框架(angular) 将angular.js导入项目 js/libs/angular.js 在main.js中配置 1234567891011121314151617181920212223242526272829(function () &#123; require.config(&#123; //基本路径 baseUrl: \"js/\", //模块标识名与模块路径映射 paths: &#123; //第三方库 'jquery' : './libs/jquery-1.10.1', 'angular' : './libs/angular', //自定义模块 \"alerter\": \"./modules/alerter\", \"dataService\": \"./modules/dataService\" &#125;, /* 配置不兼容AMD的模块 exports : 指定与相对应的模块名对应的模块对象 */ shim: &#123; 'angular' : &#123; exports : 'angular' &#125; &#125; &#125;) //引入使用模块 require( ['alerter', 'angular'], function(alerter, angular) &#123; alerter.showMsg() console.log(angular); &#125;)&#125;)() CMD（浏览器端） sea.js 基本语法 定义暴露模块: 定义没有依赖的模块 1234define(function(require, exports, module)&#123; exports.xxx = value module.exports = value&#125;) 定义有依赖的模块 12345678910define(function(require, exports, module)&#123; //引入依赖模块(同步) var module2 = require('./module2') //引入依赖模块(异步) require.async('./module3', function (m3) &#123; &#125;) //暴露模块 exports.xxx = value&#125;) 引入使用模块 123456define(function (require) &#123; var m1 = require('./module1') var m4 = require('./module4') m1.show() m4.show()&#125;) 使用模块seajs.use([‘模块1’, ‘模块2’]) 代码实现： 下载sea.js, 并引入 官网: http://seajs.org/ github : https://github.com/seajs/seajs 将sea.js导入项目: js/libs/sea.js 创建项目结构 12345678910|-js |-libs |-sea.js |-modules |-module1.js |-module2.js |-module3.js |-module4.js |-main.js|-index.html 定义sea.js的模块代码 module1.js 1234567891011define(function (require, exports, module) &#123; //内部变量数据 var data = 'Hello world' //内部函数 function show() &#123; console.log('module1 show() ' + data) &#125; //向外暴露 exports.show = show&#125;) module2.js 12345define(function (require, exports, module) &#123; module.exports = &#123; msg: 'I Will Back' &#125;&#125;) module3.js 1234define(function (require, exports, module) &#123; const API_KEY = 'abc123' exports.API_KEY = API_KEY&#125;) module4.js 1234567891011121314define(function (require, exports, module) &#123; //引入依赖模块(同步) var module2 = require('./module2') function show() &#123; console.log('module4 show() ' + module2.msg) &#125; exports.show = show //引入依赖模块(异步) require.async('./module3', function (m3) &#123; console.log('异步引入依赖模块3 ' + m3.API_KEY) &#125;)&#125;) main.js : 主(入口)模块 123456define(function (require) &#123; var m1 = require('./module1') var m4 = require('./module4') m1.show() m4.show()&#125;) index.html: 12345678910111213141516&lt;!--使用seajs: 1. 引入sea.js库 2. 如何定义导出模块 : define() exports module.exports 3. 如何依赖模块: require() 4. 如何使用模块: seajs.use()--&gt;&lt;script type=\"text/javascript\" src=\"js/libs/sea.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; seajs.use('./js/modules/main')&lt;/script&gt; ​ ES6 ES6内置了模块化的实现 基本语法 定义暴露模块 : export 暴露一个对象: 1export default 对象 暴露多个: 123456export var xxx &#x3D; value1export let yyy &#x3D; value2var xxx &#x3D; value1let yyy &#x3D; value2export &#123;xxx, yyy&#125; 引入使用模块 : import default模块: 1import xxx from &#39;模块路径&#x2F;模块名&#39; 其它模块 12import &#123;xxx, yyy&#125; from &#39;模块路径&#x2F;模块名&#39;import * as module1 from &#39;模块路径&#x2F;模块名&#39; 问题: 所有浏览器还不能直接识别ES6模块化的语法 解决: 使用Babel将ES6—&gt;ES5(使用了CommonJS) —-浏览器还不能直接支行 使用Browserify—&gt;打包处理—-浏览器可以运行 代码实现： 定义package.json文件 1234&#123; \"name\" : \"es6-babel-browserify\", \"version\" : \"1.0.0\"&#125; 安装babel-cli, babel-preset-es2015和browserify npm install babel-cli browserify -g npm install babel-preset-es2015 –save-dev preset 预设(将es6转换成es5的所有插件打包) 定义.babelrc文件 123&#123; \"presets\": [\"es2015\"]&#125; 编码 js/src/module1.js 分别暴露 1234567export function foo() &#123; console.log('module1 foo()');&#125;export function bar() &#123; console.log('module1 bar()');&#125;export const DATA_ARR = [1, 3, 5, 1] js/src/module2.js 统一暴露 1234567891011let data = 'module2 data'function fun1() &#123; console.log('module2 fun1() ' + data);&#125;function fun2() &#123; console.log('module2 fun2() ' + data);&#125;export &#123;fun1, fun2&#125; js/src/module3.js 123456export default &#123; name: 'Tom', setName: function (name) &#123; this.name = name &#125;&#125; js/src/app.js 1234567891011121314151617import &#123;foo, bar&#125; from './module1'import &#123;DATA_ARR&#125; from './module1'import &#123;fun1, fun2&#125; from './module2'import person from './module3'import $ from 'jquery'$('body').css('background', 'red')foo()bar()console.log(DATA_ARR);fun1()fun2()person.setName('JACK')console.log(person.name); 编译 使用Babel将ES6编译为ES5代码(但包含CommonJS语法) : babel js/src -d js/lib 使用Browserify编译js : browserify js/lib/app.js -o js/lib/bundle.js 页面中引入测试 1&lt;script type=\"text/javascript\" src=\"js/lib/bundle.js\"&gt;&lt;/script&gt; 引入第三方模块(jQuery) 下载jQuery模块: npm install jquery@1 –save 在app.js中引入并使用 12import $ from 'jquery'$('body').css('background', 'red')","tags":[{"name":"js","slug":"js","permalink":"https://sunshine-zwq.github.io/tags/js/"},{"name":"js模块化","slug":"js模块化","permalink":"https://sunshine-zwq.github.io/tags/js%E6%A8%A1%E5%9D%97%E5%8C%96/"}]},{"title":"Node.js入门","date":"2020-09-06T05:06:19.720Z","path":"2020/09/06/Node.js入门/","text":"Node.js简介简介： (1).开发者：瑞安·达尔（Ryan Dahl） (2).Node.js是一个能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript运行环境。 (3).Node采用Google开发的V8引擎运行js代码，使用事件驱动、非阻塞和异步I/O模型等技术来提高性能，可优化应用程序的传输量和规模。 (4).Node大部分基本模块都用JavaScript编写。在Node出现之前，JS通常作为客户端程序设计语言使用，以JS写出的程序常在用户的浏览器上运行。 特点： (1).Node.js允许通过JS和一系列模块来编写服务器端应用和网络相关的应用。 (2).核心模块包括文件系统I/O、网络（HTTP、TCP、UDP、DNS、TLS/SSL等）、二进制数据流、加密算法、数据流等等。Node模块的API形式简单，降低了编程的复杂度。 (3).使用框架可以加速开发。常用的框架有Express.js、Socket.IO和Connect等。Node.js的程序可以在Microsoft Windows、Linux、Unix、Mac OS X等服务器上运行。 (4).Node.js也可以使用CoffeeScript、TypeScript、Dart语言，以及其他能够编译成JavaScript的语言编程。 用途： • Web服务API，比如REST• 实时多人游戏• 后端的Web服务，例如跨域、服务器端的请求• 基于Web的应用• 多客户端的通信，如即时通信 Node的基本使用使用node执行js： 1node hello.js CommonJS规范ECMAScript标准的缺陷：• 没有模块系统• 标准库较少• 没有标准接口• 缺乏管理系统 CommonJS简介：• CommonJS规范的提出，主要是为了弥补当前JavaScript没有模块化标准的缺陷。• CommonJS规范为JS指定了一个美好的愿景，希望JS能够在任何地方运行。 模块引用• 在规范中，定义了require()方法，这个方法接收模块标识，以此将一个模块引入到当前运行环境中。使用require()引入模块以后，该函数会返回一个对象，这个对象代表的就是引入的模块。 模块引用的示例代码： 1var math = require('math'); 注意： 1.require()可以传递一个文件的路径作为参数，node会自动根据该路径来引入外部模块 2.这里的路径，如果使用相对路径，必须以 ./ 或者 ../ 开头 3.路径的后缀.js可以省略 模块定义• 在运行环境中，提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一的导出的出口。• 在模块中还存在一个module对象，它代表模块自身，而exports是module的属性。• 在Node中一个文件就是一个模块。• 在Node中，每一个js文件中的js代码都是独立运行在一个函数中，而不是全局作用域，所以一个模块中的变量和函数在其他模块中无法访问。 使用exports向外暴露属性或方法示例： 123exports.x = 10;exports.xxx = function() &#123;&#125;;module.exports = &#123;&#125;; 模块标识• 模块标识其实就是模块的名字，也就是传递给require()方法的参数，它必须是符合驼峰命名法的字符串，或者是以 ./ 或 ../ 开头的相对路径、或者绝对路径。 模块分为两大类：核心模块、文件模块。 (1).核心模块 • 由node引擎提供的模块 • 核心模块的标识，就是模块的名字 (2).文件模块 • 由用户自己创建的模块 • 文件模块的标识，就是文件的路径（绝对路径，或相对路径） 在node中有一个全局变量global，它的作用和网页中window类似 • 在全局中创建的变量都会作为global的属性保存 • 在全局中创建的函数都会作为global的方法保存 当node在执行模块中的代码时，它会在代码首尾包裹一层函数，代码示例： 原始代码： 1234567891011121314var a = 10;/** 在node中有一个全局变量global，它的作用和网页中window类似 • 在全局中创建的变量都会作为global的属性保存 • 在全局中创建的函数都会作为global的方法保存 */// console.log(global.a);/** arguments.callee - 这个属性保存的是当前执行的函数对象 */console.log(arguments.callee + \"\"); 实际执行的代码： 12345678910111213141516function (exports, require, module, __filename, __dirname) &#123; var a = 10;/** 在node中有一个全局变量global，它的作用和网页中window类似 • 在全局中创建的变量都会作为global的属性保存 • 在全局中创建的函数都会作为global的方法保存 */// console.log(global.a);/** arguments.callee - 这个属性保存的是当前执行的函数对象 */console.log(arguments.callee + \"\");&#125; 实际上模块中的代码都是包装在一个函数中执行的，并且在函数执行时，同时传递进了5个实参： (1).exports：该对象用于将变量或函数暴露到外部 (2).require：函数，用来引入外部的模块 (3).module：代表的就是当前模块本身，exports就是module的属性 (4).__filename：当前模块的完整路径 (5).__dirname：当前模块所在文件夹的完整路径 exports和module.exports的区别： (1).通过exports只能使用 . 的方式来向外暴露内部变量，如exports.xxx = yyy (2).module.exports既可以通过 . 的方式，也可以直接赋值 ​ module.exports.xxx = yyy ​ module.exports = { ​ } NPM包 package• CommonJS的包规范允许我们将一组相关的模块组合到一起，形成一组完整的工具。• CommonJS的包规范由包结构和包描述文件两个部分组成 包结构：用于组织包中的各种文件 • 包实际上就是一个压缩文件，解压以后还原为目录。符合规范的目录，应该包含如下文件：– package.json 描述文件（必须要有）– bin 可执行二进制文件– lib js代码– doc 文档– test 单元测试 包描述文件：描述包的相关信息，以供外部读取分析 • 包描述文件用于表达非代码相关的信息，它是一个JSON格式的文件 – package.json，位于包的根目录下，是包的重要组成部分。• package.json中的字段– name、description、version、keywords、maintainers、contributors、bugs、licenses、repositories、dependencies、homepage、os、cpu、engine、builtin、directories、implements、scripts、author、bin、main、devDependencies。 NPM(Node Package Manager)• CommonJS包规范是理论，NPM是其中一种实践。• 对于Node而言，NPM帮助其完成了第三方模块的发布、安装和依赖等。借助NPM，Node与第三方模块之间形成了很好的一个生态系统。 NPM命令常用命令： • npm –v 查看npm的版本 • npm version 查看所有模块的版本 • npm search 包名 搜索包 • npm install / i 包名 安装包 • npm remove / r 包名 删除包 • npm install 包名 –save 安装包并添加到依赖中 • npm install 下载当前项目所依赖的包 • npm install 包名 -g 全局安装包（全局安装的包一般都是一些工具） • npm init 初始化项目生成package.json文件 • npm install 包名 –registry=地址 从镜像源安装 • npm config set registry 地址 设置镜像源 安装cnpm（使用淘宝镜像）: 1npm install -g cnpm --registry=https://registry.npm.taobao.org Node搜索包的流程： • Node在使用模块名字来引入模块时，它会首先在当前目录的node_modules中寻找是否包含有该模块 • 如果有则直接使用，如果没有则去上一级目录的node_modules中寻找 • 如果有则直接使用，如果没有则再去上一级目录寻找，直到找到为止 • 直到找到磁盘的根目录，如果依然没有，则报错 文件系统BufferBuffer(缓冲区) • 从结构上看Buffer非常像一个数组，它的元素为16进制的两位数。 • 实际上一个元素就表示内存中的一个字节。 • 实际上Buffer中的内存不是通过JavaScript分配的，而是在底层通过C++申请的。 • 也就是我们可以直接通过Buffer来创建内存中的空间。 Buffer的操作 • Buffer.from(str) 将一个字符串转换为buffer • Buffer.alloc(size) 创建一个指定大小的buffer • Buffer.allocUnsafe(size) 创建一个指定大小的buffer，但是可能包含敏感数据 • buf.toString() 将缓冲区的数据转换为字符串 写入操作• 向缓冲区中写入字符串 – buf.write(string[, offset[, length]][, encoding])• 替换指定索引位置的数据 – buf[index]• 将指定值填入到缓冲区的指定位置 – buf.fill(value[, offset[, end]][, encoding]) 读取操作• 将缓冲区中的内容，转换为一个字符串返回 – buf.toString([encoding[, start[, end]]])• 读取缓冲区指定索引的内容 – buf[index] 其他操作• 复制缓冲区 – buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])• 对缓冲区切片 – buf.slice([start[, end]])• 拼接缓冲区 – Buffer.concat(list[, totalLength]) fs（文件系统）• 在Node中，与文件系统的交互是非常重要的，服务器的本质就将本地的文件发送给远程的客户端• Node通过fs模块来和文件系统进行交互• 该模块提供了一些标准文件访问API来打开、读取、写入文件，以及与其交互。• 要使用fs模块，首先需要对其进行加载 – const fs = require(“fs”); 同步和异步调用• fs模块中所有的操作都有两种形式可供选择同步和异步。• 同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码。• 异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回。 打开和关闭文件• 打开文件 – fs.open(path, flags[, mode], callback) – fs.openSync(path, flags[, mode])• 关闭文件 – fs.close(fd, callback) – fs.closeSync(fd) 打开状态(mode)r 读取文件 , 文件不存在则出现异常r+ 读写文件 , 文件不存在则出现异常rs 在同步模式下打开文件用于读取rs+ 在同步模式下打开文件用于读写w 打开文件用于写操作 , 如果不存在则创建，如果存在则截断wx 打开文件用于写操作 , 如果 存在则打开失败w+ 打开文件用于读写 , 如果不存在则创建 , 如果存在则截断wx+ 打开文件用于读写 , 如果 存在则打开失败a 打开文件用于追加 , 如果不存在则创建ax 打开文件用于追加 , 如果路径存在则失败a+ 打开文件进行读取和追加 , 如果不存在则创建该文件ax+ 打开文件进行读取和追加 , 如果路径存在则失败 同步文件写入• fs.writeSync(fd, buffer, offset, length[, position])• fs.writeSync(fd, data[, position[, encoding]]) • 要完成同步写入文件，先需要通过openSync()打开文件来获取一个文件描述符，然后在通过writeSync()写入文件。 • 参数 – fd 文件描述符，通过openSync()获取 – data 要写入的数据（String 或 Buffer） – offset buffer写入的偏移量 – length 写入的长度 – position 写入的起始位置 – encoding 写入编码 示例代码： 123456789101112131415161718192021222324252627282930313233343536/** 文件系统（File System） - 文件系统简单来说就是通过Node来操作系统中的文件 - 使用文件系统，需要先引入fs模块，fs是核心模块，直接引入不需要下载 同步文件的写入 - 手动操作的步骤 1.打开文件 fs.openSync(path, flags[, mode]) - path 要打开的文件路径 - flags 打开文件要做的操作的类型 r 只读的 w 可写的 - mode 设置文件的操作权限，一般不传 返回值：该方法会返回一个文件的描述符作为结果，我们可以通过该描述符来对文件进行各种操作 2.向文件中写入内容 fs.writeSync(fd, string[, position[, encoding]]) - fd 文件的描述符，需要传递写入的文件的描述符 - string 要写入的内容 - position 写入的起始位置 - encoding 写入的编码，默认utf-8 3.保存并关闭文件 fs.close(fd) - fd 要关闭的文件的描述符 */var fs = require(\"fs\");// 打开文件var fd = fs.openSync(\"hello.txt\", \"w\");// 向文件中写入内容fs.writeSync(fd, \"今天天气真不错~~~\");// 关闭文件fs.closeSync(fd); 异步文件写入• fs.write(fd, buffer, offset, length[, position], callback)• fs.write(fd, data[, position[, encoding]], callback) • 要使用异步写入文件，先需要通过open()打开文件，然后在回调函数中通过write()写入。 • 参数： – fd 文件描述符 – data 要写入的数据（String 或 Buffer） – offset buffer写入的偏移量 – length 写入的长度 – position 写入的起始位置 – encoding 写入编码 示例代码： 12345678910111213141516171819202122232425262728293031323334/** 异步文件写入 fs.open(path, flags[, mode], callback) - 用来打开一个文件 - 异步调用的方法，结果都是通过回调函数的参数返回的 - 回调函数的两个参数： - err 错误对象，如果没有错误则为null - fd 文件的描述符 fs.write(fd, string[, position[, encoding]], callback) - 用来异步写入一个文件 fs.close(fd, callback) - 用来关闭文件 */var fs = require(\"fs\");// 打开文件fs.open(\"hello2.txt\", \"w\", function (err, fd) &#123; if(!err)&#123; fs.write(fd, \"这是异步写入的内容\", function (err) &#123; if(!err)&#123; console.log(\"写入成功~~~\"); &#125; // 关闭文件 fs.close(fd, function () &#123; if(!err)&#123; console.log(\"文件已关闭~~~\"); &#125; &#125;) &#125;) &#125;else&#123; console.log(err); &#125;&#125;) 简单文件写入• fs.writeFile(file, data[, options], callback)• fs.writeFileSync(file, data[, options]) • 参数： – file 文件路径 – data 被写入的内容，可以是String或Buffer – options 对象，包含属性（encoding、mode、flag） – callback 回调函数 示例代码： 12345678910111213141516171819202122/** 简单文件写入 fs.writeFile(file, data[, options], callback) fs.writeFileSync(file, data[, options]) - file 要操作的文件路径 - data 要写入的数据 - options 选项，可以对写入进行一些设置 - flag r 只读 w 可写 a 追加 - callback 当写入完成以后执行的函数 */var fs = require(\"fs\");fs.writeFile(\"hello3.txt\", \"这是通过writeFile写入的内容\", &#123;flag: \"a\"&#125;, function (err) &#123; if(!err)&#123; console.log(\"写入成功~~~\"); &#125;else&#123; console.log(err); &#125;&#125;) 流式文件写入• 往一个文件中写入大量数据时，最好的方法之一是使用流。• 若要将数据异步传送到文件，首需要使用以下语法创建一个Writable对象： – fs.createWriteStream(path[, options]) • path 文件路径 • options {encoding:””,mode:””,flag:””}• 一旦你打开了Writable文件流，就可以使用write()方法来写入它，写入完成后，再调用end()方法来关闭流。 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738/** 同步、异步、简单文件的写入，都不适合大文件的写入，性能较差，容易导致内存溢出 */var fs = require(\"fs\");// 流式文件写入// 创建一个可写流/** fs.createWriteStram(path[, options]) - 可以用来创建一个可写流 - path 文件路径 - options 配置的参数 */var ws = fs.createWriteStream(\"hello5.txt\");// 可以通过监听流的open和close事件来监听流的打开和关闭/** on(事件字符串， 回调函数) - 可以为对象绑定一个事件 once(事件字符串， 回调函数) - 可以为对象绑定一个一次性的事件，该事件将会在触发一次之后自动失效 */ws.once(\"open\", function () &#123; console.log(\"流打开了~\")&#125;)ws.once(\"close\", function () &#123; console.log(\"流关闭了~\")&#125;)// 通过ws向文件中输出内容ws.write(\"通过可写流写入文件的内容1\");ws.write(\"通过可写流写入文件的内容2\");ws.write(\"通过可写流写入文件的内容3\");ws.write(\"通过可写流写入文件的内容4\");ws.write(\"通过可写流写入文件的内容5\");// 关闭流ws.end(); 同步文件读取• fs.readSync(fd, buffer, offset, length, position) – 参数： • fd 文件描述符 • buffer 读取文件的缓冲区 • offset buffer的开始写入的位置 • length 要读取的字节数 • position 开始读取文件的位置 异步文件读取• fs.read(fd, buffer, offset, length, position, callback) – 参数： • fd 文件描述符 • buffer 读取文件的缓冲区 • offset buffer的开始写入的位置 • length 要读取的字节数 • position 开始读取文件的位置 • callback 回调函数 参数err , bytesRead , buffer 简单文件读取• fs.readFile(file[, options], callback)• fs.readFileSync(file[, options]) – 参数： • file 文件路径或文件描述符 • options – encoding 默认 = null – flag 默认 = ‘r’ • callback 回调函数，有两个参数err 、data 示例代码： 12345678910111213141516171819202122232425/** 简单文件读取 fs.readFile(path[, options], callback) fs.readFileSync(path[, options]) - path 要读取的文件路径 - options 读取的选项 - callback 回调函数，通过回调函数将读取到内容返回(err, data) err 错误对象 data 读取到的数据，会返回一个Buffer */var fs = require(\"fs\");fs.readFile(\"hello3.txt\", function (err, data) &#123; if(!err)&#123; console.log(data.toString()) // 将data写入到文件中 fs.writeFile(\"copyOf_hello3.txt\", data, function (err) &#123; if(!err)&#123; console.log(\"文件写入成功\"); &#125;else&#123; console.log(err); &#125; &#125;) &#125;&#125;) 流式文件读取• 从一个文件中读取大量的数据时，最好的方法之一就是流式读取，这样将把一个文件作为Readable流的形式打开。• 要从异步从文件传输数据，首先需要通过以下语法创建一个Readable流对象： – fs.createReadStream(path[, options]) • path 文件路径 • options {encoding:””,mode:””,flag:””}• 当你打开Readable文件流以后，可以通过readable事件和read()请求，或通过data事件处理程序轻松地从它读出。 示例代码： 1234567891011121314151617181920212223242526272829303132/** 流式文件读取也适用于一些比较大的文件，可以分多次将文件读取到内存中 */var fs = require(\"fs\");// 创建一个可读流var rs = fs.createReadStream(\"avatar.jpg\");// 创建一个可写流var ws = fs.createWriteStream(\"test.jpg\");// 监听流的打开和关闭rs.once(\"open\", function () &#123; console.log(\"可读流打开了~\")&#125;)rs.once(\"close\", function () &#123; console.log(\"可读流关闭了~\"); // 数据读取完毕，关闭可写流 ws.end();&#125;)ws.once(\"open\", function () &#123; console.log(\"可写流打开了~\")&#125;)ws.once(\"close\", function () &#123; console.log(\"可写流关闭了~\")&#125;)// 如果要读取一个可读流中的数据，必须要为可读流绑定一个data事件，data事件绑定完毕，它会自动开始读取数据rs.on(\"data\", function (data) &#123; console.log(data); // 将读取到的数据写入到可写流中 ws.write(data);&#125;) 利用pipe()实现更简洁的文件复制： 123456789var fs = require(\"fs\");// 创建一个可读流var rs = fs.createReadStream(\"avatar.jpg\");// 创建一个可写流var ws = fs.createWriteStream(\"test.jpg\");// pipe()可以将可读流中的内容，直接输出到可写流中rs.pipe(ws); 其他操作• 验证路径是否存在 – fs.exists(path，callback) – fs.existsSync(path) • 获取文件信息 – fs.stat(path, callback) – fs.statSync(path) • 删除文件 – fs.unlink(path, callback) – fs.unlinkSync(path) • 列出文件 – fs.readdir(path[, options], callback) – fs.readdirSync(path[, options]) • 截断文件 – fs.truncate(path, len, callback) – fs.truncateSync(path, len) • 建立目录 – fs.mkdir(path[, mode], callback) – fs.mkdirSync(path[, mode]) • 删除目录 – fs.rmdir(path, callback) – fs.rmdirSync(path) • 重命名文件和目录（可实现剪切的功能） – fs.rename(oldPath, newPath, callback) – fs.renameSync(oldPath, newPath) • 监视文件更改写入 – fs.watchFile(filename[, options], listener)","tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sunshine-zwq.github.io/tags/jQuery/"},{"name":"Node.js","slug":"Node-js","permalink":"https://sunshine-zwq.github.io/tags/Node-js/"}]},{"title":"jQuery包裹节点方法wrap()、wrapAll()、wrapInner()的区别","date":"2020-08-29T03:10:25.593Z","path":"2020/08/29/jQuery包裹节点方法wrap()、wrapAll()、wrapInner()的区别/","text":"1.wrap()方法原始DOM代码： 1234&lt;div id=\"container\"&gt; &lt;div&gt;姓名：小明&lt;/div&gt; &lt;div&gt;年龄：20岁&lt;/div&gt;&lt;/div&gt; 使用wrap()： 1$(\"#container\").wrap('&lt;div class=\"wrapper\"&gt;&lt;/div&gt;'); 处理后DOM代码： 123456&lt;div class=\"wrapper\"&gt; &lt;div id=\"container\"&gt; &lt;div&gt;姓名：小明&lt;/div&gt; &lt;div&gt;年龄：20岁&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 效果：给$选择器的所有元素外部包裹一层wrapper 2.wrapAll()方法原始DOM代码： 12345&lt;div id=\"container\"&gt; &lt;p&gt;姓名：小明&lt;/p&gt; &lt;p&gt;年龄：20岁&lt;/p&gt; &lt;div&gt;性别：男&lt;div&gt;&lt;/div&gt; 使用wrapAll()： 1$(\"p\").wrapAll('&lt;div class=\"wrapper\"&gt;&lt;/div&gt;'); 处理后DOM代码： 1234567&lt;div id=\"container\"&gt; &lt;div class=\"wrapper\"&gt; &lt;p&gt;姓名：小明&lt;/p&gt; &lt;p&gt;年龄：20岁&lt;/p&gt; &lt;/div&gt; &lt;div&gt;性别：男&lt;div&gt;&lt;/div&gt; 效果：给$选择器的全部匹配元素的外部包裹一层wrapper 3.wrapInner()方法原始DOM代码： 1234&lt;div id=\"container\"&gt; &lt;div&gt;姓名：小明&lt;/div&gt; &lt;div&gt;年龄：20岁&lt;/div&gt;&lt;/div&gt; 使用wrapInner()： 1$(\"#container\").wrapInner('&lt;div class=\"wrapper\"&gt;&lt;/div&gt;'); 处理后DOM代码： 123456&lt;div id=\"container\"&gt; &lt;div class=\"wrapper\"&gt; &lt;div&gt;姓名：小明&lt;/div&gt; &lt;div&gt;年龄：20岁&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 效果：给$选择器的所有元素内部包裹一层wrapper","tags":[{"name":"前端","slug":"前端","permalink":"https://sunshine-zwq.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"jQuery","slug":"jQuery","permalink":"https://sunshine-zwq.github.io/tags/jQuery/"}]},{"title":"用apache的ftpserver搭建FTP服务器","date":"2020-08-23T15:44:27.115Z","path":"2020/08/23/用apache的ftpserver搭建FTP服务器/","text":"maven依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.ftpserver&lt;/groupId&gt; &lt;artifactId&gt;ftpserver-core&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt; 主要代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import org.apache.ftpserver.FtpServer;import org.apache.ftpserver.FtpServerFactory;import org.apache.ftpserver.ftplet.Authority;import org.apache.ftpserver.listener.ListenerFactory;import org.apache.ftpserver.usermanager.impl.BaseUser;import org.apache.ftpserver.usermanager.impl.WritePermission;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.ArrayList;import java.util.List;/** * 搭建ftp服务器 * @author zhuwq * @date 2020/8/21 17:27 */public class MyFtpServer &#123; private static Logger logger = LoggerFactory.getLogger(MyFtpServer.class); /** * 启动FTP服务 * @param port 端口 * @param username ftp用户名 * @param password ftp用户密码 * @param homeDirectory 主页目录 * @return */ public static boolean startServer(int port, String username, String password, String homeDirectory)&#123; logger.info(\"MyFtpServer.startServer[port:&#123;&#125;,username:&#123;&#125;,password:&#123;&#125;,homeDirectory:&#123;&#125;]\", port, username, password, homeDirectory); try&#123; FtpServerFactory serverFactory = new FtpServerFactory(); ListenerFactory factory = new ListenerFactory(); //设置监听端口 factory.setPort(port); //替换默认监听 serverFactory.addListener(\"default\", factory.createListener()); //用户名 BaseUser user = new BaseUser(); user.setName(username); //密码 如果不设置密码就是匿名用户 user.setPassword(password); //用户主目录 user.setHomeDirectory(homeDirectory); List&lt;Authority&gt; authorities = new ArrayList&lt;Authority&gt;(); //增加写权限 authorities.add(new WritePermission()); user.setAuthorities(authorities); //增加该用户 serverFactory.getUserManager().save(user); FtpServer server = serverFactory.createServer(); server.start(); logger.info(\"MyFtpServer.startServer success!!!\"); return true; &#125;catch (Exception e)&#123; e.printStackTrace(); logger.error(e.getMessage(), e); return false; &#125; &#125;&#125; 测试代码1234567public static void main(String[] args) &#123; int port = 21; String username = \"admin\"; String password = \"123456\"; String homeDirectory = \"E:\\\\FTPServer\"; MyFtpServer.startServer(port, username, password, homeDirectory); &#125; 参考链接：https://blog.csdn.net/fengsheng5210/article/details/78140746","tags":[{"name":"java","slug":"java","permalink":"https://sunshine-zwq.github.io/tags/java/"},{"name":"ftp","slug":"ftp","permalink":"https://sunshine-zwq.github.io/tags/ftp/"}]},{"title":"json转换","date":"2020-07-12T03:02:12.968Z","path":"2020/07/12/json转换/","text":"fastjsonjson字符串转JSONObject1JSONObject jsonObject = JSON.parseObject(json); json字符串转对象1Student student = JSONObject.parseObject(json, Student.class); json字符串转List1List&lt;Student&gt; studentList = JSONObject.parseArray(json, Student.class); json字符串转Map1Map&lt;String,String&gt; map = JSONObject.parseObject(json, Map.class); 对象转json字符串1String json = JSON.toJSONString(obj);","tags":[{"name":"json","slug":"json","permalink":"https://sunshine-zwq.github.io/tags/json/"}]},{"title":"ECMAScript入门","date":"2020-03-18T16:43:38.000Z","path":"2020/03/19/ECMAScript入门/","text":"基本介绍123456789101112131. 它是一种由ECMA组织（前身为欧洲计算机制造商协会）制定和发布的脚本语言规范2. 而我们学的 JavaScript 是ECMA的实现, 但术语ECMAScript和JavaScript平时表达同一个意思3. JS包含三个部分： 1). ECMAScript（核心） 2). 扩展&#x3D;&#x3D;&gt;浏览器端 * BOM（浏览器对象模型） * DOM（文档对象模型） 3). 扩展&#x3D;&#x3D;&gt;服务器端 * Node4. ES的几个重要版本 * ES5 : 09年发布 * ES6(ES2015) : 15年发布, 也称为ECMA2015 * ES7(ES2016) : 16年发布, 也称为ECMA2016 (变化不大) ES5严格模式1234567891011121314151. 理解: * 除了正常运行模式(混杂模式)，ES5添加了第二种运行模式：&quot;严格模式&quot;（strict mode）。 * 顾名思义，这种模式使得Javascript在更严格的语法条件下运行2. 目的&#x2F;作用 * 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 * 消除代码运行的一些不安全之处，为代码的安全运行保驾护航 * 为未来新版本的Javascript做好铺垫3. 使用 * 在全局或函数的第一条语句定义为: &#39;use strict&#39;; * 如果浏览器不支持, 只解析为一条简单的语句, 没有任何副作用4. 语法和行为改变 * 必须用var声明变量 * 禁止自定义的函数中的this指向window * 创建eval作用域 * 对象不能有重名的属性 示例代码： 12345678910111213141516171819202122&lt;script type=\"text/javascript\"&gt; 'use strict'; // username = 'kobe'; var username = 'kobe'; console.log(username); function Person (name, age) &#123; this.name = name; this.age = age; &#125; // Person('kobe', 41); new Person('kobe', 41); var str = 'NBA'; eval('var str = \"CBA\"; alert(str)'); alert(str); var obj = &#123; username: 'kobe', // username: 'wade' &#125;&lt;/script&gt; JSON对象12341. JSON.stringify(obj&#x2F;arr) * js对象(数组)转换为json对象(数组)2. JSON.parse(json) * json对象(数组)转换为js对象(数组) Object扩展12345678910111213ES5给Object扩展了一些静态方法, 常用的2个:1. Object.create(prototype, [descriptors]) * 作用: 以指定对象为原型创建新的对象 * 为新的对象指定新的属性, 并对属性进行描述 - value : 指定值 - writable : 标识当前属性值是否是可修改的, 默认为false - configurable: 标识当前属性是否可以被删除 默认为false - enumerable： 标识当前属性是否能用for in 枚举 默认为false2. Object.defineProperties(object, descriptors) * 作用: 为指定对象定义扩展多个属性 * get ：用来获取当前属性值的回调函数（需要取值时才会调用，“惰性求值”） * set ：修改当前属性值得触发的回调函数，并且实参即为修改后的值 * 存取器属性：setter,getter一个用来存值，一个用来取值 示例代码： 12345678910111213141516171819202122232425262728293031323334353637var obj = &#123;username: 'damu', age: 30&#125;;var obj1 = &#123;&#125;;obj1 = Object.create(obj, &#123; sex: &#123; value: '男', writable: true, configurable: true, enumerable: true &#125;&#125;);console.log(obj1.sex);obj1.sex = '女';console.log(obj1.sex);// delete obj1.sex;console.log(obj1);for(var i in obj1)&#123; console.log(i);&#125;var obj2 = &#123;firstName: 'kobe', lastName: 'bryant'&#125;;Object.defineProperties(obj2, &#123; fullName: &#123; get: function()&#123;// 获取扩展属性的值（获取扩展属性值时get会自动调用） return this.firstName + ' ' + this.lastName; &#125;, set: function(data)&#123;// 监听扩展属性，当扩展属性发生变化的时候会自动调用（变化后的值作为实参传入） var names = data.split(' '); this.firstName = names[0]; this.lastName = names[1]; &#125; &#125;&#125;)console.log(obj2.fullName);obj2.fullName = 'tim duncan';console.log(obj2.fullName);console.log(obj2.lastName); 123对象本身的两个方法* get propertyName()&#123;&#125; 用来得到当前属性值的回调函数* set propertyName()&#123;&#125; 用来监视当前属性值变化的回调函数 示例代码： 123456789101112131415var obj = &#123; firstName: 'curry', lastName: 'stephen', get fullName()&#123; return this.firstName + ' ' + this.lastName; &#125;, set fullName(data)&#123; var names = data.split(' '); this.firstName = names[0]; this.lastName = names[1]; &#125;&#125;;console.log(obj);obj.fullName = 'kobe bryant';console.log(obj.fullName); Array扩展123451. Array.prototype.indexOf(value) : 得到值在数组中的第一个下标2. Array.prototype.lastIndexOf(value) : 得到值在数组中的最后一个下标3. Array.prototype.forEach(function(item, index)&#123;&#125;) : 遍历数组4. Array.prototype.map(function(item, index)&#123;&#125;) : 遍历数组返回一个新的数组，返回加工之后的值5. Array.prototype.filter(function(item, index)&#123;&#125;) : 遍历过滤出一个新的子数组， 返回条件为true的值 示例代码： 12345678910111213141516171819202122232425/* 需求: 1. 输出第一个6的下标 2. 输出最后一个6的下标 3. 输出所有元素的值和下标 4. 根据arr产生一个新数组,要求每个元素都比原来大10 5. 根据arr产生一个新数组, 返回的每个元素要大于4 */var arr = [2,4,3,1,2,6,5,4];console.log(arr.indexOf(4));console.log(arr.lastIndexOf(4));arr.forEach(function(item, index)&#123; console.log(item, index);&#125;)var arr1 = arr.map(function (item, index) &#123; return item + 10;&#125;)console.log(arr1);var arr2 = arr.filter(function (item, index) &#123; return item &gt; 4;&#125;)console.log(arr2); Function扩展1234561. Function.prototype.bind(obj) : * 作用: 将函数内的this绑定为obj, 并将函数返回2. 面试题: 区别bind()与call()和apply()? * 都能指定函数中的this * call()&#x2F;apply()是立即调用函数 * bind()是将函数返回 示例代码： 123456789101112131415161718192021var obj = &#123;username: 'kobe'&#125;;function foo(data)&#123; console.log(this, data);&#125;// 直接调用foo方法打印的this是Window// foo();// call和apply的方法作用一样，区别在于传参的方式foo.call(obj, 33);// 直接从第2个参数开始，依次传入foo.apply(obj, [33]);// 第二个参数必须是数组，参数放在数组里// bind的特点：绑定完this不会立即调用当前的函数，而是将函数返回var bar = foo.bind(obj);bar();// bind的传参方式和call一样foo.bind(obj, 33)();// 应用举例setTimeout(function()&#123; console.log(this);&#125;.bind(obj), 1000); ES6（常用）let关键字1234567891. 作用: * 与var类似, 用于声明一个变量2. 特点: * 在块作用域内有效 * 不能重复声明 * 不会预处理（即不能在声明之前使用，会抛出异常，而var在声明前使用值是undefined）, 不存在提升3. 应用: * 循环遍历加监听 * 使用let取代var是趋势 示例代码： 1234567891011121314151617181920212223242526272829303132333435// console.log(username);let username = 'kobe';// let username = 'wade';console.log(username);let btns = document.getElementsByTagName('button');for(var i = 0; i &lt; btns.length; i++)&#123; var btn = btns[i]; btn.onclick = function () &#123; // 打印出来的都是3 alert(i); &#125;&#125;// 解决方法1：用闭包函数btns = document.getElementsByTagName('button');for(var i = 0; i &lt; btns.length; i++)&#123; var btn = btns[i]; (function(i)&#123; btn.onclick = function () &#123; // 打印出来的都是3 alert(i); &#125; &#125;)(i)&#125;// 解决方法2：用let关键字btns = document.getElementsByTagName('button');for(let i = 0; i &lt; btns.length; i++)&#123; var btn = btns[i]; btn.onclick = function () &#123; // 打印出来的都是3 alert(i); &#125;&#125; const关键字12345671. 作用: * 定义一个常量2. 特点: * 不能修改 * 其它特点同let3. 应用: * 保存不用改变的数据 解构赋值123456781. 理解: * 从对象或数组中提取数据, 并赋值给变量(多个)2. 对象的解构赋值 let &#123;n, a&#125; &#x3D; &#123;n:&#39;tom&#39;, a:12&#125;3. 数组的解构赋值 let [a,b] &#x3D; [1, &#39;atguigu&#39;];4. 用途 * 给多个形参赋值 示例代码： 1234567891011121314let obj = &#123;username: 'kobe', age: 39&#125;;// let username = obj.username;// let age = obj.age;let &#123;username, age&#125; = obj;console.log(username, age);let arr = [1,3,5,'abc',true];let [,,a,b] = arr;console.log(a, b);function foo(&#123;username, age&#125;)&#123;// &#123;username, age&#125; = obj console.log(username, age);&#125;foo(obj); 模板字符串1231. 模板字符串 : 简化字符串的拼接 * 模板字符串必须用 &#96;&#96; 包含 * 变化的部分使用$&#123;xxx&#125;定义 示例代码： 12345let obj = &#123;username: 'kobe', age: 39&#125;;let str = '我的名字叫：' + obj.username + '，我今年的年龄是：' + obj.age;console.log(str);str = `我的名字叫：$&#123;obj.username&#125;，我今年的年龄是：$&#123;obj.age&#125;`;console.log(str); 简化的对象写法1234567891011简化的对象写法* 省略同名的属性值* 省略方法的function* 例如: let x &#x3D; 1; let y &#x3D; 2; let point &#x3D; &#123; x, y, setX (x) &#123;this.x &#x3D; x&#125; &#125;; 箭头函数123456789101112131415* 作用: 定义匿名函数* 基本语法: * 没有参数: () &#x3D;&gt; console.log(&#39;xxxx&#39;) * 一个参数: i &#x3D;&gt; i+2 * 大于一个参数: (i,j) &#x3D;&gt; i+j * 函数体不用大括号: 默认返回结果 * 函数体如果有多个语句, 需要用&#123;&#125;包围，若有需要返回的内容，需要手动返回* 使用场景: 多用来定义回调函数* 箭头函数的特点： 1、简洁 2、箭头函数没有自己的this，箭头函数的this不是调用的时候决定的，而是在定义的时候处在的对象就是它的this 3、扩展理解： 箭头函数的this看外层的是否有函数， 如果有，外层函数的this就是内部箭头函数的this， 如果没有，则this是window。 示例代码： 123456789101112131415161718192021222324252627282930313233// 不同传参的情况// 1、没有形参let fun = () =&gt; console.log('我是箭头函数');fun();// 2、只有1个形参，()可以省略let fun2 = a =&gt; console.log(a);fun2('aaa');// 3、两个及以上形参，()不能省略let fun3 = (x, y) =&gt; console.log(x, y);fun3(25, 36);// 不同函数体的情况// 1、函数体只有一条语句或是表达式的时候，&#123;&#125;可以省略。会自动返回语句执行的结果或是表达式的结果let fun4 = (x, y) =&gt; x + y;console.log(fun4(24, 36));// 2、函数体不止一条语句或表达式的情况下，&#123;&#125;不可以省略let fun5 = (x, y) =&gt; &#123; console.log(x, y); return x + y;&#125;console.log(fun5(35, 50));let obj = &#123; name: '箭头函数', // getName()&#123; getName: () =&gt; &#123; btn2.onclick = () =&gt; &#123; console.log(this); &#125; &#125;&#125;// 等价于 obj.getName = () =&gt; &#123;&#125;，所以this是Window对象obj.getName(); 三点运算符12345678910111213141516171819* 用途1. rest(可变)参数 * 用来取代arguments 但比 arguments 灵活,只能是最后部分形参参数 function fun(...values) &#123; console.log(arguments); arguments.forEach(function (item, index) &#123; console.log(item, index); &#125;); console.log(values); values.forEach(function (item, index) &#123; console.log(item, index); &#125;) &#125; fun(1,2,3);2. 扩展运算符 let arr1 &#x3D; [1,3,5]; let arr2 &#x3D; [2,...arr1,6]; console.log(arr2); console.log(...arr2); 形参默认值12345* 形参的默认值----当不传入参数的时候默认使用形参里的默认值function Point(x &#x3D; 1,y &#x3D; 2) &#123; this.x &#x3D; x; this.y &#x3D; y;&#125; Promise对象123456789101112131415161718192021222324252627282930313233341. 理解: * Promise对象: 代表了未来某个将要发生的事件(通常是一个异步操作) * 有了promise对象, 可以将异步操作以同步的流程表达出来, 避免了层层嵌套的回调函数(俗称&#39;回调地狱&#39;) * ES6的Promise是一个构造函数, 用来生成promise实例2. 使用promise基本步骤(2步): * 创建promise对象 let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123; &#x2F;&#x2F;初始化promise状态为 pending &#x2F;&#x2F;执行异步操作 if(异步操作成功) &#123; resolve(value);&#x2F;&#x2F;修改promise的状态为fullfilled &#125; else &#123; reject(errMsg);&#x2F;&#x2F;修改promise的状态为rejected &#125; &#125;) * 调用promise的then() promise.then( result &#x3D;&gt; console.log(result), errorMsg &#x3D;&gt; alert(errorMsg) )3. promise对象的3个状态 * pending: 初始化状态 * fullfilled: 成功状态 * rejected: 失败状态4. 应用: * 使用promise实现超时处理 * 使用promise封装处理ajax请求 let request &#x3D; new XMLHttpRequest(); request.onreadystatechange &#x3D; function () &#123; &#125; request.responseType &#x3D; &#39;json&#39;; request.open(&quot;GET&quot;, url); request.send(); 示例代码： 12345678910111213141516171819202122// 创建promise对象let promise = new Promise((resolve, reject) =&gt; &#123; // 初始化promise状态：pending: 初始化 console.log('111'); // 执行异步操作，通常是发送ajax请求、开启定时器 setTimeout(function () &#123; console.log('333'); // 根据异步任务的返回结果去修改promise状态 // 异步任务执行成功 resolve('哈哈');// 修改promise的状态为 fullfilled: 成功的状态 // 异步任务执行失败 // reject('555');// 修改promise的状态为 rejected: 失败的状态 &#125;, 2000);&#125;)console.log('222');promise.then((data) =&gt; &#123;// 成功的回调 console.log(data, '成功了！')&#125;, (error) =&gt; &#123;// 失败的回调 console.log(error, '失败了。。。')&#125;) 应用案例： 123456789101112131415161718192021222324252627282930313233343536373839404142// 定义获取新闻的函数function getNews(url)&#123; let promise = new Promise((resolve, reject) =&gt; &#123; // 状态：初始化 // 执行异步任务 // 创建xmlHttp实例对象 let xmlHttp = new XMLHttpRequest(); // 绑定监听 readyState xmlHttp.onreadystatechange = function()&#123; if(xmlHttp.readyState === 4)&#123; if(xmlHttp.status == 200)&#123;// 请求成功 // 修改状态 resolve(xmlHttp.responseText);// 修改promise的状态为成功的状态 &#125;else&#123;// 请求失败 reject('暂时没有新闻内容'); &#125; &#125; &#125; // open 设置请求的方式以及url xmlHttp.open('GET', url); // 发送 xmlHttp.send(); &#125;) return promise;&#125;getNews('http://localhost:3000/news?id=2').then((data) =&gt; &#123; console.log(data); // 发送请求获取评论内容准备url let commentsUrl = JSON.parse(data).commentsUrl; let url = 'http://localhost:3000' + commentsUrl; // 发送请求 return getNews(url);&#125;, (error) =&gt; &#123; console.log(error);&#125;).then((data) =&gt; &#123; console.log(data);&#125;, (error) =&gt; &#123;&#125;) Symbol123456789101112131415161718192021前言：ES5中对象的属性名都是字符串，容易造成重名，污染环境Symbol： 概念：ES6中的添加了一种原始数据类型symbol(已有的原始数据类型：String, Number, boolean, null, undefined, 对象) 特点： 1、Symbol属性对应的值是唯一的，解决命名冲突问题 2、Symbol值不能与其他数据进行计算，包括同字符串拼串 3、for in, for of遍历时不会遍历symbol属性。 使用： 1、调用Symbol函数得到symbol值 let symbol &#x3D; Symbol(); let obj &#x3D; &#123;&#125;; obj[symbol] &#x3D; &#39;hello&#39;; 2、传参标识 let symbol &#x3D; Symbol(&#39;one&#39;); let symbol2 &#x3D; Symbol(&#39;two&#39;); console.log(symbol);&#x2F;&#x2F; Symbol(&#39;one&#39;) console.log(symbol2);&#x2F;&#x2F; Symbol(&#39;two&#39;) 3、内置Symbol值 * 除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。 - Symbol.iterator * 对象的Symbol.iterator属性，指向该对象的默认遍历器方法 示例代码： 1234567891011121314151617181920// 创建Symbol属性值let symbol = Symbol();console.log(symbol);let obj = &#123;username: 'kobe', age: 39&#125;;obj[symbol] = 'hello';console.log(obj);// for in, for of遍历时不会遍历symbol属性for(let i in obj)&#123; console.log(i);&#125;let symbol2 = Symbol('one');let symbol3 = Symbol('two');console.log(symbol2 == symbol3);// falseconsole.log(symbol2, symbol3);// 可以去定义常量const Person_key = Symbol('person_key');console.log(Person_key); Iterator遍历器12345678910111213141516171819概念： iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制作用： 1、为各种数据结构，提供一个统一的、简便的访问接口； 2、使得数据结构的成员能够按某种次序排列 3、ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费。工作原理： - 创建一个指针对象(遍历器对象)，指向数据结构的起始位置。 - 第一次调用next方法，指针自动指向数据结构的第一个成员 - 接下来不断调用next方法，指针会一直往后移动，直到指向最后一个成员 - 每调用next方法返回的是一个包含value和done的对象，&#123;value: 当前成员的值,done: 布尔值&#125; * value表示当前成员的值，done对应的布尔值表示当前的数据的结构是否遍历结束。 * 当遍历结束的时候返回的value值是undefined，done值为false原生具备iterator接口的数据(可用for of遍历) 1、Array 2、arguments 3、set容器 4、map容器 5、String 。。。 实现模拟 Iterator 遍历器： 1234567891011121314151617// 模拟指针对象（遍历器对象）function myIterator(arr)&#123;// iterator接口 let nextIndex = 0;// 记录指针的位置 return &#123; next: function()&#123; return nextIndex &lt; arr.length ? &#123;value: arr[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125;&#125;// 准备一个数据let arr = [1, 4, 65, 'abc'];let iteratorObj = myIterator(arr);console.log(iteratorObj.next());console.log(iteratorObj.next());console.log(iteratorObj.next());console.log(iteratorObj.next());console.log(iteratorObj.next()); 示例代码： 12345678910111213141516let arr = [1, 4, 65, 'abc'];// 将iterator接口部署到指定的数据类型上，可以使用for of去循环遍历// 数组、字符串、arguments、set容器、map容器for(let i of arr)&#123; console.log(i);&#125;let str = 'abcdefg';for(let i of str)&#123; console.log(i);&#125;function fun()&#123; for(let i of arguments)&#123; console.log(i); &#125;&#125;fun(1,4,5,'abc'); 扩展： 1234567891011121314151617181920212223242526272829303132333435// 对象的Symbol.iterator属性，指向该对象的默认遍历器方法// 等同于在指定的数据内结构上部署了iterator接口，// 当使用for of去遍历某一个数据结构时，首先先去找Symbol.iterator，找到了就去遍历，没有找到的话不能遍历 ==》 xxx is not iterablelet targetData = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3, [Symbol.iterator]: function() &#123; let nextIndex = 0;// 记录指针的位置 return &#123; next: () =&gt; &#123; return nextIndex &lt; this.length ? &#123;value: this[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125; &#125;&#125;// 定义了Symbol.iterator之后，Object也可以用for of遍历了for(let i of targetData)&#123; console.log(i);&#125;// 用Symbol.iterator去迭代let numbers = [1,2,3,4,5];let iterator = numbers[Symbol.iterator]();console.log(iterator.next().value);console.log(iterator.next().value);// 使用三点运算符、解构赋值，默认去调用iterator接口let arr2 = [1, 6];let arr3 = [2, 3, 4, 5];arr2 = [1, ...arr3, 6];console.log(arr2);let [a, b] = arr2;console.log(a, b); Generator函数123456789101112131415161718Generator函数 概念： 1、ES6提供的解决异步编程的方案之一 2、Generator函数是一个状态机，内部封装了不同状态的数据， 3、用来生成遍历器对象 4、可暂停函数(惰性求值), yield可暂停，next方法可启动。每次返回的是yield后的表达式结果 特点： 1、function 与函数名之间有一个星号 2、内部用yield表达式来定义不同的状态 例如： function* generatorExample()&#123; let result &#x3D; yield &#39;hello&#39;; &#x2F;&#x2F; 状态值为hello yield &#39;generator&#39;; &#x2F;&#x2F; 状态值为generator &#125; 3、generator函数返回的是指针对象，而不会执行函数内部逻辑 4、调用next方法函数内部逻辑开始执行，遇到yield表达式停止，返回&#123;value: yield后的表达式结果&#x2F;undefined, done: false&#x2F;true&#125; 5、再次调用next方法会从上一次停止时的yield处开始，直到最后 6、yield语句返回结果通常为undefined， 当调用next方法时传参内容会作为启动时yield语句的返回值。 示例代码： 12345678910111213141516171819202122232425function* myGenerator()&#123; console.log('开始执行'); let result = yield 'hello'; console.log(result);// 打印结果==》传入的参数aaa console.log('暂停后，再次执行'); yield 'generator'; console.log('遍历完毕'); return '返回的结果';&#125;let mg = myGenerator();// 返回的是指针对象console.log(mg);console.log(mg.next());// &#123;value: \"hello\", done: false&#125;console.log(mg.next('传入的参数aaa'));// &#123;value: \"generator\", done: false&#125;console.log(mg.next());// &#123;value: \"返回的结果\", done: true&#125;// 对象的symbol.iterator属性 指向遍历器对象let obj = &#123;username: 'kobe', age: 39&#125;;obj[Symbol.iterator] = function* myTest()&#123; yield 1 yield 2 yield 3&#125;for(let i of obj)&#123; console.log(i);&#125; 应用案例： 12345678910111213141516171819202122/* * 需求： * 1、发送ajax请求获取新闻内容 * 2、新闻内容获取成功后再次发送请求，获取对应的新闻评论内容 * 3、新闻内容获取失败则不需要再次发送请求。 * */ function getNews(url)&#123; $.get(url, function (data)&#123; console.log(data); let url = 'http://localhost:3000' + data.commentsUrl; SX.next(url); &#125;) &#125; function* sendXml()&#123; let url = yield getNews('http://localhost:3000/news?id=3'); yield getNews(url); &#125; // 获取遍历器对象 let SX = sendXml(); SX.next(); async函数12345678910111213async函数(源自ES2017)概念： 真正意义上去解决异步回调的问题，同步流程表达异步操作本质： Generator的语法糖语法： async function foo()&#123; await 异步操作; await 异步操作； &#125;特点： 1、不需要像Generator去调用next方法，遇到await等待，当前的异步操作完成就往下执行 2、返回的总是Promise对象，可以用then方法进行下一步操作 3、async取代Generator函数的星号*，await取代Generator的yield 4、语意上更为明确，使用简单，经临床验证，暂时没有任何副作用 示例代码： 12345678910111213// async基本使用function foo()&#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, 2000); &#125;)&#125;async function test()&#123; console.log('开始执行', new Date().toTimeString()); await foo(); console.log('执行完毕。。。', new Date().toTimeString());&#125;test(); 应用案例： 12345678910111213141516171819// 获取新闻内容async function getNews(url)&#123; return new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; method: 'GET', url, success: data =&gt; resolve(data), error: error =&gt; reject(error) &#125;) &#125;)&#125;async function sendXml()&#123; let result = await getNews('http://localhost:3000/news?id=3'); console.log(result); result = await getNews('http://localhost:3000' + result.commentsUrl); console.log(result);&#125;sendXml(); class面向对象1234561. 通过class定义类&#x2F;实现类的继承2. 在类中通过constructor定义构造方法3. 通过new来创建类的实例4. 通过extends来实现类的继承5. 通过super调用父类的构造方法6. 重写从父类中继承的一般方法 示例代码： 12345678910111213141516171819202122232425262728293031// 定义一个人物的类class Person&#123; // 类的构造方法 constructor(name, age)&#123; this.name = name; this.age = age; &#125; // 类的一般方法 showName()&#123; console.log(this.name, this.age); &#125;&#125;let person = new Person('kobe', 39);console.log(person);person.showName();// 子类class StarPerson extends Person&#123; constructor(name, age, salary)&#123; super(name, age);// 调用父类的构造方法 this.salary = salary; &#125; // 子类的方法重写 showName()&#123; console.log(this.name, this.age, this.salary); &#125;&#125;let p1 = new StarPerson('wade', 36, 100000000);console.log(p1);p1.showName(); ModuleES6（其他）字符串扩展12341. includes(str) : 判断是否包含指定的字符串2. startsWith(str) : 判断是否以指定字符串开头3. endsWith(str) : 判断是否以指定字符串结尾4. repeat(count) : 重复指定次数 示例代码： 123456let str = 'abc';console.log(str.includes('t'));console.log(str.includes('a'));console.log(str.startsWith('a'));console.log(str.endsWith('f'));console.log(str.repeat(3));// abcabcabc 数值扩展1234561. 二进制与八进制数值表示法: 二进制用0b, 八进制用0o2. Number.isFinite(i) : 判断是否是有限大的数3. Number.isNaN(i) : 判断是否是NaN4. Number.isInteger(i) : 判断是否是整数5. Number.parseInt(str) : 将字符串转换为对应的数值6. Math.trunc(i) : 直接去除小数部分 示例代码： 123456789console.log(0b1010);// 10console.log(0o56);// 46console.log(Number.isFinite(Infinity));// falseconsole.log(Number.isNaN(NaN));// trueconsole.log(Number.isInteger(123.12));// falseconsole.log(Number.isInteger(123.0));// trueconsole.log(Number.parseInt('123abc222'));// 123console.log(Number.parseInt('abc222'));// NaNconsole.log(Math.trunc(123.12));// 123 数组扩展12341. Array.from(v) : 将伪数组对象或可遍历对象转换为真数组2. Array.of(v1, v2, v3) : 将一系列值转换成数组3. find(function(value, index, arr)&#123;return true&#125;) : 找出第一个满足条件返回true的元素4. findIndex(function(value, index, arr)&#123;return true&#125;) : 找出第一个满足条件返回true的元素下标 示例代码： 123456789101112131415161718let btns = document.getElementsByTagName('button');console.log(btns);Array.from(btns).forEach(function(item, index)&#123; console.log(item);&#125;)let arr = Array.of(1,3,'abc',true);console.log(arr);let arr2 = [2,3,4,2,5,7,3,6,5];let result = arr2.find(function(item, index)&#123; return item &gt; 4;&#125;)console.log(result);result = arr2.findIndex(function(item, index)&#123; return item &gt; 4;&#125;)console.log(result); Object扩展12345671. Object.is(v1, v2) * 判断2个数据是否完全相等（其实是用字符串比较）2. Object.assign(target, source1, source2..) * 将源对象的属性复制到目标对象上3. 直接操作 __proto__ 属性 let obj2 &#x3D; &#123;&#125;; obj2.__proto__ &#x3D; obj1; 示例代码： 12345678910111213141516console.log(0 == -0);// trueconsole.log(NaN == NaN);// falseconsole.log(Object.is(0, -0));// falseconsole.log(Object.is(NaN, NaN));// truelet obj = &#123;&#125;;let obj1 = &#123;username: 'iverson', age:42&#125;;let obj2 = &#123;sex: '男'&#125;;Object.assign(obj, obj1, obj2);console.log(obj);let obj3 = &#123;&#125;;let obj4 = &#123;qian: 5000000&#125;;obj3.__proto__ = obj4;console.log(obj3);console.log(obj3.qian); 深度克隆123456789101112131415161718192021221、数据类型： * 数据分为基本的数据类型(String, Number, boolean, Null, Undefined)和对象数据类型 - 基本数据类型： 特点： 存储的是该对象的实际数据 - 对象数据类型： 特点： 存储的是该对象在栈中引用，真实的数据存放在堆内存里2、复制数据 - 基本数据类型存放的就是实际的数据，可直接复制 let number2 &#x3D; 2; let number1 &#x3D; number2; - 克隆数据：对象&#x2F;数组 1、区别： 浅拷贝&#x2F;深度拷贝 判断： 拷贝是否产生了新的数据还是拷贝的是数据的引用 知识点：对象数据存放的是对象在栈内存的引用，直接复制的是对象的引用 let obj &#x3D; &#123;username: &#39;kobe&#39;&#125; let obj1 &#x3D; obj; &#x2F;&#x2F; obj1 复制了obj在栈内存的引用 2、常用的拷贝技术 1). arr.concat(): 数组浅拷贝 2). arr.slice(): 数组浅拷贝 3). JSON.parse(JSON.stringify(arr&#x2F;obj)): 数组或对象深拷贝, 但不能处理函数数据 4). 浅拷贝包含函数数据的对象&#x2F;数组 5). 深拷贝包含函数数据的对象&#x2F;数组 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 不会影响原数据let str = 'abcd';let str2 = str;console.log(str2);str2 = '';console.log(str);let bool1 = true;let bool2 = bool1;bool2 = false;console.log(bool1);// 拷贝数组/对象，没有生成新的数据而是复制了一份引用let obj = &#123;username: 'kobe', age: 39&#125;;let obj2 = obj;console.log(obj2);obj2.username = 'wade';console.log(obj.username);let arr = [1, 4, &#123;username: 'kobe', age: 39&#125;];let arr2 = arr;arr2[0] = 'abcd';console.log(arr, arr2);/** * 拷贝数据： * 基本数据类型： * 拷贝后会生成一份新的数据，修改拷贝以后的数据不会影响原数据 * 对象/数组： * 拷贝后不会生成新的数据，而是拷贝的引用。修改拷贝以后的数据会影响原来的数据 * * 拷贝数据的方法： * 1.直接赋值给一个变量 // 浅拷贝 * 2.Object.assign() // 浅拷贝 * 3.Array.prototype.concat() // 浅拷贝 * 4.Array.prototype.slice() // 浅拷贝 * 5.JSON.parse(JSON.stringify()) // 深拷贝（深度克隆），但不能处理函数数据 * * 浅拷贝（对象/数组） * 特点：拷贝的引用，修改拷贝以后的数据会影响原数据，使得原数据不安全 * 深拷贝（深度克隆） * 特点：拷贝的时候生成新数据，修改拷贝以后的数据不会影响原数据 */&#123;let obj = &#123;username: 'kobe'&#125;;let obj2 = Object.assign(obj);console.log(obj2);obj.username = 'wade';console.log(obj2);let arr = [1, 3, &#123;username: 'kobe'&#125;, function fun()&#123;&#125;];let arr2 = arr.concat();arr2[0] = 2;// 这个修改不影响arr的第一个元素，因为是复制的基本类型arr2[2].username = 'wade';// 这个修改会影响原数据，因为复制是对象的引用console.log(arr);let arr3 = arr.slice();arr3[2].username = 'iverson';// 会影响console.log(arr);let arr4 = JSON.parse(JSON.stringify(arr));console.log(arr4);arr4[2].username = 'duncan';// 不影响console.log(arr, arr4); 实现深度克隆前的知识储备： 12345678910111213141516171819202122/** * 思考：如何实现深度拷贝（克隆） * 即使有对象/数组，也可以继续遍历对象/数组拿到里边每一项值，直到拿到的是基本数据类型，然后再去复制，就是深度拷贝 * * 如何判断数据类型：arr --&gt; Array null --&gt; Null * 1.typeof返回的数据类型：String, Number, Boolean, Undefined, Object, Function * 2.Object.prototype.toString.call(this) */let result= 'abcd';result = null;result = [1, 3];console.log(Object.prototype.toString.call(result).slice(8, -1));// for in循环，对象（属性名） 数组（下标）let obj6 = &#123;username: 'kobe', age: 39&#125;;for (let i in obj6)&#123; console.log(i);&#125;let arr6 = [1, 3, 'abc'];for (let i in arr6)&#123; console.log(i);&#125; 实现深度克隆： 123456789101112131415161718192021222324252627282930313233343536373839404142// 定义检测数据类型的功能函数function checkType(target)&#123; return Object.prototype.toString.call(target).slice(8, -1);&#125;// 实现深度克隆 --&gt; 对象/数组function clone(target)&#123; // 判断拷贝的数据类型 // 初始化变量result成为最终克隆的数据 let result, targetType = checkType(target); if(targetType === 'Object')&#123; result = &#123;&#125;; &#125;else if(targetType === 'Array')&#123; result = []; &#125;else&#123; return target; &#125; // 遍历目标数据 for(let i in target)&#123; // 获取遍历数据结构的每一项值 let value = target[i]; // 判断目标结构里的每一项值是否存在对象/数组 if(checkType(value) === 'Object' || checkType(value) === 'Array')&#123;// 对象/数组里嵌套了对象/数组 // 继续遍历获取到的value值 result[i] = clone(value); &#125;else&#123;// 获取到的value值是基本的数据类型或函数 result[i] = value; &#125; &#125; return result;&#125;let arr7 = [1, 2, &#123;username: 'kobe', age:39&#125;];let arr8 = clone(arr7);console.log(arr8);arr8[2].username = 'wade';console.log(arr7, arr8);let obj7 = &#123;username: 'kobe', age: 39&#125;;let obj8 = clone(obj7);console.log(obj8);obj8.username = 'wade';console.log(obj7, obj8); Set和Map12345678910111213141516171. Set容器 : 无序不可重复的多个value的集合体 * Set() * Set(array) * add(value) * delete(value) * has(value) * clear() * size2. Map容器 : 无序的 key不重复的多个key-value的集合体 * Map() * Map(array) * set(key, value)&#x2F;&#x2F;添加 * get(key) * delete(key) * has(key) * clear() * size 示例代码： 123456789101112131415161718let set = new Set([1,2,4,5,2,3,6]);console.log(set);set.add(7);console.log(set.size, set);console.log(set.has(8));// falseconsole.log(set.has(7));// trueset.delete(4);console.log(set);set.clear();console.log(set);let map = new Map([['username', 'kobe'], [36, 'age']]);console.log(map);map.set(78, 'haha');console.log(map);map.delete(36);console.log(map);console.log(map.size); for of循环123456for(let value of target)&#123;&#125;循环遍历 1. 遍历数组 2. 遍历Set 3. 遍历Map 4. 遍历字符串 5. 遍历伪数组 示例代码： 123456789101112131415// 数组去重let arr = [1,2,4,5,5,6,2];let arr1 = arr;arr = [];let set = new Set(arr1);for (let i of set)&#123; arr.push(i);&#125;console.log(arr);// 遍历伪数组let btns = document.getElementsByTagName('button');for(let i of btns)&#123; console.log(i);&#125; ES7121. 指数运算符(幂): **2. Array.prototype.includes(value) : 判断数组中是否包含指定value 示例代码： 123console.log(3 ** 3);// 27let arr = [1,4,5,6,'abc'];console.log(arr.includes(6));// true","tags":[{"name":"前端","slug":"前端","permalink":"https://sunshine-zwq.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"https://sunshine-zwq.github.io/tags/ECMAScript/"}]}]