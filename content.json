[{"title":"ECMAScript入门","date":"2020-03-18T16:43:38.000Z","path":"2020/03/19/ECMAScript入门/","text":"基本介绍123456789101112131. 它是一种由ECMA组织（前身为欧洲计算机制造商协会）制定和发布的脚本语言规范2. 而我们学的 JavaScript 是ECMA的实现, 但术语ECMAScript和JavaScript平时表达同一个意思3. JS包含三个部分： 1). ECMAScript（核心） 2). 扩展&#x3D;&#x3D;&gt;浏览器端 * BOM（浏览器对象模型） * DOM（文档对象模型） 3). 扩展&#x3D;&#x3D;&gt;服务器端 * Node4. ES的几个重要版本 * ES5 : 09年发布 * ES6(ES2015) : 15年发布, 也称为ECMA2015 * ES7(ES2016) : 16年发布, 也称为ECMA2016 (变化不大) ES5严格模式1234567891011121314151. 理解: * 除了正常运行模式(混杂模式)，ES5添加了第二种运行模式：&quot;严格模式&quot;（strict mode）。 * 顾名思义，这种模式使得Javascript在更严格的语法条件下运行2. 目的&#x2F;作用 * 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 * 消除代码运行的一些不安全之处，为代码的安全运行保驾护航 * 为未来新版本的Javascript做好铺垫3. 使用 * 在全局或函数的第一条语句定义为: &#39;use strict&#39;; * 如果浏览器不支持, 只解析为一条简单的语句, 没有任何副作用4. 语法和行为改变 * 必须用var声明变量 * 禁止自定义的函数中的this指向window * 创建eval作用域 * 对象不能有重名的属性 示例代码： 12345678910111213141516171819202122&lt;script type=\"text/javascript\"&gt; 'use strict'; // username = 'kobe'; var username = 'kobe'; console.log(username); function Person (name, age) &#123; this.name = name; this.age = age; &#125; // Person('kobe', 41); new Person('kobe', 41); var str = 'NBA'; eval('var str = \"CBA\"; alert(str)'); alert(str); var obj = &#123; username: 'kobe', // username: 'wade' &#125;&lt;/script&gt; JSON对象12341. JSON.stringify(obj&#x2F;arr) * js对象(数组)转换为json对象(数组)2. JSON.parse(json) * json对象(数组)转换为js对象(数组) Object扩展12345678910111213ES5给Object扩展了一些静态方法, 常用的2个:1. Object.create(prototype, [descriptors]) * 作用: 以指定对象为原型创建新的对象 * 为新的对象指定新的属性, 并对属性进行描述 - value : 指定值 - writable : 标识当前属性值是否是可修改的, 默认为false - configurable: 标识当前属性是否可以被删除 默认为false - enumerable： 标识当前属性是否能用for in 枚举 默认为false2. Object.defineProperties(object, descriptors) * 作用: 为指定对象定义扩展多个属性 * get ：用来获取当前属性值的回调函数（需要取值时才会调用，“惰性求值”） * set ：修改当前属性值得触发的回调函数，并且实参即为修改后的值 * 存取器属性：setter,getter一个用来存值，一个用来取值 示例代码： 12345678910111213141516171819202122232425262728293031323334353637var obj = &#123;username: 'damu', age: 30&#125;;var obj1 = &#123;&#125;;obj1 = Object.create(obj, &#123; sex: &#123; value: '男', writable: true, configurable: true, enumerable: true &#125;&#125;);console.log(obj1.sex);obj1.sex = '女';console.log(obj1.sex);// delete obj1.sex;console.log(obj1);for(var i in obj1)&#123; console.log(i);&#125;var obj2 = &#123;firstName: 'kobe', lastName: 'bryant'&#125;;Object.defineProperties(obj2, &#123; fullName: &#123; get: function()&#123;// 获取扩展属性的值（获取扩展属性值时get会自动调用） return this.firstName + ' ' + this.lastName; &#125;, set: function(data)&#123;// 监听扩展属性，当扩展属性发生变化的时候会自动调用（变化后的值作为实参传入） var names = data.split(' '); this.firstName = names[0]; this.lastName = names[1]; &#125; &#125;&#125;)console.log(obj2.fullName);obj2.fullName = 'tim duncan';console.log(obj2.fullName);console.log(obj2.lastName); 123对象本身的两个方法* get propertyName()&#123;&#125; 用来得到当前属性值的回调函数* set propertyName()&#123;&#125; 用来监视当前属性值变化的回调函数 示例代码： 123456789101112131415var obj = &#123; firstName: 'curry', lastName: 'stephen', get fullName()&#123; return this.firstName + ' ' + this.lastName; &#125;, set fullName(data)&#123; var names = data.split(' '); this.firstName = names[0]; this.lastName = names[1]; &#125;&#125;;console.log(obj);obj.fullName = 'kobe bryant';console.log(obj.fullName); Array扩展123451. Array.prototype.indexOf(value) : 得到值在数组中的第一个下标2. Array.prototype.lastIndexOf(value) : 得到值在数组中的最后一个下标3. Array.prototype.forEach(function(item, index)&#123;&#125;) : 遍历数组4. Array.prototype.map(function(item, index)&#123;&#125;) : 遍历数组返回一个新的数组，返回加工之后的值5. Array.prototype.filter(function(item, index)&#123;&#125;) : 遍历过滤出一个新的子数组， 返回条件为true的值 示例代码： 12345678910111213141516171819202122232425/* 需求: 1. 输出第一个6的下标 2. 输出最后一个6的下标 3. 输出所有元素的值和下标 4. 根据arr产生一个新数组,要求每个元素都比原来大10 5. 根据arr产生一个新数组, 返回的每个元素要大于4 */var arr = [2,4,3,1,2,6,5,4];console.log(arr.indexOf(4));console.log(arr.lastIndexOf(4));arr.forEach(function(item, index)&#123; console.log(item, index);&#125;)var arr1 = arr.map(function (item, index) &#123; return item + 10;&#125;)console.log(arr1);var arr2 = arr.filter(function (item, index) &#123; return item &gt; 4;&#125;)console.log(arr2); Function扩展1234561. Function.prototype.bind(obj) : * 作用: 将函数内的this绑定为obj, 并将函数返回2. 面试题: 区别bind()与call()和apply()? * 都能指定函数中的this * call()&#x2F;apply()是立即调用函数 * bind()是将函数返回 示例代码： 123456789101112131415161718192021var obj = &#123;username: 'kobe'&#125;;function foo(data)&#123; console.log(this, data);&#125;// 直接调用foo方法打印的this是Window// foo();// call和apply的方法作用一样，区别在于传参的方式foo.call(obj, 33);// 直接从第2个参数开始，依次传入foo.apply(obj, [33]);// 第二个参数必须是数组，参数放在数组里// bind的特点：绑定完this不会立即调用当前的函数，而是将函数返回var bar = foo.bind(obj);bar();// bind的传参方式和call一样foo.bind(obj, 33)();// 应用举例setTimeout(function()&#123; console.log(this);&#125;.bind(obj), 1000); ES6（常用）let关键字1234567891. 作用: * 与var类似, 用于声明一个变量2. 特点: * 在块作用域内有效 * 不能重复声明 * 不会预处理（即不能在声明之前使用，会抛出异常，而var在声明前使用值是undefined）, 不存在提升3. 应用: * 循环遍历加监听 * 使用let取代var是趋势 示例代码： 1234567891011121314151617181920212223242526272829303132333435// console.log(username);let username = 'kobe';// let username = 'wade';console.log(username);let btns = document.getElementsByTagName('button');for(var i = 0; i &lt; btns.length; i++)&#123; var btn = btns[i]; btn.onclick = function () &#123; // 打印出来的都是3 alert(i); &#125;&#125;// 解决方法1：用闭包函数btns = document.getElementsByTagName('button');for(var i = 0; i &lt; btns.length; i++)&#123; var btn = btns[i]; (function(i)&#123; btn.onclick = function () &#123; // 打印出来的都是3 alert(i); &#125; &#125;)(i)&#125;// 解决方法2：用let关键字btns = document.getElementsByTagName('button');for(let i = 0; i &lt; btns.length; i++)&#123; var btn = btns[i]; btn.onclick = function () &#123; // 打印出来的都是3 alert(i); &#125;&#125; const关键字12345671. 作用: * 定义一个常量2. 特点: * 不能修改 * 其它特点同let3. 应用: * 保存不用改变的数据 解构赋值123456781. 理解: * 从对象或数组中提取数据, 并赋值给变量(多个)2. 对象的解构赋值 let &#123;n, a&#125; &#x3D; &#123;n:&#39;tom&#39;, a:12&#125;3. 数组的解构赋值 let [a,b] &#x3D; [1, &#39;atguigu&#39;];4. 用途 * 给多个形参赋值 示例代码： 1234567891011121314let obj = &#123;username: 'kobe', age: 39&#125;;// let username = obj.username;// let age = obj.age;let &#123;username, age&#125; = obj;console.log(username, age);let arr = [1,3,5,'abc',true];let [,,a,b] = arr;console.log(a, b);function foo(&#123;username, age&#125;)&#123;// &#123;username, age&#125; = obj console.log(username, age);&#125;foo(obj); 模板字符串1231. 模板字符串 : 简化字符串的拼接 * 模板字符串必须用 &#96;&#96; 包含 * 变化的部分使用$&#123;xxx&#125;定义 示例代码： 12345let obj = &#123;username: 'kobe', age: 39&#125;;let str = '我的名字叫：' + obj.username + '，我今年的年龄是：' + obj.age;console.log(str);str = `我的名字叫：$&#123;obj.username&#125;，我今年的年龄是：$&#123;obj.age&#125;`;console.log(str); 简化的对象写法1234567891011简化的对象写法* 省略同名的属性值* 省略方法的function* 例如: let x &#x3D; 1; let y &#x3D; 2; let point &#x3D; &#123; x, y, setX (x) &#123;this.x &#x3D; x&#125; &#125;; 箭头函数123456789101112131415* 作用: 定义匿名函数* 基本语法: * 没有参数: () &#x3D;&gt; console.log(&#39;xxxx&#39;) * 一个参数: i &#x3D;&gt; i+2 * 大于一个参数: (i,j) &#x3D;&gt; i+j * 函数体不用大括号: 默认返回结果 * 函数体如果有多个语句, 需要用&#123;&#125;包围，若有需要返回的内容，需要手动返回* 使用场景: 多用来定义回调函数* 箭头函数的特点： 1、简洁 2、箭头函数没有自己的this，箭头函数的this不是调用的时候决定的，而是在定义的时候处在的对象就是它的this 3、扩展理解： 箭头函数的this看外层的是否有函数， 如果有，外层函数的this就是内部箭头函数的this， 如果没有，则this是window。 示例代码： 123456789101112131415161718192021222324252627282930313233// 不同传参的情况// 1、没有形参let fun = () =&gt; console.log('我是箭头函数');fun();// 2、只有1个形参，()可以省略let fun2 = a =&gt; console.log(a);fun2('aaa');// 3、两个及以上形参，()不能省略let fun3 = (x, y) =&gt; console.log(x, y);fun3(25, 36);// 不同函数体的情况// 1、函数体只有一条语句或是表达式的时候，&#123;&#125;可以省略。会自动返回语句执行的结果或是表达式的结果let fun4 = (x, y) =&gt; x + y;console.log(fun4(24, 36));// 2、函数体不止一条语句或表达式的情况下，&#123;&#125;不可以省略let fun5 = (x, y) =&gt; &#123; console.log(x, y); return x + y;&#125;console.log(fun5(35, 50));let obj = &#123; name: '箭头函数', // getName()&#123; getName: () =&gt; &#123; btn2.onclick = () =&gt; &#123; console.log(this); &#125; &#125;&#125;// 等价于 obj.getName = () =&gt; &#123;&#125;，所以this是Window对象obj.getName(); 三点运算符12345678910111213141516171819* 用途1. rest(可变)参数 * 用来取代arguments 但比 arguments 灵活,只能是最后部分形参参数 function fun(...values) &#123; console.log(arguments); arguments.forEach(function (item, index) &#123; console.log(item, index); &#125;); console.log(values); values.forEach(function (item, index) &#123; console.log(item, index); &#125;) &#125; fun(1,2,3);2. 扩展运算符 let arr1 &#x3D; [1,3,5]; let arr2 &#x3D; [2,...arr1,6]; console.log(arr2); console.log(...arr2); 形参默认值12345* 形参的默认值----当不传入参数的时候默认使用形参里的默认值function Point(x &#x3D; 1,y &#x3D; 2) &#123; this.x &#x3D; x; this.y &#x3D; y;&#125; Promise对象123456789101112131415161718192021222324252627282930313233341. 理解: * Promise对象: 代表了未来某个将要发生的事件(通常是一个异步操作) * 有了promise对象, 可以将异步操作以同步的流程表达出来, 避免了层层嵌套的回调函数(俗称&#39;回调地狱&#39;) * ES6的Promise是一个构造函数, 用来生成promise实例2. 使用promise基本步骤(2步): * 创建promise对象 let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123; &#x2F;&#x2F;初始化promise状态为 pending &#x2F;&#x2F;执行异步操作 if(异步操作成功) &#123; resolve(value);&#x2F;&#x2F;修改promise的状态为fullfilled &#125; else &#123; reject(errMsg);&#x2F;&#x2F;修改promise的状态为rejected &#125; &#125;) * 调用promise的then() promise.then( result &#x3D;&gt; console.log(result), errorMsg &#x3D;&gt; alert(errorMsg) )3. promise对象的3个状态 * pending: 初始化状态 * fullfilled: 成功状态 * rejected: 失败状态4. 应用: * 使用promise实现超时处理 * 使用promise封装处理ajax请求 let request &#x3D; new XMLHttpRequest(); request.onreadystatechange &#x3D; function () &#123; &#125; request.responseType &#x3D; &#39;json&#39;; request.open(&quot;GET&quot;, url); request.send(); 示例代码： 12345678910111213141516171819202122// 创建promise对象let promise = new Promise((resolve, reject) =&gt; &#123; // 初始化promise状态：pending: 初始化 console.log('111'); // 执行异步操作，通常是发送ajax请求、开启定时器 setTimeout(function () &#123; console.log('333'); // 根据异步任务的返回结果去修改promise状态 // 异步任务执行成功 resolve('哈哈');// 修改promise的状态为 fullfilled: 成功的状态 // 异步任务执行失败 // reject('555');// 修改promise的状态为 rejected: 失败的状态 &#125;, 2000);&#125;)console.log('222');promise.then((data) =&gt; &#123;// 成功的回调 console.log(data, '成功了！')&#125;, (error) =&gt; &#123;// 失败的回调 console.log(error, '失败了。。。')&#125;) 应用案例： 123456789101112131415161718192021222324252627282930313233343536373839404142// 定义获取新闻的函数function getNews(url)&#123; let promise = new Promise((resolve, reject) =&gt; &#123; // 状态：初始化 // 执行异步任务 // 创建xmlHttp实例对象 let xmlHttp = new XMLHttpRequest(); // 绑定监听 readyState xmlHttp.onreadystatechange = function()&#123; if(xmlHttp.readyState === 4)&#123; if(xmlHttp.status == 200)&#123;// 请求成功 // 修改状态 resolve(xmlHttp.responseText);// 修改promise的状态为成功的状态 &#125;else&#123;// 请求失败 reject('暂时没有新闻内容'); &#125; &#125; &#125; // open 设置请求的方式以及url xmlHttp.open('GET', url); // 发送 xmlHttp.send(); &#125;) return promise;&#125;getNews('http://localhost:3000/news?id=2').then((data) =&gt; &#123; console.log(data); // 发送请求获取评论内容准备url let commentsUrl = JSON.parse(data).commentsUrl; let url = 'http://localhost:3000' + commentsUrl; // 发送请求 return getNews(url);&#125;, (error) =&gt; &#123; console.log(error);&#125;).then((data) =&gt; &#123; console.log(data);&#125;, (error) =&gt; &#123;&#125;) Symbol123456789101112131415161718192021前言：ES5中对象的属性名都是字符串，容易造成重名，污染环境Symbol： 概念：ES6中的添加了一种原始数据类型symbol(已有的原始数据类型：String, Number, boolean, null, undefined, 对象) 特点： 1、Symbol属性对应的值是唯一的，解决命名冲突问题 2、Symbol值不能与其他数据进行计算，包括同字符串拼串 3、for in, for of遍历时不会遍历symbol属性。 使用： 1、调用Symbol函数得到symbol值 let symbol &#x3D; Symbol(); let obj &#x3D; &#123;&#125;; obj[symbol] &#x3D; &#39;hello&#39;; 2、传参标识 let symbol &#x3D; Symbol(&#39;one&#39;); let symbol2 &#x3D; Symbol(&#39;two&#39;); console.log(symbol);&#x2F;&#x2F; Symbol(&#39;one&#39;) console.log(symbol2);&#x2F;&#x2F; Symbol(&#39;two&#39;) 3、内置Symbol值 * 除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。 - Symbol.iterator * 对象的Symbol.iterator属性，指向该对象的默认遍历器方法 示例代码： 1234567891011121314151617181920// 创建Symbol属性值let symbol = Symbol();console.log(symbol);let obj = &#123;username: 'kobe', age: 39&#125;;obj[symbol] = 'hello';console.log(obj);// for in, for of遍历时不会遍历symbol属性for(let i in obj)&#123; console.log(i);&#125;let symbol2 = Symbol('one');let symbol3 = Symbol('two');console.log(symbol2 == symbol3);// falseconsole.log(symbol2, symbol3);// 可以去定义常量const Person_key = Symbol('person_key');console.log(Person_key); Iterator遍历器12345678910111213141516171819概念： iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制作用： 1、为各种数据结构，提供一个统一的、简便的访问接口； 2、使得数据结构的成员能够按某种次序排列 3、ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费。工作原理： - 创建一个指针对象(遍历器对象)，指向数据结构的起始位置。 - 第一次调用next方法，指针自动指向数据结构的第一个成员 - 接下来不断调用next方法，指针会一直往后移动，直到指向最后一个成员 - 每调用next方法返回的是一个包含value和done的对象，&#123;value: 当前成员的值,done: 布尔值&#125; * value表示当前成员的值，done对应的布尔值表示当前的数据的结构是否遍历结束。 * 当遍历结束的时候返回的value值是undefined，done值为false原生具备iterator接口的数据(可用for of遍历) 1、Array 2、arguments 3、set容器 4、map容器 5、String 。。。 实现模拟 Iterator 遍历器： 1234567891011121314151617// 模拟指针对象（遍历器对象）function myIterator(arr)&#123;// iterator接口 let nextIndex = 0;// 记录指针的位置 return &#123; next: function()&#123; return nextIndex &lt; arr.length ? &#123;value: arr[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125;&#125;// 准备一个数据let arr = [1, 4, 65, 'abc'];let iteratorObj = myIterator(arr);console.log(iteratorObj.next());console.log(iteratorObj.next());console.log(iteratorObj.next());console.log(iteratorObj.next());console.log(iteratorObj.next()); 示例代码： 12345678910111213141516let arr = [1, 4, 65, 'abc'];// 将iterator接口部署到指定的数据类型上，可以使用for of去循环遍历// 数组、字符串、arguments、set容器、map容器for(let i of arr)&#123; console.log(i);&#125;let str = 'abcdefg';for(let i of str)&#123; console.log(i);&#125;function fun()&#123; for(let i of arguments)&#123; console.log(i); &#125;&#125;fun(1,4,5,'abc'); 扩展： 1234567891011121314151617181920212223242526272829303132333435// 对象的Symbol.iterator属性，指向该对象的默认遍历器方法// 等同于在指定的数据内结构上部署了iterator接口，// 当使用for of去遍历某一个数据结构时，首先先去找Symbol.iterator，找到了就去遍历，没有找到的话不能遍历 ==》 xxx is not iterablelet targetData = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3, [Symbol.iterator]: function() &#123; let nextIndex = 0;// 记录指针的位置 return &#123; next: () =&gt; &#123; return nextIndex &lt; this.length ? &#123;value: this[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125; &#125;&#125;// 定义了Symbol.iterator之后，Object也可以用for of遍历了for(let i of targetData)&#123; console.log(i);&#125;// 用Symbol.iterator去迭代let numbers = [1,2,3,4,5];let iterator = numbers[Symbol.iterator]();console.log(iterator.next().value);console.log(iterator.next().value);// 使用三点运算符、解构赋值，默认去调用iterator接口let arr2 = [1, 6];let arr3 = [2, 3, 4, 5];arr2 = [1, ...arr3, 6];console.log(arr2);let [a, b] = arr2;console.log(a, b); Generator函数123456789101112131415161718Generator函数 概念： 1、ES6提供的解决异步编程的方案之一 2、Generator函数是一个状态机，内部封装了不同状态的数据， 3、用来生成遍历器对象 4、可暂停函数(惰性求值), yield可暂停，next方法可启动。每次返回的是yield后的表达式结果 特点： 1、function 与函数名之间有一个星号 2、内部用yield表达式来定义不同的状态 例如： function* generatorExample()&#123; let result &#x3D; yield &#39;hello&#39;; &#x2F;&#x2F; 状态值为hello yield &#39;generator&#39;; &#x2F;&#x2F; 状态值为generator &#125; 3、generator函数返回的是指针对象，而不会执行函数内部逻辑 4、调用next方法函数内部逻辑开始执行，遇到yield表达式停止，返回&#123;value: yield后的表达式结果&#x2F;undefined, done: false&#x2F;true&#125; 5、再次调用next方法会从上一次停止时的yield处开始，直到最后 6、yield语句返回结果通常为undefined， 当调用next方法时传参内容会作为启动时yield语句的返回值。 示例代码： 12345678910111213141516171819202122232425function* myGenerator()&#123; console.log('开始执行'); let result = yield 'hello'; console.log(result);// 打印结果==》传入的参数aaa console.log('暂停后，再次执行'); yield 'generator'; console.log('遍历完毕'); return '返回的结果';&#125;let mg = myGenerator();// 返回的是指针对象console.log(mg);console.log(mg.next());// &#123;value: \"hello\", done: false&#125;console.log(mg.next('传入的参数aaa'));// &#123;value: \"generator\", done: false&#125;console.log(mg.next());// &#123;value: \"返回的结果\", done: true&#125;// 对象的symbol.iterator属性 指向遍历器对象let obj = &#123;username: 'kobe', age: 39&#125;;obj[Symbol.iterator] = function* myTest()&#123; yield 1 yield 2 yield 3&#125;for(let i of obj)&#123; console.log(i);&#125; 应用案例： 12345678910111213141516171819202122/* * 需求： * 1、发送ajax请求获取新闻内容 * 2、新闻内容获取成功后再次发送请求，获取对应的新闻评论内容 * 3、新闻内容获取失败则不需要再次发送请求。 * */ function getNews(url)&#123; $.get(url, function (data)&#123; console.log(data); let url = 'http://localhost:3000' + data.commentsUrl; SX.next(url); &#125;) &#125; function* sendXml()&#123; let url = yield getNews('http://localhost:3000/news?id=3'); yield getNews(url); &#125; // 获取遍历器对象 let SX = sendXml(); SX.next(); async函数12345678910111213async函数(源自ES2017)概念： 真正意义上去解决异步回调的问题，同步流程表达异步操作本质： Generator的语法糖语法： async function foo()&#123; await 异步操作; await 异步操作； &#125;特点： 1、不需要像Generator去调用next方法，遇到await等待，当前的异步操作完成就往下执行 2、返回的总是Promise对象，可以用then方法进行下一步操作 3、async取代Generator函数的星号*，await取代Generator的yield 4、语意上更为明确，使用简单，经临床验证，暂时没有任何副作用 示例代码： 12345678910111213// async基本使用function foo()&#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, 2000); &#125;)&#125;async function test()&#123; console.log('开始执行', new Date().toTimeString()); await foo(); console.log('执行完毕。。。', new Date().toTimeString());&#125;test(); 应用案例： 12345678910111213141516171819// 获取新闻内容async function getNews(url)&#123; return new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; method: 'GET', url, success: data =&gt; resolve(data), error: error =&gt; reject(error) &#125;) &#125;)&#125;async function sendXml()&#123; let result = await getNews('http://localhost:3000/news?id=3'); console.log(result); result = await getNews('http://localhost:3000' + result.commentsUrl); console.log(result);&#125;sendXml(); class面向对象1234561. 通过class定义类&#x2F;实现类的继承2. 在类中通过constructor定义构造方法3. 通过new来创建类的实例4. 通过extends来实现类的继承5. 通过super调用父类的构造方法6. 重写从父类中继承的一般方法 示例代码： 12345678910111213141516171819202122232425262728293031// 定义一个人物的类class Person&#123; // 类的构造方法 constructor(name, age)&#123; this.name = name; this.age = age; &#125; // 类的一般方法 showName()&#123; console.log(this.name, this.age); &#125;&#125;let person = new Person('kobe', 39);console.log(person);person.showName();// 子类class StarPerson extends Person&#123; constructor(name, age, salary)&#123; super(name, age);// 调用父类的构造方法 this.salary = salary; &#125; // 子类的方法重写 showName()&#123; console.log(this.name, this.age, this.salary); &#125;&#125;let p1 = new StarPerson('wade', 36, 100000000);console.log(p1);p1.showName(); ModuleES6（其他）字符串扩展12341. includes(str) : 判断是否包含指定的字符串2. startsWith(str) : 判断是否以指定字符串开头3. endsWith(str) : 判断是否以指定字符串结尾4. repeat(count) : 重复指定次数 示例代码： 123456let str = 'abc';console.log(str.includes('t'));console.log(str.includes('a'));console.log(str.startsWith('a'));console.log(str.endsWith('f'));console.log(str.repeat(3));// abcabcabc 数值扩展1234561. 二进制与八进制数值表示法: 二进制用0b, 八进制用0o2. Number.isFinite(i) : 判断是否是有限大的数3. Number.isNaN(i) : 判断是否是NaN4. Number.isInteger(i) : 判断是否是整数5. Number.parseInt(str) : 将字符串转换为对应的数值6. Math.trunc(i) : 直接去除小数部分 示例代码： 123456789console.log(0b1010);// 10console.log(0o56);// 46console.log(Number.isFinite(Infinity));// falseconsole.log(Number.isNaN(NaN));// trueconsole.log(Number.isInteger(123.12));// falseconsole.log(Number.isInteger(123.0));// trueconsole.log(Number.parseInt('123abc222'));// 123console.log(Number.parseInt('abc222'));// NaNconsole.log(Math.trunc(123.12));// 123 数组扩展12341. Array.from(v) : 将伪数组对象或可遍历对象转换为真数组2. Array.of(v1, v2, v3) : 将一系列值转换成数组3. find(function(value, index, arr)&#123;return true&#125;) : 找出第一个满足条件返回true的元素4. findIndex(function(value, index, arr)&#123;return true&#125;) : 找出第一个满足条件返回true的元素下标 示例代码： 123456789101112131415161718let btns = document.getElementsByTagName('button');console.log(btns);Array.from(btns).forEach(function(item, index)&#123; console.log(item);&#125;)let arr = Array.of(1,3,'abc',true);console.log(arr);let arr2 = [2,3,4,2,5,7,3,6,5];let result = arr2.find(function(item, index)&#123; return item &gt; 4;&#125;)console.log(result);result = arr2.findIndex(function(item, index)&#123; return item &gt; 4;&#125;)console.log(result); Object扩展12345671. Object.is(v1, v2) * 判断2个数据是否完全相等（其实是用字符串比较）2. Object.assign(target, source1, source2..) * 将源对象的属性复制到目标对象上3. 直接操作 __proto__ 属性 let obj2 &#x3D; &#123;&#125;; obj2.__proto__ &#x3D; obj1; 示例代码： 12345678910111213141516console.log(0 == -0);// trueconsole.log(NaN == NaN);// falseconsole.log(Object.is(0, -0));// falseconsole.log(Object.is(NaN, NaN));// truelet obj = &#123;&#125;;let obj1 = &#123;username: 'iverson', age:42&#125;;let obj2 = &#123;sex: '男'&#125;;Object.assign(obj, obj1, obj2);console.log(obj);let obj3 = &#123;&#125;;let obj4 = &#123;qian: 5000000&#125;;obj3.__proto__ = obj4;console.log(obj3);console.log(obj3.qian); 深度克隆123456789101112131415161718192021221、数据类型： * 数据分为基本的数据类型(String, Number, boolean, Null, Undefined)和对象数据类型 - 基本数据类型： 特点： 存储的是该对象的实际数据 - 对象数据类型： 特点： 存储的是该对象在栈中引用，真实的数据存放在堆内存里2、复制数据 - 基本数据类型存放的就是实际的数据，可直接复制 let number2 &#x3D; 2; let number1 &#x3D; number2; - 克隆数据：对象&#x2F;数组 1、区别： 浅拷贝&#x2F;深度拷贝 判断： 拷贝是否产生了新的数据还是拷贝的是数据的引用 知识点：对象数据存放的是对象在栈内存的引用，直接复制的是对象的引用 let obj &#x3D; &#123;username: &#39;kobe&#39;&#125; let obj1 &#x3D; obj; &#x2F;&#x2F; obj1 复制了obj在栈内存的引用 2、常用的拷贝技术 1). arr.concat(): 数组浅拷贝 2). arr.slice(): 数组浅拷贝 3). JSON.parse(JSON.stringify(arr&#x2F;obj)): 数组或对象深拷贝, 但不能处理函数数据 4). 浅拷贝包含函数数据的对象&#x2F;数组 5). 深拷贝包含函数数据的对象&#x2F;数组 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 不会影响原数据let str = 'abcd';let str2 = str;console.log(str2);str2 = '';console.log(str);let bool1 = true;let bool2 = bool1;bool2 = false;console.log(bool1);// 拷贝数组/对象，没有生成新的数据而是复制了一份引用let obj = &#123;username: 'kobe', age: 39&#125;;let obj2 = obj;console.log(obj2);obj2.username = 'wade';console.log(obj.username);let arr = [1, 4, &#123;username: 'kobe', age: 39&#125;];let arr2 = arr;arr2[0] = 'abcd';console.log(arr, arr2);/** * 拷贝数据： * 基本数据类型： * 拷贝后会生成一份新的数据，修改拷贝以后的数据不会影响原数据 * 对象/数组： * 拷贝后不会生成新的数据，而是拷贝的引用。修改拷贝以后的数据会影响原来的数据 * * 拷贝数据的方法： * 1.直接赋值给一个变量 // 浅拷贝 * 2.Object.assign() // 浅拷贝 * 3.Array.prototype.concat() // 浅拷贝 * 4.Array.prototype.slice() // 浅拷贝 * 5.JSON.parse(JSON.stringify()) // 深拷贝（深度克隆），但不能处理函数数据 * * 浅拷贝（对象/数组） * 特点：拷贝的引用，修改拷贝以后的数据会影响原数据，使得原数据不安全 * 深拷贝（深度克隆） * 特点：拷贝的时候生成新数据，修改拷贝以后的数据不会影响原数据 */&#123;let obj = &#123;username: 'kobe'&#125;;let obj2 = Object.assign(obj);console.log(obj2);obj.username = 'wade';console.log(obj2);let arr = [1, 3, &#123;username: 'kobe'&#125;, function fun()&#123;&#125;];let arr2 = arr.concat();arr2[0] = 2;// 这个修改不影响arr的第一个元素，因为是复制的基本类型arr2[2].username = 'wade';// 这个修改会影响原数据，因为复制是对象的引用console.log(arr);let arr3 = arr.slice();arr3[2].username = 'iverson';// 会影响console.log(arr);let arr4 = JSON.parse(JSON.stringify(arr));console.log(arr4);arr4[2].username = 'duncan';// 不影响console.log(arr, arr4); 实现深度克隆前的知识储备： 12345678910111213141516171819202122/** * 思考：如何实现深度拷贝（克隆） * 即使有对象/数组，也可以继续遍历对象/数组拿到里边每一项值，直到拿到的是基本数据类型，然后再去复制，就是深度拷贝 * * 如何判断数据类型：arr --&gt; Array null --&gt; Null * 1.typeof返回的数据类型：String, Number, Boolean, Undefined, Object, Function * 2.Object.prototype.toString.call(this) */let result= 'abcd';result = null;result = [1, 3];console.log(Object.prototype.toString.call(result).slice(8, -1));// for in循环，对象（属性名） 数组（下标）let obj6 = &#123;username: 'kobe', age: 39&#125;;for (let i in obj6)&#123; console.log(i);&#125;let arr6 = [1, 3, 'abc'];for (let i in arr6)&#123; console.log(i);&#125; 实现深度克隆： 123456789101112131415161718192021222324252627282930313233343536373839404142// 定义检测数据类型的功能函数function checkType(target)&#123; return Object.prototype.toString.call(target).slice(8, -1);&#125;// 实现深度克隆 --&gt; 对象/数组function clone(target)&#123; // 判断拷贝的数据类型 // 初始化变量result成为最终克隆的数据 let result, targetType = checkType(target); if(targetType === 'Object')&#123; result = &#123;&#125;; &#125;else if(targetType === 'Array')&#123; result = []; &#125;else&#123; return target; &#125; // 遍历目标数据 for(let i in target)&#123; // 获取遍历数据结构的每一项值 let value = target[i]; // 判断目标结构里的每一项值是否存在对象/数组 if(checkType(value) === 'Object' || checkType(value) === 'Array')&#123;// 对象/数组里嵌套了对象/数组 // 继续遍历获取到的value值 result[i] = clone(value); &#125;else&#123;// 获取到的value值是基本的数据类型或函数 result[i] = value; &#125; &#125; return result;&#125;let arr7 = [1, 2, &#123;username: 'kobe', age:39&#125;];let arr8 = clone(arr7);console.log(arr8);arr8[2].username = 'wade';console.log(arr7, arr8);let obj7 = &#123;username: 'kobe', age: 39&#125;;let obj8 = clone(obj7);console.log(obj8);obj8.username = 'wade';console.log(obj7, obj8); Set和Map12345678910111213141516171. Set容器 : 无序不可重复的多个value的集合体 * Set() * Set(array) * add(value) * delete(value) * has(value) * clear() * size2. Map容器 : 无序的 key不重复的多个key-value的集合体 * Map() * Map(array) * set(key, value)&#x2F;&#x2F;添加 * get(key) * delete(key) * has(key) * clear() * size 示例代码： 123456789101112131415161718let set = new Set([1,2,4,5,2,3,6]);console.log(set);set.add(7);console.log(set.size, set);console.log(set.has(8));// falseconsole.log(set.has(7));// trueset.delete(4);console.log(set);set.clear();console.log(set);let map = new Map([['username', 'kobe'], [36, 'age']]);console.log(map);map.set(78, 'haha');console.log(map);map.delete(36);console.log(map);console.log(map.size); for of循环123456for(let value of target)&#123;&#125;循环遍历 1. 遍历数组 2. 遍历Set 3. 遍历Map 4. 遍历字符串 5. 遍历伪数组 示例代码： 123456789101112131415// 数组去重let arr = [1,2,4,5,5,6,2];let arr1 = arr;arr = [];let set = new Set(arr1);for (let i of set)&#123; arr.push(i);&#125;console.log(arr);// 遍历伪数组let btns = document.getElementsByTagName('button');for(let i of btns)&#123; console.log(i);&#125; ES7121. 指数运算符(幂): **2. Array.prototype.includes(value) : 判断数组中是否包含指定value 示例代码： 123console.log(3 ** 3);// 27let arr = [1,4,5,6,'abc'];console.log(arr.includes(6));// true","tags":[{"name":"前端","slug":"前端","permalink":"https://sunshine-zwq.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"https://sunshine-zwq.github.io/tags/ECMAScript/"}]}]