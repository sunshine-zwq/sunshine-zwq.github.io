[{"title":"利用LinkedHashMap实现LRU算法","date":"2020-11-16T15:02:14.765Z","path":"2020/11/16/利用LinkedHashMap实现LRU算法/","text":"LRU LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.util.ArrayList;import java.util.Collection;import java.util.LinkedHashMap;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;import java.util.Map;/** * 类说明：利用LinkedHashMap实现简单的缓存， 必须实现removeEldestEntry方法，具体参见JDK文档 * * @author dennis * * @param &lt;K&gt; * @param &lt;V&gt; */public class LRULinkedHashMap&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123; private final int maxCapacity; private static final float DEFAULT_LOAD_FACTOR = 0.75f; private final Lock lock = new ReentrantLock(); public LRULinkedHashMap(int maxCapacity) &#123; super(maxCapacity, DEFAULT_LOAD_FACTOR, true); this.maxCapacity = maxCapacity; &#125; @Override protected boolean removeEldestEntry(java.util.Map.Entry&lt;K, V&gt; eldest) &#123; return size() &gt; maxCapacity; &#125; @Override public boolean containsKey(Object key) &#123; try &#123; lock.lock(); return super.containsKey(key); &#125; finally &#123; lock.unlock(); &#125; &#125; @Override public V get(Object key) &#123; try &#123; lock.lock(); return super.get(key); &#125; finally &#123; lock.unlock(); &#125; &#125; @Override public V put(K key, V value) &#123; try &#123; lock.lock(); return super.put(key, value); &#125; finally &#123; lock.unlock(); &#125; &#125; public int size() &#123; try &#123; lock.lock(); return super.size(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void clear() &#123; try &#123; lock.lock(); super.clear(); &#125; finally &#123; lock.unlock(); &#125; &#125; public Collection&lt;Map.Entry&lt;K, V&gt;&gt; getAll() &#123; try &#123; lock.lock(); return new ArrayList&lt;Map.Entry&lt;K, V&gt;&gt;(super.entrySet()); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 参考链接： 缓存淘汰算法–LRU算法(java代码实现)","tags":[{"name":"java","slug":"java","permalink":"https://sunshine-zwq.github.io/tags/java/"},{"name":"算法","slug":"算法","permalink":"https://sunshine-zwq.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Java8特性","date":"2020-09-30T03:52:46.970Z","path":"2020/09/30/Java8特性/","text":"Java 8 新特性简介 速度更快 代码更少（增加了新的语法 Lambda 表达式） 强大的 Stream API 便于并行 最大化减少空指针异常 Optional 1.Lambda 表达式简介： Lambda 是一个 匿名函数。Lambda 表达式在Java 语言中引入了一个新的语法元素和操作符 “-&gt;” ，该操作符被称为 Lambda 操作符或箭头操作符。它将 Lambda 分为两个部分： 左侧：指定了 Lambda 表达式需要的所有参数右侧：指定了 Lambda 体，即 Lambda 表达式要执行的功能。 从匿名类到 Lambda 的转换： 12345678910// 匿名内部类Runnable r1 = new Runnable() &#123; @Override public void run() &#123; System.out.println(\"Hello World\"); &#125;&#125;// Lambda表达式Runnable r1 = () -&gt; System.out.println(\"Hello World\"); Lambda 表达式语法： 12345678910111213141516171819202122// 语法格式1：无参，无返回值，Lambda体只需要一条语句Runnable r1 = () -&gt; System.out.println(\"Hello Lambda!\");// 语法格式2：Lambda只需要一个参数Consumer&lt;String&gt; fun = (args) -&gt; System.out.println(args);// 只有一个参数时，参数的括号可省略（参数有2个或以上时，括号不能省略）Consumer&lt;String&gt; fun = args -&gt; System.out.println(args);// 语法格式3：Lambda需要2个参数，并且有返回值BinaryOperator&lt;Long&gt; bo = (x, y) -&gt; &#123; System.out.println(\"实现函数接口方法\"); return x + y;&#125;// 语法格式4：当Lambda体有返回值且只有一条语句时，return与大括号可以省略BinaryOperator&lt;Long&gt; bo = (x, y) -&gt; x + y;// 语法格式5：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”BinaryOperator&lt;Long&gt; bo = (Long x, Long y) -&gt; &#123; System.out.println(\"实现函数接口方法\"); return x + y;&#125; 类型推断 上述 Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac根据程序的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的。 2.函数式接口简介： 只包含一个抽象方法的接口，称为 函数式接口。 可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明）。 我们可以在任意函数式接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口，同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口 自定义函数式接口： 12345678910@FunctionalInterfacepublic interface MyNumber &#123; public double getValue();&#125;// 函数式接口中使用泛型@FunctionalInterfacepublic interface MyFunc&lt;T&gt; &#123; public T getValue(T t);&#125; 作为参数传递Lambda表达式： 123456public String toUpperString(MyFunc&lt;String&gt; mf, String str)&#123; return mf.getValue(str);&#125;String newStr = toUpperString((str) -&gt; str.toUpperCase(), \"abcdef\");System.out.println(newStr); Java内置四大核心函数式接口： 函数式接口 参数类型 返回类型 用途 Consumer：消费型接口 T void 对类型为T的对象应用操作，包含方法：void accept(T t) Supplier：供给型接口 无 T 返回类型为T的对象，包含方法：T get(); Function&lt;T, R&gt;：函数型接口 T R 对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：R apply(T t); Predicate：断定型接口 T boolean 确定类型为T的对象是否满足某约束，并返回boolean 值。包含方法：boolean test(T t); 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// Consumer&lt;T&gt; 消费型接口 @Test public void test1()&#123; buy(1000, (m) -&gt; System.out.println(\"本次超市购物消费\" + m + \"元\")); &#125; public void buy(double money, Consumer&lt;Double&gt; con)&#123; con.accept(money); &#125; // Supplier&lt;T&gt; 供给型接口 @Test public void test2()&#123; List&lt;Integer&gt; numList = getNumList(10, () -&gt; (int)(Math.random() * 100)); for (Integer num : numList) &#123; System.out.println(num); &#125; &#125; // 需求：产生指定个数的整数，并放入集合中 public List&lt;Integer&gt; getNumList(int num, Supplier&lt;Integer&gt; sup)&#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; num; i++)&#123; list.add(sup.get()); &#125; return list; &#125; // Function&lt;T, R&gt; 函数型接口 @Test public void test3()&#123; String newStr = strHandler(\" 测试Function函数式接口 \", (s) -&gt; s.trim()); System.out.println(newStr); String subStr = strHandler(\"测试Function函数式接口\", (s) -&gt; s.substring(2, 5)); System.out.println(subStr); &#125; public String strHandler(String str, Function&lt;String, String&gt; fun)&#123; return fun.apply(str); &#125; // Predicate&lt;T&gt; 断言型接口 @Test public void test4()&#123; List&lt;String&gt; list = Arrays.asList(\"Hello\", \"www\", \"ok\", \"Lambda\", \"test\"); List&lt;String&gt; resultList = filterStr(list, (s) -&gt; s.contains(\"e\")); for (String s : resultList) &#123; System.out.println(s); &#125; &#125; public List&lt;String&gt; filterStr(List&lt;String&gt; list, Predicate&lt;String&gt; pre)&#123; List&lt;String&gt; strList = new ArrayList&lt;&gt;(); for (String s : list) &#123; if(pre.test(s))&#123; strList.add(s); &#125; &#125; return strList; &#125; 其他接口： 函数式接口 参数类型 返回类型 用途 BiFunction&lt;T, U, R&gt; T, U R 对类型为 T, U 参数应用操作，返回 R 类型的结果。包含方法：R apply(T t, U u); UnaryOperator(Function 子接口) T T 对类型为T的对象进行一元运算，并返回T类型的结果。包含方法：T apply(T t); BinaryOperator(BiFunction 子接口) T, T T 对类型为T的对象进行二元运算，并返回T类型的结果。包含方法：T apply(T t1, T t2); BiConsumer&lt;T, U&gt; T, U void 对类型为T, U 参数应用操作。包含方法：void accept(T t, U u) ToIntFunctionToLongFunctionToDoubleFunction T intlongdouble 分别计算int 、 long 、double值的函数 IntFunctionLongFunctionDoubleFunction intlongdouble R 参数分别为int、long、double 类型的函数 3.方法引用与构造器引用简介： 当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用 可以理解为，方法引用是lambda表达式的另外一种表现形式。 实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致 方法引用，使用操作符 :: 将方法名和对象或类的名字分隔开来。 (1).对象::实例方法 1234(x) -&gt; System.out.println(x)// 等同于System.out::println (2).类::静态方法 1234BinaryOperator&lt;Double&gt; bo = (x, y) -&gt; Math.pow(x, y);// 等同于BinaryOperator&lt;Double&gt; bo = Math::pow; (3).类::实例方法 当需要引用方法的第一个参数是调用对象，并且第二个参数是需要引用方法的第二个 参数( 或无参数 ) 时：ClassName::methodName 1234compare((x, y) -&gt; x.equals(y), \"abcdef\", \"abcdef\");// 等同于compare(String::equals, \"abcdef\", \"abcdef\"); (4).构造器引用 格式：Class::new 与函数式接口相结合，自动与函数式接口中方法兼容。可以把构造器引用赋值给定义的方法，与构造器参数列表要与接口中抽象方法的参数列表一致！ 1234Function&lt;Integer, MyClass&gt; fun = (n) -&gt; new MyClass(n);// 等同于Function&lt;Integer, MyClass&gt; fun = MyClass::new; (5).数组引用 格式：type[]::new 1234Function&lt;Integer, Integer[]&gt; fun = (n) -&gt; new Integer[n];// 等同于Function&lt;Integer, Integer[]&gt; fun = Integer[]::new; 4.Stream API简介： Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。 什么是Stream？ Stream是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。“集合讲的是数据，流讲的是计算！ 注意：①Stream 自己不会存储元素。②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。 Stream的操作三个步骤： 创建Stream 一个数据源（如：集合、数组），获取一个流 中间操作 一个中间操作链，对数据源的数据进行处理 终止操作（终端操作） 一个终止操作，执行中间操作链，并产生结果 创建Stream(1).通过Collection接口方法 Java8 中的 Collection 接口被扩展，提供了两个获取流的方法 ： default Stream stream() : 返回一个顺序流 default Stream parallelStream() : 返回一个并行流 (2).由数组创建流 Java8 中的 Arrays 的静态方法 stream() 可以获取数组流： static Stream stream(T[] array): 返回一个流 (3).由值创建流 可以使用静态方法 Stream.of(), 通过显示值创建一个流。它可以接收任意数量的参数。 public static Stream of(T… values) : 返回一个流 (4).由函数创建流：创建无限流 可以使用静态方法 Stream.iterate() 和Stream.generate()，创建无限流。 迭代 public static Stream iterate(final T seed, final UnaryOperator f) 生成 public static Stream generate(Supplier s) 示例代码： 12345678910111213141516171819202122// 1.可以通过Collection系列集合提供的stream()或parallelStream() List&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;String&gt; stream1 = list.stream(); // 2.通过Arrays中的静态方法stream()获取数据流 Employee[] emps = new Employee[10]; Stream&lt;Employee&gt; stream2 = Arrays.stream(emps); // 3.通过Stream类中的静态方法of Stream&lt;String&gt; stream3 = Stream.of(\"aa\", \"bb\", \"cc\"); // 4.创建无限流 // 迭代 Stream&lt;Integer&gt; stream4 = Stream.iterate(0, (x) -&gt; x + 2); stream4.limit(10).forEach(System.out::println); System.out.println(\"===========================================\"); // 生成 Stream.generate(() -&gt; Math.random()) .limit(5) .forEach(System.out::println); 中间操作多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。 筛选与切片 方法 描述 filter(Predicate p) 接收 Lambda ， 从流中排除某些元素 distinct() 筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素 limit(long maxSize) 截断流，使其元素不超过给定数量 skip(long n) 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546List&lt;Employee&gt; emps = Arrays.asList( new Employee(101, \"张三\", 18, 9999.99), new Employee(102, \"李四\", 59, 6666.66), new Employee(103, \"王五\", 28, 3333.33), new Employee(104, \"赵六\", 8, 7777.77), new Employee(105, \"田七\", 38, 5555.55), new Employee(105, \"田七\", 38, 5555.55), new Employee(105, \"田七\", 38, 5555.55) ); // filter @Test public void test1()&#123; Stream&lt;Employee&gt; stream = emps.stream() .filter((e) -&gt; e.getAge() &gt; 35); stream.forEach(System.out::println); &#125; // limit @Test public void test2()&#123; emps.stream() .filter((e) -&gt; e.getSalary() &gt; 5000) .limit(2) .forEach(System.out::println); &#125; // skip @Test public void test3()&#123; emps.stream() .filter((e) -&gt; e.getSalary() &gt; 5000) .skip(2) .forEach(System.out::println); &#125; // distinct @Test public void test4()&#123; emps.stream() .filter((e) -&gt; e.getSalary() &gt; 5000) .skip(2) .distinct() .forEach(System.out::println); &#125; 映射 方法 描述 map(Function f) 接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。 mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。 mapToInt(ToIntFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream。 mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。 flatMap(Function f) 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 示例代码： 12345678910111213141516171819202122232425262728293031323334 // map @Test public void test5()&#123; List&lt;String&gt; list = Arrays.asList(\"aaa\", \"bbb\", \"ccc\", \"ddd\"); list.stream() .map((str) -&gt; str.toUpperCase()) .forEach(System.out::println); System.out.println(\"===========================================\"); emps.stream() .map((e) -&gt; e.getName()) .forEach(System.out::println); System.out.println(\"===========================================\");// Stream&lt;Stream&lt;Character&gt;&gt; stream = list.stream()// .map((s) -&gt; filterCharacter(s));// stream.forEach((sm) -&gt; &#123;// sm.forEach(System.out::println);// &#125;); list.stream() .flatMap((s) -&gt; filterCharacter(s)) .forEach(System.out::println); &#125; public static Stream&lt;Character&gt; filterCharacter(String str)&#123; List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for (char ch : str.toCharArray()) &#123; list.add(ch); &#125; return list.stream(); &#125; 排序 方法 描述 sorted() 产生一个新流，其中按自然顺序排序 sorted(Comparator comp) 产生一个新流，其中按比较器顺序排序 示例代码： 123456789101112131415161718@Test public void test6()&#123; List&lt;String&gt; list = Arrays.asList(\"ccc\", \"aaa\", \"ddd\", \"eee\", \"bbb\"); list.stream() .sorted() .forEach(System.out::println); System.out.println(\"===========================================\"); emps.stream() .sorted((e1, e2) -&gt; &#123; if(e1.getAge() == e2.getAge())&#123; return e1.getName().compareTo(e2.getName()); &#125;else&#123; return e1.getAge() - e2.getAge(); &#125; &#125;).forEach(System.out::println); &#125; 终止操作终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void。 查找与匹配 方法 描述 allMatch(Predicate p) 检查是否匹配所有元素 anyMatch(Predicate p) 检查是否至少匹配一个元素 noneMatch(Predicate p) 检查是否没有匹配所有元素 findFirst() 返回第一个元素 findAny() 返回当前流中的任意元素 count() 返回流中元素总数 max(Comparator c) 返回流中最大值 min(Comparator c) 返回流中最小值 forEach(Consumer c) 内部迭代(使用 Collection 接口需要用户去做迭代，称为外部迭代 。相反， Stream API 使用内部迭代 —— 它帮你把迭代做了) 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647List&lt;Employee&gt; emps = Arrays.asList( new Employee(101, \"张三\", 18, 9999.99), new Employee(102, \"李四\", 59, 6666.66), new Employee(103, \"王五\", 28, 3333.33), new Employee(104, \"赵六\", 8, 7777.77), new Employee(105, \"田七\", 38, 5555.55) ); @Test public void test1()&#123; boolean b1 = emps.stream() .allMatch((e) -&gt; e.getSalary() &gt; 5000); System.out.println(b1); boolean b2 = emps.stream() .anyMatch((e) -&gt; e.getSalary() &gt; 5000); System.out.println(b2); boolean b3 = emps.stream() .noneMatch((e) -&gt; e.getSalary() &gt; 5000); System.out.println(b3); Optional&lt;Employee&gt; op = emps.stream() .sorted((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())) .findFirst(); System.out.println(op.get()); Optional&lt;Employee&gt; op2 = emps.parallelStream() .filter((e) -&gt; e.getSalary() &gt; 5000) .findAny(); System.out.println(op2.get()); &#125; @Test public void test2()&#123; long count = emps.stream().count(); System.out.println(count); Optional&lt;Employee&gt; op1 = emps.stream() .max((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())); System.out.println(op1.get()); Optional&lt;Double&gt; op2 = emps.stream() .map(Employee::getSalary) .min(Double::compare); System.out.println(op2.get()); &#125; 规约 方法 描述 reduce(T iden, BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 T reduce(BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 Optional 示例代码： 12345678910111213@Test public void test3()&#123; List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,9,10); Integer sum = list.stream() .reduce(0, (x, y) -&gt; x + y); System.out.println(sum); Optional&lt;Double&gt; op = emps.stream() .map(Employee::getSalary) .reduce(Double::sum); System.out.println(op.get()); &#125; 收集 方法 描述 collect(Collector c) 将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法 Collector 接口中方法的实现决定了如何对流执行收集操作(如收集到 List、Set、Map)。但是 Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表： 方法 返回类型 作用 示例 toList List 把流中元素收集到List List emps = list.stream().collect(Collectors.toList()); toSet Set 把流中元素收集到Set Set emps= list.stream().collect(Collectors.toSet()); toCollection Collection 把流中元素收集到创建的集合 Collectionemps=list.stream().collect(Collectors.toCollection(ArrayList::new)); counting Long 计算流中元素的个数 long count = list.stream().collect(Collectors.counting()); summingInt Integer 对流中元素的整数属性求和 inttotal=list.stream().collect(Collectors.summingInt(Employee::getSalary)); averagingInt Double 计算流中元素Integer属性的平均值 doubleavg= list.stream().collect(Collectors.averagingInt(Employee::getSalary)); summarizingInt IntSummaryStatistics 收集流中Integer属性的统计值。如：平均值 IntSummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary)); joining String 连接流中每个字符串 String str= list.stream().map(Employee::getName).collect(Collectors.joining()); maxBy Optional 根据比较器选择最大值 Optionalmax= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary))); minBy Optional 根据比较器选择最小值 Optional min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary))); reducing 归约产生的类型 从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值 inttotal=list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum)); collectingAndThen 转换函数返回的类型 包裹另一个收集器，对其结果转换函数 inthow= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size)); groupingBy Map&lt;K, List&gt; 根据某属性值对流分组，属性为K，结果为V Map&lt;Emp.Status, List&gt; map= list.stream().collect(Collectors.groupingBy(Employee::getStatus)); partitioningBy Map&lt;Boolean, List&gt; 根据true或false进行分区 Map&lt;Boolean,List&gt;vd= list.stream().collect(Collectors.partitioningBy(Employee::getManage)); 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485@Test public void test4()&#123; List&lt;String&gt; list = emps.stream() .map(Employee::getName) .collect(Collectors.toList()); list.forEach(System.out::println); Set&lt;String&gt; set = emps.stream() .map(Employee::getName) .collect(Collectors.toSet()); set.forEach(System.out::println); HashSet&lt;String&gt; hs = emps.stream() .map(Employee::getName) .collect(Collectors.toCollection(HashSet::new)); hs.forEach(System.out::println); &#125; @Test public void test5()&#123; // 总数 Long count = emps.stream() .collect(Collectors.counting()); System.out.println(count); // 平均值 Double avg = emps.stream() .collect(Collectors.averagingDouble(Employee::getSalary)); System.out.println(avg); // 总和 Double sum = emps.stream() .collect(Collectors.summingDouble(Employee::getSalary)); System.out.println(sum); // 最大值 Optional&lt;Employee&gt; max = emps.stream() .collect(Collectors.maxBy((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()))); System.out.println(max.get()); // 最小值 Optional&lt;Double&gt; min = emps.stream() .map(Employee::getSalary) .collect(Collectors.minBy(Double::compare)); System.out.println(min.get()); &#125; @Test public void test6()&#123; // 分组 Map&lt;String, List&lt;Employee&gt;&gt; map = emps.stream() .collect(Collectors.groupingBy((e) -&gt; &#123; if (((Employee) e).getSalary() &gt; 7000) &#123; return \"高薪\"; &#125; else &#123; return \"低薪\"; &#125; &#125;)); System.out.println(map); &#125; @Test public void test7()&#123; // 分区 Map&lt;Boolean, List&lt;Employee&gt;&gt; map = emps.stream() .collect(Collectors.partitioningBy((e) -&gt; e.getSalary() &gt; 7000)); System.out.println(map); &#125; @Test public void test8()&#123; DoubleSummaryStatistics dss = emps.stream() .collect(Collectors.summarizingDouble(Employee::getSalary)); System.out.println(dss.getSum()); System.out.println(dss.getAverage()); System.out.println(dss.getMax()); &#125; @Test public void test9()&#123; String str = emps.stream() .map(Employee::getName) .collect(Collectors.joining(\",\")); System.out.println(str); &#125; 并行流与串行流 并行流 就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。 Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与sequential() 在并行流与顺序流之间进行切换。 5.Optional类简介： Optional 类(java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。 常用方法： Optional.of(T t)：创建一个 Optional 实例 Optional.empty()：创建一个空的 Optional 实例 Optional.ofNullable(T t)：若 t 不为 null,创建 Optional 实例,否则创建空实例 isPresent()：判断是否包含值 orElse(T t)：如果调用对象包含值，返回该值，否则返回t orElseGet(Supplier s) ：如果调用对象包含值，返回该值，否则返回 s 获取的值 map(Function f)：如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty() flatMap(Function mapper)：与 map 类似，要求返回值必须是Optional 示例代码： 12345678910111213141516171819202122232425262728293031323334353637@Test public void test1()&#123; Optional&lt;Employee&gt; op = Optional.of(new Employee()); Employee emp = op.get(); System.out.println(emp); &#125; @Test public void test2()&#123; Optional&lt;Employee&gt; op = Optional.empty(); System.out.println(op); &#125; @Test public void test3()&#123; Optional&lt;Employee&gt; op = Optional.ofNullable(null); if(op.isPresent())&#123; System.out.println(op.get()); &#125; Employee emp1 = op.orElse(new Employee(\"张三\", 28)); System.out.println(emp1); Employee emp2 = op.orElseGet(Employee::new); System.out.println(emp2); &#125; @Test public void test4()&#123; Optional&lt;Employee&gt; op = Optional.ofNullable(new Employee(\"张三\", 28)); Optional&lt;String&gt; str = op.map((e) -&gt; e.getName()); System.out.println(str.get()); Optional&lt;String&gt; str2 = op.flatMap((e) -&gt; Optional.of(e.getName())); System.out.println(str2.get()); &#125; 尽量避免使用的地方： 1、避免使用Optional.isPresent()来检查实例是否存在，因为这种方式和null != obj没有区别，这样用就没什么意义了。 2、避免使用Optional.get()方式来获取实例对象，因为使用前需要使用Optional.isPresent()来检查实例是否存在，否则会出现NPE问题。 3、避免使用Optional作为类或者实例的属性，而应该在返回值中用来包装返回实例对象。 4、避免使用Optional作为方法的参数，原因同3。 使用Optional优化的经典案例： 1234567891011121314151617181920212223// java8之前的多重if判断private String getIsoCode(User user)&#123; if (user != null) &#123; Address address = user.getAddress(); if (address != null) &#123; Country country = address.getCountry(); if (country != null) &#123; String isocode = country.getIsocode(); if (isocode != null) &#123; return isocode; &#125; &#125; &#125; &#125; return \"\";&#125;// 用java8的Optional优化后String isoCode = Optional.ofNullable(user) .map(User::getAddress) //Optional&lt;Address&gt; .map(Address::getCountry) //Optional&lt;Country&gt; .map(Country::getIsocode) // Optional&lt;String&gt; .orElse(\"\"); 6.接口中的默认方法与静态方法接口中的默认方法 Java 8中允许接口中包含具有具体实现的方法，该方法称为“默认方法”，默认方法使用 default 关键字修饰。 示例代码： 1234567public interface MyFunc &#123; default String getName()&#123; return \"Hello Java8\"; &#125;&#125; 接口默认方法的 ” 类优先 ”原则 若一个接口中定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时： 选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。 接口冲突。如果一个父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否是默认方法），那么必须覆盖该方法来解决冲突 示例代码： 1234567891011121314151617interface MyFunc&#123; default String getName()&#123; return \"Hello Java8\"; &#125;&#125;interface Named&#123; default String getName()&#123; return \"Hello World\"; &#125;&#125;class MyClass implements MyFunc, Named&#123; public String getName()&#123; return Named.super.getName(); &#125;&#125; 接口中的静态方法 Java8 中，接口中允许添加静态方法。 示例代码： 123456789101112interface Named&#123; public Integer myFun(); default String getName()&#123; return \"Hello World\"; &#125; static void show()&#123; System.out.println(\"Hi\"); &#125;&#125; 7.新时间日期 API在旧版的 Java 中，日期时间 API 存在诸多问题，其中有： 非线程安全 − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。 设计很差 − Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。 时区处理麻烦 − 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。 使用 LocalDate 、LocalTime 、LocalDateTime LocalDate、LocalTime、LocalDateTime 类的实例是不可变的对象，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息。也不包含与时区相关的信息。 方法 描述 示例 now() 静态方法，根据当前时间创建对象 LocalDate localDate = LocalDate.now();LocalTime localTime = LocalTime.now();LocalDateTime localDateTime = LocalDateTime.now(); of() 静态方法，根据指定日期/时间创建对象 LocalDate localDate = LocalDate.of(2016, 10, 26);LocalTime localTime = LocalTime.of(02, 22, 56);LocalDateTime localDateTime = LocalDateTime.of(2016, 10,26, 12, 10, 55); plusDays, plusWeeks,plusMonths, plusYears 向当前 LocalDate 对象添加几天、几周、几个月、几年 minusDays, minusWeeks,minusMonths, minusYears 从当前 LocalDate 对象减去几天、几周、几个月、几年 plus, minus 添加或减少一个 Duration 或 Period withDayOfMonth,withDayOfYear,withMonth,withYear 将月份天数、年份天数、月份、年份修改为指定的值并返回新的LocalDate 对象 getDayOfMonth 获得月份天数(1-31) getDayOfYear 获得年份天数(1-366) getDayOfWeek 获得星期几(返回一个 DayOfWeek枚举值) getMonth 获得月份, 返回一个 Month 枚举值 getMonthValue 获得月份(1-12) getYear 获得年份 until 获得两个日期之间的 Period 对象，或者指定 ChronoUnits 的数字 isBefore, isAfter 比较两个 LocalDate isLeapYear 判断是否是闰年 Instant 时间戳 用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算 Duration 和 Period Duration: 用于计算两个“时间”间隔 Period: 用于计算两个“日期”间隔 日期的操纵 emporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下个周日”等操作。 TemporalAdjusters : 该类通过静态方法提供了大量的常用 TemporalAdjuster 的实现。 解析与格式化 java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法： 预定义的标准格式 语言环境相关的格式 自定义的格式 时区的处理 Java8 中加入了对时区的支持，带时区的时间为分别为：ZonedDate、ZonedTime、ZonedDateTime 其中每个时区都对应着 ID，地区ID都为 “{区域}/{城市}”的格式，例如 ：Asia/Shanghai 等 ZoneId：该类中包含了所有的时区信息 getAvailableZoneIds() : 可以获取所有时区时区信息 of(id) : 用指定的时区信息获取 ZoneId 对象 与传统日期处理的转换 类 To遗留类 From遗留类 java.time.Instantjava.util.Date Date.from(instant) date.toInstant() java.time.Instantjava.sql.Timestamp Timestamp.from(instant) timestamp.toInstant() java.time.ZonedDateTimejava.util.GregorianCalendar GregorianCalendar.from(zonedDateTime) cal.toZonedDateTime() java.time.LocalDatejava.sql.Time Date.valueOf(localDate) date.toLocalDate() java.time.LocalTimejava.sql.Time Date.valueOf(localDate) date.toLocalTime() java.time.LocalDateTimejava.sql.Timestamp Timestamp.valueOf(localDateTime) timestamp.toLocalDateTime() java.time.ZoneIdjava.util.TimeZone Timezone.getTimeZone(id) timeZone.toZoneId() java.time.format.DateTimeFormatterjava.text.DateFormat formatter.toFormat() 无 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126@Test public void test1()&#123; LocalDateTime ldt = LocalDateTime.now(); System.out.println(ldt); System.out.println(ldt.getYear()); System.out.println(ldt.getMonthValue()); System.out.println(ldt.getDayOfMonth()); System.out.println(ldt.getHour()); System.out.println(ldt.getMinute()); System.out.println(ldt.getSecond()); LocalDateTime ldt2 = ldt.plusYears(2); System.out.println(ldt2); LocalDateTime ldt3 = ldt.plusMonths(2); System.out.println(ldt3); &#125; @Test public void test2()&#123; Instant ins = Instant.now(); System.out.println(ins);// 默认获取UTC时区 OffsetDateTime odt = ins.atOffset(ZoneOffset.ofHours(8)); System.out.println(odt); System.out.println(odt.toEpochSecond()); Instant ins2 = Instant.ofEpochSecond(1000); System.out.println(ins2); &#125; @Test public void test3()&#123; Instant ins1 = Instant.now(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Instant ins2 = Instant.now(); Duration duration = Duration.between(ins1, ins2); System.out.println(duration.toMillis()); System.out.println(\"======================================\"); LocalTime lt1 = LocalTime.now(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; LocalTime lt2 = LocalTime.now(); System.out.println(Duration.between(lt1, lt2).toMillis()); &#125; @Test public void test4()&#123; LocalDate ld1 = LocalDate.of(2015, 6, 1); LocalDate ld2 = LocalDate.now(); Period period = Period.between(ld1, ld2); System.out.println(period); System.out.println(period.getYears()); System.out.println(period.getMonths()); System.out.println(period.getDays()); &#125; // TemporalAdjuster: 时间校正器 @Test public void test5()&#123; LocalDateTime ldt = LocalDateTime.now(); System.out.println(ldt); LocalDateTime ldt2 = ldt.withDayOfMonth(10); System.out.println(ldt2); LocalDateTime ldt3 = ldt.with(TemporalAdjusters.next(DayOfWeek.SUNDAY)); System.out.println(ldt3); // 自定义：下一个工作日 LocalDateTime ldt5 = ldt.with((l) -&gt; &#123; LocalDateTime ldt4 = (LocalDateTime) l; DayOfWeek dow = ldt4.getDayOfWeek(); if (dow.equals(DayOfWeek.FRIDAY)) &#123; return ldt4.plusDays(3); &#125; else if (dow.equals(DayOfWeek.SATURDAY)) &#123; return ldt4.plusDays(2); &#125; else &#123; return ldt4.plusDays(1); &#125; &#125;); System.out.println(ldt5); &#125; // DateTimeFormatter @Test public void test6()&#123; DateTimeFormatter dtf = DateTimeFormatter.ISO_DATE; LocalDateTime ldt = LocalDateTime.now(); String strDate = ldt.format(dtf); System.out.println(strDate); DateTimeFormatter dtf2 = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日 HH:mm:ss\"); String strDate2 = ldt.format(dtf2); System.out.println(strDate2); LocalDateTime newDate = ldt.parse(strDate2, dtf2); System.out.println(newDate); &#125; // ZonedDate、ZonedTime、ZonedDateTime @Test public void test7()&#123; LocalDateTime ldt = LocalDateTime.now(ZoneId.of(\"Asia/Shanghai\")); System.out.println(ldt); ZonedDateTime zdt = ldt.atZone(ZoneId.of(\"Asia/Shanghai\")); System.out.println(zdt); &#125; 8.其他新特性重复注解与类型注解 Java 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。","tags":[{"name":"java","slug":"java","permalink":"https://sunshine-zwq.github.io/tags/java/"},{"name":"java8","slug":"java8","permalink":"https://sunshine-zwq.github.io/tags/java8/"},{"name":"Lambda","slug":"Lambda","permalink":"https://sunshine-zwq.github.io/tags/Lambda/"},{"name":"Stream","slug":"Stream","permalink":"https://sunshine-zwq.github.io/tags/Stream/"}]},{"title":"JS模块化","date":"2020-09-13T06:45:51.107Z","path":"2020/09/13/JS模块化/","text":"简介 什么是模块? 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起 块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信 一个模块的组成 数据—&gt;内部的属性 操作数据的行为—&gt;内部的函数 模块化 编码时是按照模块一个一个编码的, 整个项目就是一个模块化的项目 模块化的好处 避免命名冲突（减少命名空间污染） 更好的分离，按需加载 更高复用性 高可维护性 CommonJS 说明 每个文件都可当作一个模块 在服务器端：模块的加载是运行时同步加载的 在浏览器端：模块需要提前编译打包处理 基本语法 暴露模块 module.exports = value exports.xxx = value 引入模块 require(xxx) 第三方模块：xxx为模块名 自定义模块：xxx为模块文件路径 基于服务端应用（Node.js） 项目结构 12345678910|-modules |-module1.js |-module2.js |-module3.js|-app.js|-package.json &#123; &quot;name&quot;: &quot;commonJS-node&quot;, &quot;version&quot;: &quot;1.0.0&quot; &#125; 下载第三方模块 npm install uniq –save 模块化编码 module1.js12345module.exports = &#123; foo() &#123; console.log('moudle1 foo()') &#125;&#125; module2.js123module.exports = function () &#123; console.log('module2()')&#125; module3.js1234567exports.foo = function () &#123; console.log('module3 foo()')&#125;exports.bar = function () &#123; console.log('module3 bar()')&#125; app.js 12345678910111213141516171819202122/** 1. 定义暴露模块: module.exports = value; exports.xxx = value; 2. 引入模块: var module = require(模块名或模块路径); */\"use strict\";//引用模块let module1 = require('./modules/module1')let module2 = require('./modules/module2')let module3 = require('./modules/module3')let uniq = require('uniq')//使用模块module1.foo()module2()module3.foo()module3.bar()console.log(uniq([1, 3, 1, 4, 3])) 通过node运行app.js 命令: node app.js 工具: 右键–&gt;运行 基于浏览器端应用（Browserify ） 项目结构12345678910111213|-js |-dist &#x2F;&#x2F;打包生成文件的目录 |-src &#x2F;&#x2F;源码所在的目录 |-module1.js |-module2.js |-module3.js |-app.js &#x2F;&#x2F;应用主源文件|-index.html|-package.json &#123; &quot;name&quot;: &quot;browserify-test&quot;, &quot;version&quot;: &quot;1.0.0&quot; &#125; 下载browserify 全局: npm install browserify -g 局部: npm install browserify –save-dev 定义模块代码 module1.js12345module.exports = &#123; foo() &#123; console.log('moudle1 foo()') &#125;&#125; module2.js123module.exports = function () &#123; console.log('module2()')&#125; module3.js1234567exports.foo = function () &#123; console.log('module3 foo()')&#125;exports.bar = function () &#123; console.log('module3 bar()')&#125; app.js (应用的主js)1234567891011121314//引用模块let module1 = require('./module1')let module2 = require('./module2')let module3 = require('./module3')let uniq = require('uniq')//使用模块module1.foo()module2()module3.foo()module3.bar()console.log(uniq([1, 3, 1, 4, 3])) 打包处理js: browserify js/src/app.js -o js/dist/bundle.js 页面使用引入: 1&lt;script type=\"text/javascript\" src=\"js/dist/bundle.js\"&gt;&lt;/script&gt; AMD（浏览器端） require.js 基本语法 定义暴露模块 定义没有依赖的模块：define(function(){return 模块}) 定义有依赖的模块：define([‘module1’, ‘module2’], function(m1, m2){return 模块}) 引入模块: require([‘module1’, ‘module2’], function(m1, m2){//使用模块对象}) 配置: 123456789101112131415161718192021require.config(&#123; //基本路径 baseUrl : 'js/', //标识名称与路径的映射 paths : &#123; '模块1' : 'modules/模块1', '模块2' : 'modules/模块2', 'angular' : 'libs/angular', 'angular-messages' : 'libs/angular-messages' &#125;, //非AMD的模块 shim : &#123; 'angular' : &#123; exports : 'angular' &#125;, 'angular-messages' : &#123; exports : 'angular-messages', deps : ['angular'] &#125; &#125;&#125;) 代码实现： 下载require.js, 并引入 官网: http://www.requirejs.cn/ github : https://github.com/requirejs/requirejs 将require.js导入项目: js/libs/require.js 项目结构 12345678|-js |-libs |-require.js |-modules |-alerter.js |-dataService.js |-main.js|-index.html 定义require.js的模块代码 dataService.js 123456789define(function () &#123; let msg = 'Hello world' function getMsg() &#123; return msg.toUpperCase() &#125; return &#123;getMsg&#125;&#125;) alerter.js 12345678910define(['dataService', 'jquery'], function (dataService, $) &#123; let name = 'Tom2' function showMsg() &#123; $('body').css('background', 'gray') alert(dataService.getMsg() + ', ' + name) &#125; return &#123;showMsg&#125;&#125;) 应用主(入口)js: main.js 1234567891011121314151617(function () &#123; //配置 requirejs.config(&#123; //基本路径 baseUrl: \"js/\", //模块标识名与模块路径映射 paths: &#123; \"alerter\": \"modules/alerter\", \"dataService\": \"modules/dataService\", &#125; &#125;) //引入使用模块 requirejs( ['alerter'], function(alerter) &#123; alerter.showMsg() &#125;)&#125;)() 页面使用模块: 1&lt;script data-main=\"js/main\" src=\"js/libs/require.js\"&gt;&lt;/script&gt; 使用第三方基于require.js的框架(jquery) 将jquery的库文件导入到项目: js/libs/jquery-1.10.1.js 在main.js中配置jquery路径 123paths: &#123; &#39;jquery&#39;: &#39;libs&#x2F;jquery-1.10.1&#39; &#125; 在alerter.js中使用jquery 12345678define([&#39;dataService&#39;, &#39;jquery&#39;], function (dataService, $) &#123; var name &#x3D; &#39;xfzhang&#39; function showMsg() &#123; $(&#39;body&#39;).css(&#123;background : &#39;red&#39;&#125;) alert(name + &#39; &#39;+dataService.getMsg()) &#125; return &#123;showMsg&#125;&#125;) 使用第三方不基于require.js的框架(angular) 将angular.js导入项目 js/libs/angular.js 在main.js中配置 1234567891011121314151617181920212223242526272829(function () &#123; require.config(&#123; //基本路径 baseUrl: \"js/\", //模块标识名与模块路径映射 paths: &#123; //第三方库 'jquery' : './libs/jquery-1.10.1', 'angular' : './libs/angular', //自定义模块 \"alerter\": \"./modules/alerter\", \"dataService\": \"./modules/dataService\" &#125;, /* 配置不兼容AMD的模块 exports : 指定与相对应的模块名对应的模块对象 */ shim: &#123; 'angular' : &#123; exports : 'angular' &#125; &#125; &#125;) //引入使用模块 require( ['alerter', 'angular'], function(alerter, angular) &#123; alerter.showMsg() console.log(angular); &#125;)&#125;)() CMD（浏览器端） sea.js 基本语法 定义暴露模块: 定义没有依赖的模块 1234define(function(require, exports, module)&#123; exports.xxx = value module.exports = value&#125;) 定义有依赖的模块 12345678910define(function(require, exports, module)&#123; //引入依赖模块(同步) var module2 = require('./module2') //引入依赖模块(异步) require.async('./module3', function (m3) &#123; &#125;) //暴露模块 exports.xxx = value&#125;) 引入使用模块 123456define(function (require) &#123; var m1 = require('./module1') var m4 = require('./module4') m1.show() m4.show()&#125;) 使用模块seajs.use([‘模块1’, ‘模块2’]) 代码实现： 下载sea.js, 并引入 官网: http://seajs.org/ github : https://github.com/seajs/seajs 将sea.js导入项目: js/libs/sea.js 创建项目结构 12345678910|-js |-libs |-sea.js |-modules |-module1.js |-module2.js |-module3.js |-module4.js |-main.js|-index.html 定义sea.js的模块代码 module1.js 1234567891011define(function (require, exports, module) &#123; //内部变量数据 var data = 'Hello world' //内部函数 function show() &#123; console.log('module1 show() ' + data) &#125; //向外暴露 exports.show = show&#125;) module2.js 12345define(function (require, exports, module) &#123; module.exports = &#123; msg: 'I Will Back' &#125;&#125;) module3.js 1234define(function (require, exports, module) &#123; const API_KEY = 'abc123' exports.API_KEY = API_KEY&#125;) module4.js 1234567891011121314define(function (require, exports, module) &#123; //引入依赖模块(同步) var module2 = require('./module2') function show() &#123; console.log('module4 show() ' + module2.msg) &#125; exports.show = show //引入依赖模块(异步) require.async('./module3', function (m3) &#123; console.log('异步引入依赖模块3 ' + m3.API_KEY) &#125;)&#125;) main.js : 主(入口)模块 123456define(function (require) &#123; var m1 = require('./module1') var m4 = require('./module4') m1.show() m4.show()&#125;) index.html: 12345678910111213141516&lt;!--使用seajs: 1. 引入sea.js库 2. 如何定义导出模块 : define() exports module.exports 3. 如何依赖模块: require() 4. 如何使用模块: seajs.use()--&gt;&lt;script type=\"text/javascript\" src=\"js/libs/sea.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; seajs.use('./js/modules/main')&lt;/script&gt; ​ ES6 ES6内置了模块化的实现 基本语法 定义暴露模块 : export 暴露一个对象: 1export default 对象 暴露多个: 123456export var xxx &#x3D; value1export let yyy &#x3D; value2var xxx &#x3D; value1let yyy &#x3D; value2export &#123;xxx, yyy&#125; 引入使用模块 : import default模块: 1import xxx from &#39;模块路径&#x2F;模块名&#39; 其它模块 12import &#123;xxx, yyy&#125; from &#39;模块路径&#x2F;模块名&#39;import * as module1 from &#39;模块路径&#x2F;模块名&#39; 问题: 所有浏览器还不能直接识别ES6模块化的语法 解决: 使用Babel将ES6—&gt;ES5(使用了CommonJS) —-浏览器还不能直接支行 使用Browserify—&gt;打包处理—-浏览器可以运行 代码实现： 定义package.json文件 1234&#123; \"name\" : \"es6-babel-browserify\", \"version\" : \"1.0.0\"&#125; 安装babel-cli, babel-preset-es2015和browserify npm install babel-cli browserify -g npm install babel-preset-es2015 –save-dev preset 预设(将es6转换成es5的所有插件打包) 定义.babelrc文件 123&#123; \"presets\": [\"es2015\"]&#125; 编码 js/src/module1.js 分别暴露 1234567export function foo() &#123; console.log('module1 foo()');&#125;export function bar() &#123; console.log('module1 bar()');&#125;export const DATA_ARR = [1, 3, 5, 1] js/src/module2.js 统一暴露 1234567891011let data = 'module2 data'function fun1() &#123; console.log('module2 fun1() ' + data);&#125;function fun2() &#123; console.log('module2 fun2() ' + data);&#125;export &#123;fun1, fun2&#125; js/src/module3.js 123456export default &#123; name: 'Tom', setName: function (name) &#123; this.name = name &#125;&#125; js/src/app.js 1234567891011121314151617import &#123;foo, bar&#125; from './module1'import &#123;DATA_ARR&#125; from './module1'import &#123;fun1, fun2&#125; from './module2'import person from './module3'import $ from 'jquery'$('body').css('background', 'red')foo()bar()console.log(DATA_ARR);fun1()fun2()person.setName('JACK')console.log(person.name); 编译 使用Babel将ES6编译为ES5代码(但包含CommonJS语法) : babel js/src -d js/lib 使用Browserify编译js : browserify js/lib/app.js -o js/lib/bundle.js 页面中引入测试 1&lt;script type=\"text/javascript\" src=\"js/lib/bundle.js\"&gt;&lt;/script&gt; 引入第三方模块(jQuery) 下载jQuery模块: npm install jquery@1 –save 在app.js中引入并使用 12import $ from 'jquery'$('body').css('background', 'red')","tags":[{"name":"js","slug":"js","permalink":"https://sunshine-zwq.github.io/tags/js/"},{"name":"js模块化","slug":"js模块化","permalink":"https://sunshine-zwq.github.io/tags/js%E6%A8%A1%E5%9D%97%E5%8C%96/"}]},{"title":"Node.js入门","date":"2020-09-06T05:06:19.720Z","path":"2020/09/06/Node.js入门/","text":"Node.js简介简介： (1).开发者：瑞安·达尔（Ryan Dahl） (2).Node.js是一个能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript运行环境。 (3).Node采用Google开发的V8引擎运行js代码，使用事件驱动、非阻塞和异步I/O模型等技术来提高性能，可优化应用程序的传输量和规模。 (4).Node大部分基本模块都用JavaScript编写。在Node出现之前，JS通常作为客户端程序设计语言使用，以JS写出的程序常在用户的浏览器上运行。 特点： (1).Node.js允许通过JS和一系列模块来编写服务器端应用和网络相关的应用。 (2).核心模块包括文件系统I/O、网络（HTTP、TCP、UDP、DNS、TLS/SSL等）、二进制数据流、加密算法、数据流等等。Node模块的API形式简单，降低了编程的复杂度。 (3).使用框架可以加速开发。常用的框架有Express.js、Socket.IO和Connect等。Node.js的程序可以在Microsoft Windows、Linux、Unix、Mac OS X等服务器上运行。 (4).Node.js也可以使用CoffeeScript、TypeScript、Dart语言，以及其他能够编译成JavaScript的语言编程。 用途： • Web服务API，比如REST• 实时多人游戏• 后端的Web服务，例如跨域、服务器端的请求• 基于Web的应用• 多客户端的通信，如即时通信 Node的基本使用使用node执行js： 1node hello.js CommonJS规范ECMAScript标准的缺陷：• 没有模块系统• 标准库较少• 没有标准接口• 缺乏管理系统 CommonJS简介：• CommonJS规范的提出，主要是为了弥补当前JavaScript没有模块化标准的缺陷。• CommonJS规范为JS指定了一个美好的愿景，希望JS能够在任何地方运行。 模块引用• 在规范中，定义了require()方法，这个方法接收模块标识，以此将一个模块引入到当前运行环境中。使用require()引入模块以后，该函数会返回一个对象，这个对象代表的就是引入的模块。 模块引用的示例代码： 1var math = require('math'); 注意： 1.require()可以传递一个文件的路径作为参数，node会自动根据该路径来引入外部模块 2.这里的路径，如果使用相对路径，必须以 ./ 或者 ../ 开头 3.路径的后缀.js可以省略 模块定义• 在运行环境中，提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一的导出的出口。• 在模块中还存在一个module对象，它代表模块自身，而exports是module的属性。• 在Node中一个文件就是一个模块。• 在Node中，每一个js文件中的js代码都是独立运行在一个函数中，而不是全局作用域，所以一个模块中的变量和函数在其他模块中无法访问。 使用exports向外暴露属性或方法示例： 123exports.x = 10;exports.xxx = function() &#123;&#125;;module.exports = &#123;&#125;; 模块标识• 模块标识其实就是模块的名字，也就是传递给require()方法的参数，它必须是符合驼峰命名法的字符串，或者是以 ./ 或 ../ 开头的相对路径、或者绝对路径。 模块分为两大类：核心模块、文件模块。 (1).核心模块 • 由node引擎提供的模块 • 核心模块的标识，就是模块的名字 (2).文件模块 • 由用户自己创建的模块 • 文件模块的标识，就是文件的路径（绝对路径，或相对路径） 在node中有一个全局变量global，它的作用和网页中window类似 • 在全局中创建的变量都会作为global的属性保存 • 在全局中创建的函数都会作为global的方法保存 当node在执行模块中的代码时，它会在代码首尾包裹一层函数，代码示例： 原始代码： 1234567891011121314var a = 10;/** 在node中有一个全局变量global，它的作用和网页中window类似 • 在全局中创建的变量都会作为global的属性保存 • 在全局中创建的函数都会作为global的方法保存 */// console.log(global.a);/** arguments.callee - 这个属性保存的是当前执行的函数对象 */console.log(arguments.callee + \"\"); 实际执行的代码： 12345678910111213141516function (exports, require, module, __filename, __dirname) &#123; var a = 10;/** 在node中有一个全局变量global，它的作用和网页中window类似 • 在全局中创建的变量都会作为global的属性保存 • 在全局中创建的函数都会作为global的方法保存 */// console.log(global.a);/** arguments.callee - 这个属性保存的是当前执行的函数对象 */console.log(arguments.callee + \"\");&#125; 实际上模块中的代码都是包装在一个函数中执行的，并且在函数执行时，同时传递进了5个实参： (1).exports：该对象用于将变量或函数暴露到外部 (2).require：函数，用来引入外部的模块 (3).module：代表的就是当前模块本身，exports就是module的属性 (4).__filename：当前模块的完整路径 (5).__dirname：当前模块所在文件夹的完整路径 exports和module.exports的区别： (1).通过exports只能使用 . 的方式来向外暴露内部变量，如exports.xxx = yyy (2).module.exports既可以通过 . 的方式，也可以直接赋值 ​ module.exports.xxx = yyy ​ module.exports = { ​ } NPM包 package• CommonJS的包规范允许我们将一组相关的模块组合到一起，形成一组完整的工具。• CommonJS的包规范由包结构和包描述文件两个部分组成 包结构：用于组织包中的各种文件 • 包实际上就是一个压缩文件，解压以后还原为目录。符合规范的目录，应该包含如下文件：– package.json 描述文件（必须要有）– bin 可执行二进制文件– lib js代码– doc 文档– test 单元测试 包描述文件：描述包的相关信息，以供外部读取分析 • 包描述文件用于表达非代码相关的信息，它是一个JSON格式的文件 – package.json，位于包的根目录下，是包的重要组成部分。• package.json中的字段– name、description、version、keywords、maintainers、contributors、bugs、licenses、repositories、dependencies、homepage、os、cpu、engine、builtin、directories、implements、scripts、author、bin、main、devDependencies。 NPM(Node Package Manager)• CommonJS包规范是理论，NPM是其中一种实践。• 对于Node而言，NPM帮助其完成了第三方模块的发布、安装和依赖等。借助NPM，Node与第三方模块之间形成了很好的一个生态系统。 NPM命令常用命令： • npm –v 查看npm的版本 • npm version 查看所有模块的版本 • npm search 包名 搜索包 • npm install / i 包名 安装包 • npm remove / r 包名 删除包 • npm install 包名 –save 安装包并添加到依赖中 • npm install 下载当前项目所依赖的包 • npm install 包名 -g 全局安装包（全局安装的包一般都是一些工具） • npm init 初始化项目生成package.json文件 • npm install 包名 –registry=地址 从镜像源安装 • npm config set registry 地址 设置镜像源 安装cnpm（使用淘宝镜像）: 1npm install -g cnpm --registry=https://registry.npm.taobao.org Node搜索包的流程： • Node在使用模块名字来引入模块时，它会首先在当前目录的node_modules中寻找是否包含有该模块 • 如果有则直接使用，如果没有则去上一级目录的node_modules中寻找 • 如果有则直接使用，如果没有则再去上一级目录寻找，直到找到为止 • 直到找到磁盘的根目录，如果依然没有，则报错 文件系统BufferBuffer(缓冲区) • 从结构上看Buffer非常像一个数组，它的元素为16进制的两位数。 • 实际上一个元素就表示内存中的一个字节。 • 实际上Buffer中的内存不是通过JavaScript分配的，而是在底层通过C++申请的。 • 也就是我们可以直接通过Buffer来创建内存中的空间。 Buffer的操作 • Buffer.from(str) 将一个字符串转换为buffer • Buffer.alloc(size) 创建一个指定大小的buffer • Buffer.allocUnsafe(size) 创建一个指定大小的buffer，但是可能包含敏感数据 • buf.toString() 将缓冲区的数据转换为字符串 写入操作• 向缓冲区中写入字符串 – buf.write(string[, offset[, length]][, encoding])• 替换指定索引位置的数据 – buf[index]• 将指定值填入到缓冲区的指定位置 – buf.fill(value[, offset[, end]][, encoding]) 读取操作• 将缓冲区中的内容，转换为一个字符串返回 – buf.toString([encoding[, start[, end]]])• 读取缓冲区指定索引的内容 – buf[index] 其他操作• 复制缓冲区 – buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])• 对缓冲区切片 – buf.slice([start[, end]])• 拼接缓冲区 – Buffer.concat(list[, totalLength]) fs（文件系统）• 在Node中，与文件系统的交互是非常重要的，服务器的本质就将本地的文件发送给远程的客户端• Node通过fs模块来和文件系统进行交互• 该模块提供了一些标准文件访问API来打开、读取、写入文件，以及与其交互。• 要使用fs模块，首先需要对其进行加载 – const fs = require(“fs”); 同步和异步调用• fs模块中所有的操作都有两种形式可供选择同步和异步。• 同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码。• 异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回。 打开和关闭文件• 打开文件 – fs.open(path, flags[, mode], callback) – fs.openSync(path, flags[, mode])• 关闭文件 – fs.close(fd, callback) – fs.closeSync(fd) 打开状态(mode)r 读取文件 , 文件不存在则出现异常r+ 读写文件 , 文件不存在则出现异常rs 在同步模式下打开文件用于读取rs+ 在同步模式下打开文件用于读写w 打开文件用于写操作 , 如果不存在则创建，如果存在则截断wx 打开文件用于写操作 , 如果 存在则打开失败w+ 打开文件用于读写 , 如果不存在则创建 , 如果存在则截断wx+ 打开文件用于读写 , 如果 存在则打开失败a 打开文件用于追加 , 如果不存在则创建ax 打开文件用于追加 , 如果路径存在则失败a+ 打开文件进行读取和追加 , 如果不存在则创建该文件ax+ 打开文件进行读取和追加 , 如果路径存在则失败 同步文件写入• fs.writeSync(fd, buffer, offset, length[, position])• fs.writeSync(fd, data[, position[, encoding]]) • 要完成同步写入文件，先需要通过openSync()打开文件来获取一个文件描述符，然后在通过writeSync()写入文件。 • 参数 – fd 文件描述符，通过openSync()获取 – data 要写入的数据（String 或 Buffer） – offset buffer写入的偏移量 – length 写入的长度 – position 写入的起始位置 – encoding 写入编码 示例代码： 123456789101112131415161718192021222324252627282930313233343536/** 文件系统（File System） - 文件系统简单来说就是通过Node来操作系统中的文件 - 使用文件系统，需要先引入fs模块，fs是核心模块，直接引入不需要下载 同步文件的写入 - 手动操作的步骤 1.打开文件 fs.openSync(path, flags[, mode]) - path 要打开的文件路径 - flags 打开文件要做的操作的类型 r 只读的 w 可写的 - mode 设置文件的操作权限，一般不传 返回值：该方法会返回一个文件的描述符作为结果，我们可以通过该描述符来对文件进行各种操作 2.向文件中写入内容 fs.writeSync(fd, string[, position[, encoding]]) - fd 文件的描述符，需要传递写入的文件的描述符 - string 要写入的内容 - position 写入的起始位置 - encoding 写入的编码，默认utf-8 3.保存并关闭文件 fs.close(fd) - fd 要关闭的文件的描述符 */var fs = require(\"fs\");// 打开文件var fd = fs.openSync(\"hello.txt\", \"w\");// 向文件中写入内容fs.writeSync(fd, \"今天天气真不错~~~\");// 关闭文件fs.closeSync(fd); 异步文件写入• fs.write(fd, buffer, offset, length[, position], callback)• fs.write(fd, data[, position[, encoding]], callback) • 要使用异步写入文件，先需要通过open()打开文件，然后在回调函数中通过write()写入。 • 参数： – fd 文件描述符 – data 要写入的数据（String 或 Buffer） – offset buffer写入的偏移量 – length 写入的长度 – position 写入的起始位置 – encoding 写入编码 示例代码： 12345678910111213141516171819202122232425262728293031323334/** 异步文件写入 fs.open(path, flags[, mode], callback) - 用来打开一个文件 - 异步调用的方法，结果都是通过回调函数的参数返回的 - 回调函数的两个参数： - err 错误对象，如果没有错误则为null - fd 文件的描述符 fs.write(fd, string[, position[, encoding]], callback) - 用来异步写入一个文件 fs.close(fd, callback) - 用来关闭文件 */var fs = require(\"fs\");// 打开文件fs.open(\"hello2.txt\", \"w\", function (err, fd) &#123; if(!err)&#123; fs.write(fd, \"这是异步写入的内容\", function (err) &#123; if(!err)&#123; console.log(\"写入成功~~~\"); &#125; // 关闭文件 fs.close(fd, function () &#123; if(!err)&#123; console.log(\"文件已关闭~~~\"); &#125; &#125;) &#125;) &#125;else&#123; console.log(err); &#125;&#125;) 简单文件写入• fs.writeFile(file, data[, options], callback)• fs.writeFileSync(file, data[, options]) • 参数： – file 文件路径 – data 被写入的内容，可以是String或Buffer – options 对象，包含属性（encoding、mode、flag） – callback 回调函数 示例代码： 12345678910111213141516171819202122/** 简单文件写入 fs.writeFile(file, data[, options], callback) fs.writeFileSync(file, data[, options]) - file 要操作的文件路径 - data 要写入的数据 - options 选项，可以对写入进行一些设置 - flag r 只读 w 可写 a 追加 - callback 当写入完成以后执行的函数 */var fs = require(\"fs\");fs.writeFile(\"hello3.txt\", \"这是通过writeFile写入的内容\", &#123;flag: \"a\"&#125;, function (err) &#123; if(!err)&#123; console.log(\"写入成功~~~\"); &#125;else&#123; console.log(err); &#125;&#125;) 流式文件写入• 往一个文件中写入大量数据时，最好的方法之一是使用流。• 若要将数据异步传送到文件，首需要使用以下语法创建一个Writable对象： – fs.createWriteStream(path[, options]) • path 文件路径 • options {encoding:””,mode:””,flag:””}• 一旦你打开了Writable文件流，就可以使用write()方法来写入它，写入完成后，再调用end()方法来关闭流。 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738/** 同步、异步、简单文件的写入，都不适合大文件的写入，性能较差，容易导致内存溢出 */var fs = require(\"fs\");// 流式文件写入// 创建一个可写流/** fs.createWriteStram(path[, options]) - 可以用来创建一个可写流 - path 文件路径 - options 配置的参数 */var ws = fs.createWriteStream(\"hello5.txt\");// 可以通过监听流的open和close事件来监听流的打开和关闭/** on(事件字符串， 回调函数) - 可以为对象绑定一个事件 once(事件字符串， 回调函数) - 可以为对象绑定一个一次性的事件，该事件将会在触发一次之后自动失效 */ws.once(\"open\", function () &#123; console.log(\"流打开了~\")&#125;)ws.once(\"close\", function () &#123; console.log(\"流关闭了~\")&#125;)// 通过ws向文件中输出内容ws.write(\"通过可写流写入文件的内容1\");ws.write(\"通过可写流写入文件的内容2\");ws.write(\"通过可写流写入文件的内容3\");ws.write(\"通过可写流写入文件的内容4\");ws.write(\"通过可写流写入文件的内容5\");// 关闭流ws.end(); 同步文件读取• fs.readSync(fd, buffer, offset, length, position) – 参数： • fd 文件描述符 • buffer 读取文件的缓冲区 • offset buffer的开始写入的位置 • length 要读取的字节数 • position 开始读取文件的位置 异步文件读取• fs.read(fd, buffer, offset, length, position, callback) – 参数： • fd 文件描述符 • buffer 读取文件的缓冲区 • offset buffer的开始写入的位置 • length 要读取的字节数 • position 开始读取文件的位置 • callback 回调函数 参数err , bytesRead , buffer 简单文件读取• fs.readFile(file[, options], callback)• fs.readFileSync(file[, options]) – 参数： • file 文件路径或文件描述符 • options – encoding 默认 = null – flag 默认 = ‘r’ • callback 回调函数，有两个参数err 、data 示例代码： 12345678910111213141516171819202122232425/** 简单文件读取 fs.readFile(path[, options], callback) fs.readFileSync(path[, options]) - path 要读取的文件路径 - options 读取的选项 - callback 回调函数，通过回调函数将读取到内容返回(err, data) err 错误对象 data 读取到的数据，会返回一个Buffer */var fs = require(\"fs\");fs.readFile(\"hello3.txt\", function (err, data) &#123; if(!err)&#123; console.log(data.toString()) // 将data写入到文件中 fs.writeFile(\"copyOf_hello3.txt\", data, function (err) &#123; if(!err)&#123; console.log(\"文件写入成功\"); &#125;else&#123; console.log(err); &#125; &#125;) &#125;&#125;) 流式文件读取• 从一个文件中读取大量的数据时，最好的方法之一就是流式读取，这样将把一个文件作为Readable流的形式打开。• 要从异步从文件传输数据，首先需要通过以下语法创建一个Readable流对象： – fs.createReadStream(path[, options]) • path 文件路径 • options {encoding:””,mode:””,flag:””}• 当你打开Readable文件流以后，可以通过readable事件和read()请求，或通过data事件处理程序轻松地从它读出。 示例代码： 1234567891011121314151617181920212223242526272829303132/** 流式文件读取也适用于一些比较大的文件，可以分多次将文件读取到内存中 */var fs = require(\"fs\");// 创建一个可读流var rs = fs.createReadStream(\"avatar.jpg\");// 创建一个可写流var ws = fs.createWriteStream(\"test.jpg\");// 监听流的打开和关闭rs.once(\"open\", function () &#123; console.log(\"可读流打开了~\")&#125;)rs.once(\"close\", function () &#123; console.log(\"可读流关闭了~\"); // 数据读取完毕，关闭可写流 ws.end();&#125;)ws.once(\"open\", function () &#123; console.log(\"可写流打开了~\")&#125;)ws.once(\"close\", function () &#123; console.log(\"可写流关闭了~\")&#125;)// 如果要读取一个可读流中的数据，必须要为可读流绑定一个data事件，data事件绑定完毕，它会自动开始读取数据rs.on(\"data\", function (data) &#123; console.log(data); // 将读取到的数据写入到可写流中 ws.write(data);&#125;) 利用pipe()实现更简洁的文件复制： 123456789var fs = require(\"fs\");// 创建一个可读流var rs = fs.createReadStream(\"avatar.jpg\");// 创建一个可写流var ws = fs.createWriteStream(\"test.jpg\");// pipe()可以将可读流中的内容，直接输出到可写流中rs.pipe(ws); 其他操作• 验证路径是否存在 – fs.exists(path，callback) – fs.existsSync(path) • 获取文件信息 – fs.stat(path, callback) – fs.statSync(path) • 删除文件 – fs.unlink(path, callback) – fs.unlinkSync(path) • 列出文件 – fs.readdir(path[, options], callback) – fs.readdirSync(path[, options]) • 截断文件 – fs.truncate(path, len, callback) – fs.truncateSync(path, len) • 建立目录 – fs.mkdir(path[, mode], callback) – fs.mkdirSync(path[, mode]) • 删除目录 – fs.rmdir(path, callback) – fs.rmdirSync(path) • 重命名文件和目录（可实现剪切的功能） – fs.rename(oldPath, newPath, callback) – fs.renameSync(oldPath, newPath) • 监视文件更改写入 – fs.watchFile(filename[, options], listener)","tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://sunshine-zwq.github.io/tags/jQuery/"},{"name":"Node.js","slug":"Node-js","permalink":"https://sunshine-zwq.github.io/tags/Node-js/"}]},{"title":"jQuery包裹节点方法wrap()、wrapAll()、wrapInner()的区别","date":"2020-08-29T03:10:25.593Z","path":"2020/08/29/jQuery包裹节点方法wrap()、wrapAll()、wrapInner()的区别/","text":"1.wrap()方法原始DOM代码： 1234&lt;div id=\"container\"&gt; &lt;div&gt;姓名：小明&lt;/div&gt; &lt;div&gt;年龄：20岁&lt;/div&gt;&lt;/div&gt; 使用wrap()： 1$(\"#container\").wrap('&lt;div class=\"wrapper\"&gt;&lt;/div&gt;'); 处理后DOM代码： 123456&lt;div class=\"wrapper\"&gt; &lt;div id=\"container\"&gt; &lt;div&gt;姓名：小明&lt;/div&gt; &lt;div&gt;年龄：20岁&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 效果：给$选择器的所有元素外部包裹一层wrapper 2.wrapAll()方法原始DOM代码： 12345&lt;div id=\"container\"&gt; &lt;p&gt;姓名：小明&lt;/p&gt; &lt;p&gt;年龄：20岁&lt;/p&gt; &lt;div&gt;性别：男&lt;div&gt;&lt;/div&gt; 使用wrapAll()： 1$(\"p\").wrapAll('&lt;div class=\"wrapper\"&gt;&lt;/div&gt;'); 处理后DOM代码： 1234567&lt;div id=\"container\"&gt; &lt;div class=\"wrapper\"&gt; &lt;p&gt;姓名：小明&lt;/p&gt; &lt;p&gt;年龄：20岁&lt;/p&gt; &lt;/div&gt; &lt;div&gt;性别：男&lt;div&gt;&lt;/div&gt; 效果：给$选择器的全部匹配元素的外部包裹一层wrapper 3.wrapInner()方法原始DOM代码： 1234&lt;div id=\"container\"&gt; &lt;div&gt;姓名：小明&lt;/div&gt; &lt;div&gt;年龄：20岁&lt;/div&gt;&lt;/div&gt; 使用wrapInner()： 1$(\"#container\").wrapInner('&lt;div class=\"wrapper\"&gt;&lt;/div&gt;'); 处理后DOM代码： 123456&lt;div id=\"container\"&gt; &lt;div class=\"wrapper\"&gt; &lt;div&gt;姓名：小明&lt;/div&gt; &lt;div&gt;年龄：20岁&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 效果：给$选择器的所有元素内部包裹一层wrapper","tags":[{"name":"前端","slug":"前端","permalink":"https://sunshine-zwq.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"jQuery","slug":"jQuery","permalink":"https://sunshine-zwq.github.io/tags/jQuery/"}]},{"title":"用apache的ftpserver搭建FTP服务器","date":"2020-08-23T15:44:27.115Z","path":"2020/08/23/用apache的ftpserver搭建FTP服务器/","text":"maven依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.ftpserver&lt;/groupId&gt; &lt;artifactId&gt;ftpserver-core&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt; 主要代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import org.apache.ftpserver.FtpServer;import org.apache.ftpserver.FtpServerFactory;import org.apache.ftpserver.ftplet.Authority;import org.apache.ftpserver.listener.ListenerFactory;import org.apache.ftpserver.usermanager.impl.BaseUser;import org.apache.ftpserver.usermanager.impl.WritePermission;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.ArrayList;import java.util.List;/** * 搭建ftp服务器 * @author zhuwq * @date 2020/8/21 17:27 */public class MyFtpServer &#123; private static Logger logger = LoggerFactory.getLogger(MyFtpServer.class); /** * 启动FTP服务 * @param port 端口 * @param username ftp用户名 * @param password ftp用户密码 * @param homeDirectory 主页目录 * @return */ public static boolean startServer(int port, String username, String password, String homeDirectory)&#123; logger.info(\"MyFtpServer.startServer[port:&#123;&#125;,username:&#123;&#125;,password:&#123;&#125;,homeDirectory:&#123;&#125;]\", port, username, password, homeDirectory); try&#123; FtpServerFactory serverFactory = new FtpServerFactory(); ListenerFactory factory = new ListenerFactory(); //设置监听端口 factory.setPort(port); //替换默认监听 serverFactory.addListener(\"default\", factory.createListener()); //用户名 BaseUser user = new BaseUser(); user.setName(username); //密码 如果不设置密码就是匿名用户 user.setPassword(password); //用户主目录 user.setHomeDirectory(homeDirectory); List&lt;Authority&gt; authorities = new ArrayList&lt;Authority&gt;(); //增加写权限 authorities.add(new WritePermission()); user.setAuthorities(authorities); //增加该用户 serverFactory.getUserManager().save(user); FtpServer server = serverFactory.createServer(); server.start(); logger.info(\"MyFtpServer.startServer success!!!\"); return true; &#125;catch (Exception e)&#123; e.printStackTrace(); logger.error(e.getMessage(), e); return false; &#125; &#125;&#125; 测试代码1234567public static void main(String[] args) &#123; int port = 21; String username = \"admin\"; String password = \"123456\"; String homeDirectory = \"E:\\\\FTPServer\"; MyFtpServer.startServer(port, username, password, homeDirectory); &#125; 参考链接：https://blog.csdn.net/fengsheng5210/article/details/78140746","tags":[{"name":"java","slug":"java","permalink":"https://sunshine-zwq.github.io/tags/java/"},{"name":"ftp","slug":"ftp","permalink":"https://sunshine-zwq.github.io/tags/ftp/"}]},{"title":"json转换","date":"2020-07-12T03:02:12.968Z","path":"2020/07/12/json转换/","text":"fastjsonjson字符串转JSONObject1JSONObject jsonObject = JSON.parseObject(json); json字符串转对象1Student student = JSONObject.parseObject(json, Student.class); json字符串转List1List&lt;Student&gt; studentList = JSONObject.parseArray(json, Student.class); json字符串转Map1Map&lt;String,String&gt; map = JSONObject.parseObject(json, Map.class); 对象转json字符串1String json = JSON.toJSONString(obj);","tags":[{"name":"json","slug":"json","permalink":"https://sunshine-zwq.github.io/tags/json/"}]},{"title":"ECMAScript入门","date":"2020-03-18T16:43:38.000Z","path":"2020/03/19/ECMAScript入门/","text":"基本介绍123456789101112131. 它是一种由ECMA组织（前身为欧洲计算机制造商协会）制定和发布的脚本语言规范2. 而我们学的 JavaScript 是ECMA的实现, 但术语ECMAScript和JavaScript平时表达同一个意思3. JS包含三个部分： 1). ECMAScript（核心） 2). 扩展&#x3D;&#x3D;&gt;浏览器端 * BOM（浏览器对象模型） * DOM（文档对象模型） 3). 扩展&#x3D;&#x3D;&gt;服务器端 * Node4. ES的几个重要版本 * ES5 : 09年发布 * ES6(ES2015) : 15年发布, 也称为ECMA2015 * ES7(ES2016) : 16年发布, 也称为ECMA2016 (变化不大) ES5严格模式1234567891011121314151. 理解: * 除了正常运行模式(混杂模式)，ES5添加了第二种运行模式：&quot;严格模式&quot;（strict mode）。 * 顾名思义，这种模式使得Javascript在更严格的语法条件下运行2. 目的&#x2F;作用 * 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 * 消除代码运行的一些不安全之处，为代码的安全运行保驾护航 * 为未来新版本的Javascript做好铺垫3. 使用 * 在全局或函数的第一条语句定义为: &#39;use strict&#39;; * 如果浏览器不支持, 只解析为一条简单的语句, 没有任何副作用4. 语法和行为改变 * 必须用var声明变量 * 禁止自定义的函数中的this指向window * 创建eval作用域 * 对象不能有重名的属性 示例代码： 12345678910111213141516171819202122&lt;script type=\"text/javascript\"&gt; 'use strict'; // username = 'kobe'; var username = 'kobe'; console.log(username); function Person (name, age) &#123; this.name = name; this.age = age; &#125; // Person('kobe', 41); new Person('kobe', 41); var str = 'NBA'; eval('var str = \"CBA\"; alert(str)'); alert(str); var obj = &#123; username: 'kobe', // username: 'wade' &#125;&lt;/script&gt; JSON对象12341. JSON.stringify(obj&#x2F;arr) * js对象(数组)转换为json对象(数组)2. JSON.parse(json) * json对象(数组)转换为js对象(数组) Object扩展12345678910111213ES5给Object扩展了一些静态方法, 常用的2个:1. Object.create(prototype, [descriptors]) * 作用: 以指定对象为原型创建新的对象 * 为新的对象指定新的属性, 并对属性进行描述 - value : 指定值 - writable : 标识当前属性值是否是可修改的, 默认为false - configurable: 标识当前属性是否可以被删除 默认为false - enumerable： 标识当前属性是否能用for in 枚举 默认为false2. Object.defineProperties(object, descriptors) * 作用: 为指定对象定义扩展多个属性 * get ：用来获取当前属性值的回调函数（需要取值时才会调用，“惰性求值”） * set ：修改当前属性值得触发的回调函数，并且实参即为修改后的值 * 存取器属性：setter,getter一个用来存值，一个用来取值 示例代码： 12345678910111213141516171819202122232425262728293031323334353637var obj = &#123;username: 'damu', age: 30&#125;;var obj1 = &#123;&#125;;obj1 = Object.create(obj, &#123; sex: &#123; value: '男', writable: true, configurable: true, enumerable: true &#125;&#125;);console.log(obj1.sex);obj1.sex = '女';console.log(obj1.sex);// delete obj1.sex;console.log(obj1);for(var i in obj1)&#123; console.log(i);&#125;var obj2 = &#123;firstName: 'kobe', lastName: 'bryant'&#125;;Object.defineProperties(obj2, &#123; fullName: &#123; get: function()&#123;// 获取扩展属性的值（获取扩展属性值时get会自动调用） return this.firstName + ' ' + this.lastName; &#125;, set: function(data)&#123;// 监听扩展属性，当扩展属性发生变化的时候会自动调用（变化后的值作为实参传入） var names = data.split(' '); this.firstName = names[0]; this.lastName = names[1]; &#125; &#125;&#125;)console.log(obj2.fullName);obj2.fullName = 'tim duncan';console.log(obj2.fullName);console.log(obj2.lastName); 123对象本身的两个方法* get propertyName()&#123;&#125; 用来得到当前属性值的回调函数* set propertyName()&#123;&#125; 用来监视当前属性值变化的回调函数 示例代码： 123456789101112131415var obj = &#123; firstName: 'curry', lastName: 'stephen', get fullName()&#123; return this.firstName + ' ' + this.lastName; &#125;, set fullName(data)&#123; var names = data.split(' '); this.firstName = names[0]; this.lastName = names[1]; &#125;&#125;;console.log(obj);obj.fullName = 'kobe bryant';console.log(obj.fullName); Array扩展123451. Array.prototype.indexOf(value) : 得到值在数组中的第一个下标2. Array.prototype.lastIndexOf(value) : 得到值在数组中的最后一个下标3. Array.prototype.forEach(function(item, index)&#123;&#125;) : 遍历数组4. Array.prototype.map(function(item, index)&#123;&#125;) : 遍历数组返回一个新的数组，返回加工之后的值5. Array.prototype.filter(function(item, index)&#123;&#125;) : 遍历过滤出一个新的子数组， 返回条件为true的值 示例代码： 12345678910111213141516171819202122232425/* 需求: 1. 输出第一个6的下标 2. 输出最后一个6的下标 3. 输出所有元素的值和下标 4. 根据arr产生一个新数组,要求每个元素都比原来大10 5. 根据arr产生一个新数组, 返回的每个元素要大于4 */var arr = [2,4,3,1,2,6,5,4];console.log(arr.indexOf(4));console.log(arr.lastIndexOf(4));arr.forEach(function(item, index)&#123; console.log(item, index);&#125;)var arr1 = arr.map(function (item, index) &#123; return item + 10;&#125;)console.log(arr1);var arr2 = arr.filter(function (item, index) &#123; return item &gt; 4;&#125;)console.log(arr2); Function扩展1234561. Function.prototype.bind(obj) : * 作用: 将函数内的this绑定为obj, 并将函数返回2. 面试题: 区别bind()与call()和apply()? * 都能指定函数中的this * call()&#x2F;apply()是立即调用函数 * bind()是将函数返回 示例代码： 123456789101112131415161718192021var obj = &#123;username: 'kobe'&#125;;function foo(data)&#123; console.log(this, data);&#125;// 直接调用foo方法打印的this是Window// foo();// call和apply的方法作用一样，区别在于传参的方式foo.call(obj, 33);// 直接从第2个参数开始，依次传入foo.apply(obj, [33]);// 第二个参数必须是数组，参数放在数组里// bind的特点：绑定完this不会立即调用当前的函数，而是将函数返回var bar = foo.bind(obj);bar();// bind的传参方式和call一样foo.bind(obj, 33)();// 应用举例setTimeout(function()&#123; console.log(this);&#125;.bind(obj), 1000); ES6（常用）let关键字1234567891. 作用: * 与var类似, 用于声明一个变量2. 特点: * 在块作用域内有效 * 不能重复声明 * 不会预处理（即不能在声明之前使用，会抛出异常，而var在声明前使用值是undefined）, 不存在提升3. 应用: * 循环遍历加监听 * 使用let取代var是趋势 示例代码： 1234567891011121314151617181920212223242526272829303132333435// console.log(username);let username = 'kobe';// let username = 'wade';console.log(username);let btns = document.getElementsByTagName('button');for(var i = 0; i &lt; btns.length; i++)&#123; var btn = btns[i]; btn.onclick = function () &#123; // 打印出来的都是3 alert(i); &#125;&#125;// 解决方法1：用闭包函数btns = document.getElementsByTagName('button');for(var i = 0; i &lt; btns.length; i++)&#123; var btn = btns[i]; (function(i)&#123; btn.onclick = function () &#123; // 打印出来的都是3 alert(i); &#125; &#125;)(i)&#125;// 解决方法2：用let关键字btns = document.getElementsByTagName('button');for(let i = 0; i &lt; btns.length; i++)&#123; var btn = btns[i]; btn.onclick = function () &#123; // 打印出来的都是3 alert(i); &#125;&#125; const关键字12345671. 作用: * 定义一个常量2. 特点: * 不能修改 * 其它特点同let3. 应用: * 保存不用改变的数据 解构赋值123456781. 理解: * 从对象或数组中提取数据, 并赋值给变量(多个)2. 对象的解构赋值 let &#123;n, a&#125; &#x3D; &#123;n:&#39;tom&#39;, a:12&#125;3. 数组的解构赋值 let [a,b] &#x3D; [1, &#39;atguigu&#39;];4. 用途 * 给多个形参赋值 示例代码： 1234567891011121314let obj = &#123;username: 'kobe', age: 39&#125;;// let username = obj.username;// let age = obj.age;let &#123;username, age&#125; = obj;console.log(username, age);let arr = [1,3,5,'abc',true];let [,,a,b] = arr;console.log(a, b);function foo(&#123;username, age&#125;)&#123;// &#123;username, age&#125; = obj console.log(username, age);&#125;foo(obj); 模板字符串1231. 模板字符串 : 简化字符串的拼接 * 模板字符串必须用 &#96;&#96; 包含 * 变化的部分使用$&#123;xxx&#125;定义 示例代码： 12345let obj = &#123;username: 'kobe', age: 39&#125;;let str = '我的名字叫：' + obj.username + '，我今年的年龄是：' + obj.age;console.log(str);str = `我的名字叫：$&#123;obj.username&#125;，我今年的年龄是：$&#123;obj.age&#125;`;console.log(str); 简化的对象写法1234567891011简化的对象写法* 省略同名的属性值* 省略方法的function* 例如: let x &#x3D; 1; let y &#x3D; 2; let point &#x3D; &#123; x, y, setX (x) &#123;this.x &#x3D; x&#125; &#125;; 箭头函数123456789101112131415* 作用: 定义匿名函数* 基本语法: * 没有参数: () &#x3D;&gt; console.log(&#39;xxxx&#39;) * 一个参数: i &#x3D;&gt; i+2 * 大于一个参数: (i,j) &#x3D;&gt; i+j * 函数体不用大括号: 默认返回结果 * 函数体如果有多个语句, 需要用&#123;&#125;包围，若有需要返回的内容，需要手动返回* 使用场景: 多用来定义回调函数* 箭头函数的特点： 1、简洁 2、箭头函数没有自己的this，箭头函数的this不是调用的时候决定的，而是在定义的时候处在的对象就是它的this 3、扩展理解： 箭头函数的this看外层的是否有函数， 如果有，外层函数的this就是内部箭头函数的this， 如果没有，则this是window。 示例代码： 123456789101112131415161718192021222324252627282930313233// 不同传参的情况// 1、没有形参let fun = () =&gt; console.log('我是箭头函数');fun();// 2、只有1个形参，()可以省略let fun2 = a =&gt; console.log(a);fun2('aaa');// 3、两个及以上形参，()不能省略let fun3 = (x, y) =&gt; console.log(x, y);fun3(25, 36);// 不同函数体的情况// 1、函数体只有一条语句或是表达式的时候，&#123;&#125;可以省略。会自动返回语句执行的结果或是表达式的结果let fun4 = (x, y) =&gt; x + y;console.log(fun4(24, 36));// 2、函数体不止一条语句或表达式的情况下，&#123;&#125;不可以省略let fun5 = (x, y) =&gt; &#123; console.log(x, y); return x + y;&#125;console.log(fun5(35, 50));let obj = &#123; name: '箭头函数', // getName()&#123; getName: () =&gt; &#123; btn2.onclick = () =&gt; &#123; console.log(this); &#125; &#125;&#125;// 等价于 obj.getName = () =&gt; &#123;&#125;，所以this是Window对象obj.getName(); 三点运算符12345678910111213141516171819* 用途1. rest(可变)参数 * 用来取代arguments 但比 arguments 灵活,只能是最后部分形参参数 function fun(...values) &#123; console.log(arguments); arguments.forEach(function (item, index) &#123; console.log(item, index); &#125;); console.log(values); values.forEach(function (item, index) &#123; console.log(item, index); &#125;) &#125; fun(1,2,3);2. 扩展运算符 let arr1 &#x3D; [1,3,5]; let arr2 &#x3D; [2,...arr1,6]; console.log(arr2); console.log(...arr2); 形参默认值12345* 形参的默认值----当不传入参数的时候默认使用形参里的默认值function Point(x &#x3D; 1,y &#x3D; 2) &#123; this.x &#x3D; x; this.y &#x3D; y;&#125; Promise对象123456789101112131415161718192021222324252627282930313233341. 理解: * Promise对象: 代表了未来某个将要发生的事件(通常是一个异步操作) * 有了promise对象, 可以将异步操作以同步的流程表达出来, 避免了层层嵌套的回调函数(俗称&#39;回调地狱&#39;) * ES6的Promise是一个构造函数, 用来生成promise实例2. 使用promise基本步骤(2步): * 创建promise对象 let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123; &#x2F;&#x2F;初始化promise状态为 pending &#x2F;&#x2F;执行异步操作 if(异步操作成功) &#123; resolve(value);&#x2F;&#x2F;修改promise的状态为fullfilled &#125; else &#123; reject(errMsg);&#x2F;&#x2F;修改promise的状态为rejected &#125; &#125;) * 调用promise的then() promise.then( result &#x3D;&gt; console.log(result), errorMsg &#x3D;&gt; alert(errorMsg) )3. promise对象的3个状态 * pending: 初始化状态 * fullfilled: 成功状态 * rejected: 失败状态4. 应用: * 使用promise实现超时处理 * 使用promise封装处理ajax请求 let request &#x3D; new XMLHttpRequest(); request.onreadystatechange &#x3D; function () &#123; &#125; request.responseType &#x3D; &#39;json&#39;; request.open(&quot;GET&quot;, url); request.send(); 示例代码： 12345678910111213141516171819202122// 创建promise对象let promise = new Promise((resolve, reject) =&gt; &#123; // 初始化promise状态：pending: 初始化 console.log('111'); // 执行异步操作，通常是发送ajax请求、开启定时器 setTimeout(function () &#123; console.log('333'); // 根据异步任务的返回结果去修改promise状态 // 异步任务执行成功 resolve('哈哈');// 修改promise的状态为 fullfilled: 成功的状态 // 异步任务执行失败 // reject('555');// 修改promise的状态为 rejected: 失败的状态 &#125;, 2000);&#125;)console.log('222');promise.then((data) =&gt; &#123;// 成功的回调 console.log(data, '成功了！')&#125;, (error) =&gt; &#123;// 失败的回调 console.log(error, '失败了。。。')&#125;) 应用案例： 123456789101112131415161718192021222324252627282930313233343536373839404142// 定义获取新闻的函数function getNews(url)&#123; let promise = new Promise((resolve, reject) =&gt; &#123; // 状态：初始化 // 执行异步任务 // 创建xmlHttp实例对象 let xmlHttp = new XMLHttpRequest(); // 绑定监听 readyState xmlHttp.onreadystatechange = function()&#123; if(xmlHttp.readyState === 4)&#123; if(xmlHttp.status == 200)&#123;// 请求成功 // 修改状态 resolve(xmlHttp.responseText);// 修改promise的状态为成功的状态 &#125;else&#123;// 请求失败 reject('暂时没有新闻内容'); &#125; &#125; &#125; // open 设置请求的方式以及url xmlHttp.open('GET', url); // 发送 xmlHttp.send(); &#125;) return promise;&#125;getNews('http://localhost:3000/news?id=2').then((data) =&gt; &#123; console.log(data); // 发送请求获取评论内容准备url let commentsUrl = JSON.parse(data).commentsUrl; let url = 'http://localhost:3000' + commentsUrl; // 发送请求 return getNews(url);&#125;, (error) =&gt; &#123; console.log(error);&#125;).then((data) =&gt; &#123; console.log(data);&#125;, (error) =&gt; &#123;&#125;) Symbol123456789101112131415161718192021前言：ES5中对象的属性名都是字符串，容易造成重名，污染环境Symbol： 概念：ES6中的添加了一种原始数据类型symbol(已有的原始数据类型：String, Number, boolean, null, undefined, 对象) 特点： 1、Symbol属性对应的值是唯一的，解决命名冲突问题 2、Symbol值不能与其他数据进行计算，包括同字符串拼串 3、for in, for of遍历时不会遍历symbol属性。 使用： 1、调用Symbol函数得到symbol值 let symbol &#x3D; Symbol(); let obj &#x3D; &#123;&#125;; obj[symbol] &#x3D; &#39;hello&#39;; 2、传参标识 let symbol &#x3D; Symbol(&#39;one&#39;); let symbol2 &#x3D; Symbol(&#39;two&#39;); console.log(symbol);&#x2F;&#x2F; Symbol(&#39;one&#39;) console.log(symbol2);&#x2F;&#x2F; Symbol(&#39;two&#39;) 3、内置Symbol值 * 除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。 - Symbol.iterator * 对象的Symbol.iterator属性，指向该对象的默认遍历器方法 示例代码： 1234567891011121314151617181920// 创建Symbol属性值let symbol = Symbol();console.log(symbol);let obj = &#123;username: 'kobe', age: 39&#125;;obj[symbol] = 'hello';console.log(obj);// for in, for of遍历时不会遍历symbol属性for(let i in obj)&#123; console.log(i);&#125;let symbol2 = Symbol('one');let symbol3 = Symbol('two');console.log(symbol2 == symbol3);// falseconsole.log(symbol2, symbol3);// 可以去定义常量const Person_key = Symbol('person_key');console.log(Person_key); Iterator遍历器12345678910111213141516171819概念： iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制作用： 1、为各种数据结构，提供一个统一的、简便的访问接口； 2、使得数据结构的成员能够按某种次序排列 3、ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费。工作原理： - 创建一个指针对象(遍历器对象)，指向数据结构的起始位置。 - 第一次调用next方法，指针自动指向数据结构的第一个成员 - 接下来不断调用next方法，指针会一直往后移动，直到指向最后一个成员 - 每调用next方法返回的是一个包含value和done的对象，&#123;value: 当前成员的值,done: 布尔值&#125; * value表示当前成员的值，done对应的布尔值表示当前的数据的结构是否遍历结束。 * 当遍历结束的时候返回的value值是undefined，done值为false原生具备iterator接口的数据(可用for of遍历) 1、Array 2、arguments 3、set容器 4、map容器 5、String 。。。 实现模拟 Iterator 遍历器： 1234567891011121314151617// 模拟指针对象（遍历器对象）function myIterator(arr)&#123;// iterator接口 let nextIndex = 0;// 记录指针的位置 return &#123; next: function()&#123; return nextIndex &lt; arr.length ? &#123;value: arr[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125;&#125;// 准备一个数据let arr = [1, 4, 65, 'abc'];let iteratorObj = myIterator(arr);console.log(iteratorObj.next());console.log(iteratorObj.next());console.log(iteratorObj.next());console.log(iteratorObj.next());console.log(iteratorObj.next()); 示例代码： 12345678910111213141516let arr = [1, 4, 65, 'abc'];// 将iterator接口部署到指定的数据类型上，可以使用for of去循环遍历// 数组、字符串、arguments、set容器、map容器for(let i of arr)&#123; console.log(i);&#125;let str = 'abcdefg';for(let i of str)&#123; console.log(i);&#125;function fun()&#123; for(let i of arguments)&#123; console.log(i); &#125;&#125;fun(1,4,5,'abc'); 扩展： 1234567891011121314151617181920212223242526272829303132333435// 对象的Symbol.iterator属性，指向该对象的默认遍历器方法// 等同于在指定的数据内结构上部署了iterator接口，// 当使用for of去遍历某一个数据结构时，首先先去找Symbol.iterator，找到了就去遍历，没有找到的话不能遍历 ==》 xxx is not iterablelet targetData = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3, [Symbol.iterator]: function() &#123; let nextIndex = 0;// 记录指针的位置 return &#123; next: () =&gt; &#123; return nextIndex &lt; this.length ? &#123;value: this[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125; &#125;&#125;// 定义了Symbol.iterator之后，Object也可以用for of遍历了for(let i of targetData)&#123; console.log(i);&#125;// 用Symbol.iterator去迭代let numbers = [1,2,3,4,5];let iterator = numbers[Symbol.iterator]();console.log(iterator.next().value);console.log(iterator.next().value);// 使用三点运算符、解构赋值，默认去调用iterator接口let arr2 = [1, 6];let arr3 = [2, 3, 4, 5];arr2 = [1, ...arr3, 6];console.log(arr2);let [a, b] = arr2;console.log(a, b); Generator函数123456789101112131415161718Generator函数 概念： 1、ES6提供的解决异步编程的方案之一 2、Generator函数是一个状态机，内部封装了不同状态的数据， 3、用来生成遍历器对象 4、可暂停函数(惰性求值), yield可暂停，next方法可启动。每次返回的是yield后的表达式结果 特点： 1、function 与函数名之间有一个星号 2、内部用yield表达式来定义不同的状态 例如： function* generatorExample()&#123; let result &#x3D; yield &#39;hello&#39;; &#x2F;&#x2F; 状态值为hello yield &#39;generator&#39;; &#x2F;&#x2F; 状态值为generator &#125; 3、generator函数返回的是指针对象，而不会执行函数内部逻辑 4、调用next方法函数内部逻辑开始执行，遇到yield表达式停止，返回&#123;value: yield后的表达式结果&#x2F;undefined, done: false&#x2F;true&#125; 5、再次调用next方法会从上一次停止时的yield处开始，直到最后 6、yield语句返回结果通常为undefined， 当调用next方法时传参内容会作为启动时yield语句的返回值。 示例代码： 12345678910111213141516171819202122232425function* myGenerator()&#123; console.log('开始执行'); let result = yield 'hello'; console.log(result);// 打印结果==》传入的参数aaa console.log('暂停后，再次执行'); yield 'generator'; console.log('遍历完毕'); return '返回的结果';&#125;let mg = myGenerator();// 返回的是指针对象console.log(mg);console.log(mg.next());// &#123;value: \"hello\", done: false&#125;console.log(mg.next('传入的参数aaa'));// &#123;value: \"generator\", done: false&#125;console.log(mg.next());// &#123;value: \"返回的结果\", done: true&#125;// 对象的symbol.iterator属性 指向遍历器对象let obj = &#123;username: 'kobe', age: 39&#125;;obj[Symbol.iterator] = function* myTest()&#123; yield 1 yield 2 yield 3&#125;for(let i of obj)&#123; console.log(i);&#125; 应用案例： 12345678910111213141516171819202122/* * 需求： * 1、发送ajax请求获取新闻内容 * 2、新闻内容获取成功后再次发送请求，获取对应的新闻评论内容 * 3、新闻内容获取失败则不需要再次发送请求。 * */ function getNews(url)&#123; $.get(url, function (data)&#123; console.log(data); let url = 'http://localhost:3000' + data.commentsUrl; SX.next(url); &#125;) &#125; function* sendXml()&#123; let url = yield getNews('http://localhost:3000/news?id=3'); yield getNews(url); &#125; // 获取遍历器对象 let SX = sendXml(); SX.next(); async函数12345678910111213async函数(源自ES2017)概念： 真正意义上去解决异步回调的问题，同步流程表达异步操作本质： Generator的语法糖语法： async function foo()&#123; await 异步操作; await 异步操作； &#125;特点： 1、不需要像Generator去调用next方法，遇到await等待，当前的异步操作完成就往下执行 2、返回的总是Promise对象，可以用then方法进行下一步操作 3、async取代Generator函数的星号*，await取代Generator的yield 4、语意上更为明确，使用简单，经临床验证，暂时没有任何副作用 示例代码： 12345678910111213// async基本使用function foo()&#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, 2000); &#125;)&#125;async function test()&#123; console.log('开始执行', new Date().toTimeString()); await foo(); console.log('执行完毕。。。', new Date().toTimeString());&#125;test(); 应用案例： 12345678910111213141516171819// 获取新闻内容async function getNews(url)&#123; return new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; method: 'GET', url, success: data =&gt; resolve(data), error: error =&gt; reject(error) &#125;) &#125;)&#125;async function sendXml()&#123; let result = await getNews('http://localhost:3000/news?id=3'); console.log(result); result = await getNews('http://localhost:3000' + result.commentsUrl); console.log(result);&#125;sendXml(); class面向对象1234561. 通过class定义类&#x2F;实现类的继承2. 在类中通过constructor定义构造方法3. 通过new来创建类的实例4. 通过extends来实现类的继承5. 通过super调用父类的构造方法6. 重写从父类中继承的一般方法 示例代码： 12345678910111213141516171819202122232425262728293031// 定义一个人物的类class Person&#123; // 类的构造方法 constructor(name, age)&#123; this.name = name; this.age = age; &#125; // 类的一般方法 showName()&#123; console.log(this.name, this.age); &#125;&#125;let person = new Person('kobe', 39);console.log(person);person.showName();// 子类class StarPerson extends Person&#123; constructor(name, age, salary)&#123; super(name, age);// 调用父类的构造方法 this.salary = salary; &#125; // 子类的方法重写 showName()&#123; console.log(this.name, this.age, this.salary); &#125;&#125;let p1 = new StarPerson('wade', 36, 100000000);console.log(p1);p1.showName(); ModuleES6（其他）字符串扩展12341. includes(str) : 判断是否包含指定的字符串2. startsWith(str) : 判断是否以指定字符串开头3. endsWith(str) : 判断是否以指定字符串结尾4. repeat(count) : 重复指定次数 示例代码： 123456let str = 'abc';console.log(str.includes('t'));console.log(str.includes('a'));console.log(str.startsWith('a'));console.log(str.endsWith('f'));console.log(str.repeat(3));// abcabcabc 数值扩展1234561. 二进制与八进制数值表示法: 二进制用0b, 八进制用0o2. Number.isFinite(i) : 判断是否是有限大的数3. Number.isNaN(i) : 判断是否是NaN4. Number.isInteger(i) : 判断是否是整数5. Number.parseInt(str) : 将字符串转换为对应的数值6. Math.trunc(i) : 直接去除小数部分 示例代码： 123456789console.log(0b1010);// 10console.log(0o56);// 46console.log(Number.isFinite(Infinity));// falseconsole.log(Number.isNaN(NaN));// trueconsole.log(Number.isInteger(123.12));// falseconsole.log(Number.isInteger(123.0));// trueconsole.log(Number.parseInt('123abc222'));// 123console.log(Number.parseInt('abc222'));// NaNconsole.log(Math.trunc(123.12));// 123 数组扩展12341. Array.from(v) : 将伪数组对象或可遍历对象转换为真数组2. Array.of(v1, v2, v3) : 将一系列值转换成数组3. find(function(value, index, arr)&#123;return true&#125;) : 找出第一个满足条件返回true的元素4. findIndex(function(value, index, arr)&#123;return true&#125;) : 找出第一个满足条件返回true的元素下标 示例代码： 123456789101112131415161718let btns = document.getElementsByTagName('button');console.log(btns);Array.from(btns).forEach(function(item, index)&#123; console.log(item);&#125;)let arr = Array.of(1,3,'abc',true);console.log(arr);let arr2 = [2,3,4,2,5,7,3,6,5];let result = arr2.find(function(item, index)&#123; return item &gt; 4;&#125;)console.log(result);result = arr2.findIndex(function(item, index)&#123; return item &gt; 4;&#125;)console.log(result); Object扩展12345671. Object.is(v1, v2) * 判断2个数据是否完全相等（其实是用字符串比较）2. Object.assign(target, source1, source2..) * 将源对象的属性复制到目标对象上3. 直接操作 __proto__ 属性 let obj2 &#x3D; &#123;&#125;; obj2.__proto__ &#x3D; obj1; 示例代码： 12345678910111213141516console.log(0 == -0);// trueconsole.log(NaN == NaN);// falseconsole.log(Object.is(0, -0));// falseconsole.log(Object.is(NaN, NaN));// truelet obj = &#123;&#125;;let obj1 = &#123;username: 'iverson', age:42&#125;;let obj2 = &#123;sex: '男'&#125;;Object.assign(obj, obj1, obj2);console.log(obj);let obj3 = &#123;&#125;;let obj4 = &#123;qian: 5000000&#125;;obj3.__proto__ = obj4;console.log(obj3);console.log(obj3.qian); 深度克隆123456789101112131415161718192021221、数据类型： * 数据分为基本的数据类型(String, Number, boolean, Null, Undefined)和对象数据类型 - 基本数据类型： 特点： 存储的是该对象的实际数据 - 对象数据类型： 特点： 存储的是该对象在栈中引用，真实的数据存放在堆内存里2、复制数据 - 基本数据类型存放的就是实际的数据，可直接复制 let number2 &#x3D; 2; let number1 &#x3D; number2; - 克隆数据：对象&#x2F;数组 1、区别： 浅拷贝&#x2F;深度拷贝 判断： 拷贝是否产生了新的数据还是拷贝的是数据的引用 知识点：对象数据存放的是对象在栈内存的引用，直接复制的是对象的引用 let obj &#x3D; &#123;username: &#39;kobe&#39;&#125; let obj1 &#x3D; obj; &#x2F;&#x2F; obj1 复制了obj在栈内存的引用 2、常用的拷贝技术 1). arr.concat(): 数组浅拷贝 2). arr.slice(): 数组浅拷贝 3). JSON.parse(JSON.stringify(arr&#x2F;obj)): 数组或对象深拷贝, 但不能处理函数数据 4). 浅拷贝包含函数数据的对象&#x2F;数组 5). 深拷贝包含函数数据的对象&#x2F;数组 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 不会影响原数据let str = 'abcd';let str2 = str;console.log(str2);str2 = '';console.log(str);let bool1 = true;let bool2 = bool1;bool2 = false;console.log(bool1);// 拷贝数组/对象，没有生成新的数据而是复制了一份引用let obj = &#123;username: 'kobe', age: 39&#125;;let obj2 = obj;console.log(obj2);obj2.username = 'wade';console.log(obj.username);let arr = [1, 4, &#123;username: 'kobe', age: 39&#125;];let arr2 = arr;arr2[0] = 'abcd';console.log(arr, arr2);/** * 拷贝数据： * 基本数据类型： * 拷贝后会生成一份新的数据，修改拷贝以后的数据不会影响原数据 * 对象/数组： * 拷贝后不会生成新的数据，而是拷贝的引用。修改拷贝以后的数据会影响原来的数据 * * 拷贝数据的方法： * 1.直接赋值给一个变量 // 浅拷贝 * 2.Object.assign() // 浅拷贝 * 3.Array.prototype.concat() // 浅拷贝 * 4.Array.prototype.slice() // 浅拷贝 * 5.JSON.parse(JSON.stringify()) // 深拷贝（深度克隆），但不能处理函数数据 * * 浅拷贝（对象/数组） * 特点：拷贝的引用，修改拷贝以后的数据会影响原数据，使得原数据不安全 * 深拷贝（深度克隆） * 特点：拷贝的时候生成新数据，修改拷贝以后的数据不会影响原数据 */&#123;let obj = &#123;username: 'kobe'&#125;;let obj2 = Object.assign(obj);console.log(obj2);obj.username = 'wade';console.log(obj2);let arr = [1, 3, &#123;username: 'kobe'&#125;, function fun()&#123;&#125;];let arr2 = arr.concat();arr2[0] = 2;// 这个修改不影响arr的第一个元素，因为是复制的基本类型arr2[2].username = 'wade';// 这个修改会影响原数据，因为复制是对象的引用console.log(arr);let arr3 = arr.slice();arr3[2].username = 'iverson';// 会影响console.log(arr);let arr4 = JSON.parse(JSON.stringify(arr));console.log(arr4);arr4[2].username = 'duncan';// 不影响console.log(arr, arr4); 实现深度克隆前的知识储备： 12345678910111213141516171819202122/** * 思考：如何实现深度拷贝（克隆） * 即使有对象/数组，也可以继续遍历对象/数组拿到里边每一项值，直到拿到的是基本数据类型，然后再去复制，就是深度拷贝 * * 如何判断数据类型：arr --&gt; Array null --&gt; Null * 1.typeof返回的数据类型：String, Number, Boolean, Undefined, Object, Function * 2.Object.prototype.toString.call(this) */let result= 'abcd';result = null;result = [1, 3];console.log(Object.prototype.toString.call(result).slice(8, -1));// for in循环，对象（属性名） 数组（下标）let obj6 = &#123;username: 'kobe', age: 39&#125;;for (let i in obj6)&#123; console.log(i);&#125;let arr6 = [1, 3, 'abc'];for (let i in arr6)&#123; console.log(i);&#125; 实现深度克隆： 123456789101112131415161718192021222324252627282930313233343536373839404142// 定义检测数据类型的功能函数function checkType(target)&#123; return Object.prototype.toString.call(target).slice(8, -1);&#125;// 实现深度克隆 --&gt; 对象/数组function clone(target)&#123; // 判断拷贝的数据类型 // 初始化变量result成为最终克隆的数据 let result, targetType = checkType(target); if(targetType === 'Object')&#123; result = &#123;&#125;; &#125;else if(targetType === 'Array')&#123; result = []; &#125;else&#123; return target; &#125; // 遍历目标数据 for(let i in target)&#123; // 获取遍历数据结构的每一项值 let value = target[i]; // 判断目标结构里的每一项值是否存在对象/数组 if(checkType(value) === 'Object' || checkType(value) === 'Array')&#123;// 对象/数组里嵌套了对象/数组 // 继续遍历获取到的value值 result[i] = clone(value); &#125;else&#123;// 获取到的value值是基本的数据类型或函数 result[i] = value; &#125; &#125; return result;&#125;let arr7 = [1, 2, &#123;username: 'kobe', age:39&#125;];let arr8 = clone(arr7);console.log(arr8);arr8[2].username = 'wade';console.log(arr7, arr8);let obj7 = &#123;username: 'kobe', age: 39&#125;;let obj8 = clone(obj7);console.log(obj8);obj8.username = 'wade';console.log(obj7, obj8); Set和Map12345678910111213141516171. Set容器 : 无序不可重复的多个value的集合体 * Set() * Set(array) * add(value) * delete(value) * has(value) * clear() * size2. Map容器 : 无序的 key不重复的多个key-value的集合体 * Map() * Map(array) * set(key, value)&#x2F;&#x2F;添加 * get(key) * delete(key) * has(key) * clear() * size 示例代码： 123456789101112131415161718let set = new Set([1,2,4,5,2,3,6]);console.log(set);set.add(7);console.log(set.size, set);console.log(set.has(8));// falseconsole.log(set.has(7));// trueset.delete(4);console.log(set);set.clear();console.log(set);let map = new Map([['username', 'kobe'], [36, 'age']]);console.log(map);map.set(78, 'haha');console.log(map);map.delete(36);console.log(map);console.log(map.size); for of循环123456for(let value of target)&#123;&#125;循环遍历 1. 遍历数组 2. 遍历Set 3. 遍历Map 4. 遍历字符串 5. 遍历伪数组 示例代码： 123456789101112131415// 数组去重let arr = [1,2,4,5,5,6,2];let arr1 = arr;arr = [];let set = new Set(arr1);for (let i of set)&#123; arr.push(i);&#125;console.log(arr);// 遍历伪数组let btns = document.getElementsByTagName('button');for(let i of btns)&#123; console.log(i);&#125; ES7121. 指数运算符(幂): **2. Array.prototype.includes(value) : 判断数组中是否包含指定value 示例代码： 123console.log(3 ** 3);// 27let arr = [1,4,5,6,'abc'];console.log(arr.includes(6));// true","tags":[{"name":"前端","slug":"前端","permalink":"https://sunshine-zwq.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"https://sunshine-zwq.github.io/tags/ECMAScript/"}]}]